From 1ed52a4d5b8c96fd5b052d044c05ccb5f4a5827c Mon Sep 17 00:00:00 2001
From: Carlo Caione <carlo.caione@gmail.com>
Date: Thu, 2 Jan 2014 10:00:36 +0100
Subject: [PATCH 1/2] Imported Renesas patch v2.0.0

Signed-off-by: Carlo Caione <carlo.caione@gmail.com>
---
 Makefile                                   |    2 +-
 arch/arm/boot/dts/Makefile                 |    1 +
 arch/arm/boot/dts/rza1-rskrza1.dts         |   27 +
 arch/arm/configs/rskrza1_defconfig         | 2562 ++++++++++++++++++++++++++++
 arch/arm/mach-shmobile/Kconfig             |   21 +
 arch/arm/mach-shmobile/Makefile            |    2 +
 arch/arm/mach-shmobile/board-rskrza1.c     |  400 +++++
 arch/arm/mach-shmobile/clock-rza1.c        |  275 +++
 arch/arm/mach-shmobile/include/mach/rtc.h  |   44 +
 arch/arm/mach-shmobile/include/mach/rza1.h |   69 +
 arch/arm/mach-shmobile/intc-rza1.c         |   41 +
 arch/arm/mach-shmobile/pfc-rza1.c          |  300 ++++
 arch/arm/mach-shmobile/rskrza1-vdc5fb.c    |  639 +++++++
 arch/arm/mach-shmobile/setup-rza1.c        | 1016 +++++++++++
 arch/arm/tools/mach-types                  |    1 +
 drivers/dma/Kconfig                        |    8 +
 drivers/dma/Makefile                       |    1 +
 drivers/dma/rza1dma.c                      |  996 +++++++++++
 drivers/i2c/busses/Kconfig                 |    9 +
 drivers/i2c/busses/Makefile                |    1 +
 drivers/i2c/busses/i2c-riic.c              | 1364 +++++++++++++++
 drivers/iio/adc/Kconfig                    |    8 +
 drivers/iio/adc/Makefile                   |    1 +
 drivers/iio/adc/sh_adc.c                   |  763 +++++++++
 drivers/mfd/Kconfig                        |    7 +
 drivers/mfd/Makefile                       |    1 +
 drivers/mfd/raa730300.c                    |  291 ++++
 drivers/mmc/host/Kconfig                   |   13 +
 drivers/mmc/host/sh_mmcif.c                |   15 +-
 drivers/mmc/host/tmio_mmc.h                |    8 +
 drivers/mmc/host/tmio_mmc_pio.c            |   21 +-
 drivers/net/ethernet/renesas/Kconfig       |    2 +-
 drivers/net/ethernet/renesas/sh_eth.c      |   65 +-
 drivers/net/ethernet/renesas/sh_eth.h      |    4 +-
 drivers/rtc/Kconfig                        |    2 +-
 drivers/rtc/rtc-sh.c                       |   36 +-
 drivers/spi/Kconfig                        |    8 +-
 drivers/spi/Makefile                       |    1 +
 drivers/spi/spi-rspi.c                     |  272 ++-
 drivers/spi/spi-sh-spibsc.c                |  818 +++++++++
 drivers/spi/spi.c                          |    4 +
 drivers/usb/host/r8a66597-hcd.c            |   49 +-
 drivers/usb/host/r8a66597.h                |    4 +-
 drivers/video/Kconfig                      |    1 +
 drivers/video/Makefile                     |    1 +
 drivers/video/renesas/Kconfig              |   35 +
 drivers/video/renesas/Makefile             |    6 +
 drivers/video/renesas/vdc5fb-regs.h        | 1121 ++++++++++++
 drivers/video/renesas/vdc5fb.c             | 1339 +++++++++++++++
 fs/fuse/Kconfig                            |    1 +
 include/linux/i2c/riic.h                   |   42 +
 include/linux/platform_data/dma-rza1.h     |   77 +
 include/linux/platform_data/sh_adc.h       |   29 +
 include/linux/spi/rspi.h                   |    6 +-
 include/linux/spi/sh_spibsc.h              |   24 +
 include/linux/spi/smanalog.h               |   25 +
 include/linux/spi/spi.h                    |   17 +
 include/linux/usb/r8a66597.h               |  332 +++-
 include/sound/sh_scux.h                    | 1322 ++++++++++++++
 include/uapi/Kbuild                        |    1 +
 include/uapi/mfd/Kbuild                    |    2 +
 include/uapi/mfd/raa730300.h               |   28 +
 include/video/vdc5fb.h                     |  126 ++
 sound/soc/codecs/wm8978.c                  |  111 +-
 sound/soc/sh/Kconfig                       |   23 +
 sound/soc/sh/Makefile                      |    4 +
 sound/soc/sh/genmai.c                      |  585 +++++++
 sound/soc/sh/scux_dai.c                    | 1214 +++++++++++++
 sound/soc/sh/scux_pcm.c                    |  687 ++++++++
 69 files changed, 17257 insertions(+), 74 deletions(-)
 create mode 100644 arch/arm/boot/dts/rza1-rskrza1.dts
 create mode 100644 arch/arm/configs/rskrza1_defconfig
 create mode 100644 arch/arm/mach-shmobile/board-rskrza1.c
 create mode 100644 arch/arm/mach-shmobile/clock-rza1.c
 create mode 100644 arch/arm/mach-shmobile/include/mach/rtc.h
 create mode 100644 arch/arm/mach-shmobile/include/mach/rza1.h
 create mode 100644 arch/arm/mach-shmobile/intc-rza1.c
 create mode 100644 arch/arm/mach-shmobile/pfc-rza1.c
 create mode 100644 arch/arm/mach-shmobile/rskrza1-vdc5fb.c
 create mode 100644 arch/arm/mach-shmobile/setup-rza1.c
 create mode 100644 drivers/dma/rza1dma.c
 create mode 100644 drivers/i2c/busses/i2c-riic.c
 create mode 100644 drivers/iio/adc/sh_adc.c
 create mode 100644 drivers/mfd/raa730300.c
 create mode 100644 drivers/spi/spi-sh-spibsc.c
 create mode 100644 drivers/video/renesas/Kconfig
 create mode 100644 drivers/video/renesas/Makefile
 create mode 100644 drivers/video/renesas/vdc5fb-regs.h
 create mode 100644 drivers/video/renesas/vdc5fb.c
 create mode 100644 include/linux/i2c/riic.h
 create mode 100644 include/linux/platform_data/dma-rza1.h
 create mode 100644 include/linux/platform_data/sh_adc.h
 create mode 100644 include/linux/spi/sh_spibsc.h
 create mode 100644 include/linux/spi/smanalog.h
 create mode 100644 include/sound/sh_scux.h
 create mode 100644 include/uapi/mfd/Kbuild
 create mode 100644 include/uapi/mfd/raa730300.h
 create mode 100644 include/video/vdc5fb.h
 create mode 100644 sound/soc/sh/genmai.c
 create mode 100644 sound/soc/sh/scux_dai.c
 create mode 100644 sound/soc/sh/scux_pcm.c

diff --git a/Makefile b/Makefile
index 183eff3..3814945 100644
--- a/Makefile
+++ b/Makefile
@@ -1,7 +1,7 @@
 VERSION = 3
 PATCHLEVEL = 8
 SUBLEVEL = 13
-EXTRAVERSION =
+EXTRAVERSION = -RZLSP-V2.0.0
 NAME = Displaced Humerus Anterior
 
 # *DOCUMENTATION*
diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile
index 5ebb44f..6bdf03d 100644
--- a/arch/arm/boot/dts/Makefile
+++ b/arch/arm/boot/dts/Makefile
@@ -123,6 +123,7 @@ dtb-$(CONFIG_ARCH_U8500) += snowball.dtb \
 dtb-$(CONFIG_ARCH_SHMOBILE) += emev2-kzm9d.dtb \
 	r8a7740-armadillo800eva.dtb \
 	sh73a0-kzm9g.dtb \
+	rza1-rskrza1.dtb \
 	sh7372-mackerel.dtb
 dtb-$(CONFIG_ARCH_SPEAR13XX) += spear1310-evb.dtb \
 	spear1340-evb.dtb
diff --git a/arch/arm/boot/dts/rza1-rskrza1.dts b/arch/arm/boot/dts/rza1-rskrza1.dts
new file mode 100644
index 0000000..f38b31c
--- /dev/null
+++ b/arch/arm/boot/dts/rza1-rskrza1.dts
@@ -0,0 +1,27 @@
+/*
+ * Device Tree Source for the RSKRZA1 board
+ *
+ * Copyright (C) 2012-2013 Renesas Solutions Corp.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+/include/ "skeleton.dtsi"
+
+/ {
+	model = "RSKRZA1";
+	compatible = "renesas,rskrza1", "renesas,sh73a0";
+
+	memory {
+		device_type = "memory";
+		reg = <0x08000000 0x08000000>;
+	};
+};
diff --git a/arch/arm/configs/rskrza1_defconfig b/arch/arm/configs/rskrza1_defconfig
new file mode 100644
index 0000000..a4c7816
--- /dev/null
+++ b/arch/arm/configs/rskrza1_defconfig
@@ -0,0 +1,2562 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm 3.8.13-RZLSP-V2.0.0 Kernel Configuration
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_NO_IOPORT=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_ARM_PATCH_PHYS_VIRT=y
+CONFIG_NEED_MACH_MEMORY_H=y
+CONFIG_GENERIC_BUG=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_HAVE_IRQ_WORK=y
+CONFIG_IRQ_WORK=y
+CONFIG_BUILDTIME_EXTABLE_SORT=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_XZ is not set
+# CONFIG_KERNEL_LZO is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_FHANDLE is not set
+# CONFIG_AUDIT is not set
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_SPARSE_IRQ=y
+CONFIG_KTIME_SCALAR=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+
+#
+# Timers subsystem
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+
+#
+# CPU/Task time and stats accounting
+#
+CONFIG_TICK_CPU_ACCOUNTING=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TINY_PREEMPT_RCU=y
+CONFIG_PREEMPT_RCU=y
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_RCU_BOOST is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=16
+# CONFIG_CGROUPS is not set
+# CONFIG_CHECKPOINT_RESTORE is not set
+CONFIG_NAMESPACES=y
+CONFIG_UTS_NS=y
+CONFIG_IPC_NS=y
+CONFIG_PID_NS=y
+CONFIG_NET_NS=y
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+# CONFIG_RELAY is not set
+# CONFIG_BLK_DEV_INITRD is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_EXPERT=y
+CONFIG_HAVE_UID16=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_EMBEDDED=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_COMPAT_BRK=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+# CONFIG_JUMP_LABEL is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_ATTRS=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_HW_BREAKPOINT=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_ARCH_WANT_IPC_PARSE_VERSION=y
+CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+CONFIG_HAVE_MOD_ARCH_SPECIFIC=y
+CONFIG_MODULES_USE_ELF_REL=y
+CONFIG_CLONE_BACKWARDS=y
+
+#
+# GCOV-based kernel profiling
+#
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_MODULE_SIG is not set
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+CONFIG_BLK_DEV_BSG=y
+# CONFIG_BLK_DEV_BSGLIB is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_EFI_PARTITION=y
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_UNINLINE_SPIN_UNLOCK=y
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_MULTIPLATFORM is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_BCM2835 is not set
+# CONFIG_ARCH_CNS3XXX is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_SIRF is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_MXS is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_LPC32XX is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+CONFIG_ARCH_SHMOBILE=y
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C24XX is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_S5P64X0 is not set
+# CONFIG_ARCH_S5PC100 is not set
+# CONFIG_ARCH_S5PV210 is not set
+# CONFIG_ARCH_EXYNOS is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_U8500 is not set
+# CONFIG_ARCH_NOMADIK is not set
+# CONFIG_PLAT_SPEAR is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_VT8500_SINGLE is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_KEYBOARD_GPIO_POLLED is not set
+
+#
+# SH-Mobile System Type
+#
+# CONFIG_ARCH_SH7372 is not set
+# CONFIG_ARCH_SH73A0 is not set
+# CONFIG_ARCH_R8A7740 is not set
+# CONFIG_ARCH_R8A7779 is not set
+# CONFIG_ARCH_EMEV2 is not set
+CONFIG_ARCH_RZA1=y
+
+#
+# SH-Mobile Board Type
+#
+CONFIG_MACH_RSKRZA1=y
+
+#
+# SH-Mobile System Configuration
+#
+CONFIG_CPU_HAS_INTEVT=y
+
+#
+# Memory configuration
+#
+CONFIG_MEMORY_START=0x08000000
+CONFIG_MEMORY_SIZE=0x08000000
+
+#
+# Timer and clock configuration
+#
+CONFIG_SHMOBILE_TIMER_HZ=128
+CONFIG_SH_TIMER_CMT=y
+CONFIG_SH_TIMER_TMU=y
+CONFIG_EM_TIMER_STI=y
+CONFIG_SH_TIMER_MTU2=y
+CONFIG_SH_CLK_CPG=y
+
+#
+# SuperH / SH-Mobile Driver Options
+#
+CONFIG_SH_INTC=y
+
+#
+# Interrupt controller options
+#
+# CONFIG_INTC_USERIMASK is not set
+
+#
+# Pin function controller options
+#
+CONFIG_SH_PFC=y
+CONFIG_PINCTRL_SH_PFC=y
+CONFIG_GPIO_SH_PFC=y
+# CONFIG_ARCH_VT8500 is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_V7=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_32v7=y
+CONFIG_CPU_ABRT_EV7=y
+CONFIG_CPU_PABRT_V7=y
+CONFIG_CPU_CACHE_V7=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V7=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_LPAE is not set
+# CONFIG_ARCH_PHYS_ADDR_T_64BIT is not set
+CONFIG_ARM_THUMB=y
+# CONFIG_ARM_THUMBEE is not set
+# CONFIG_ARM_VIRT_EXT is not set
+# CONFIG_SWP_EMULATE is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_OUTER_CACHE=y
+CONFIG_OUTER_CACHE_SYNC=y
+CONFIG_MIGHT_HAVE_CACHE_L2X0=y
+CONFIG_CACHE_L2X0=y
+CONFIG_CACHE_PL310=y
+CONFIG_ARM_L1_CACHE_SHIFT_6=y
+CONFIG_ARM_L1_CACHE_SHIFT=6
+CONFIG_ARM_DMA_MEM_BUFFERABLE=y
+CONFIG_ARM_NR_BANKS=8
+CONFIG_MULTI_IRQ_HANDLER=y
+# CONFIG_ARM_ERRATA_430973 is not set
+# CONFIG_ARM_ERRATA_458693 is not set
+# CONFIG_ARM_ERRATA_460075 is not set
+# CONFIG_PL310_ERRATA_588369 is not set
+# CONFIG_ARM_ERRATA_720789 is not set
+# CONFIG_PL310_ERRATA_727915 is not set
+CONFIG_ARM_ERRATA_743622=y
+# CONFIG_ARM_ERRATA_751472 is not set
+# CONFIG_PL310_ERRATA_753970 is not set
+CONFIG_ARM_ERRATA_754322=y
+# CONFIG_PL310_ERRATA_769419 is not set
+# CONFIG_ARM_ERRATA_775420 is not set
+CONFIG_ARM_GIC=y
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_HAVE_SMP=y
+# CONFIG_SMP is not set
+# CONFIG_ARM_ARCH_TIMER is not set
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_ARCH_NR_GPIO=1024
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_PREEMPT_COUNT=y
+CONFIG_HZ=128
+# CONFIG_THUMB2_KERNEL is not set
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_HAVE_ARCH_PFN_VALID=y
+CONFIG_HIGHMEM=y
+# CONFIG_HIGHPTE is not set
+CONFIG_HW_PERF_EVENTS=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_COMPACTION=y
+CONFIG_MIGRATION=y
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_CROSS_MEMORY_ATTACH=y
+CONFIG_NEED_PER_CPU_KM=y
+# CONFIG_CLEANCACHE is not set
+# CONFIG_FRONTSWAP is not set
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_SECCOMP is not set
+# CONFIG_CC_STACKPROTECTOR is not set
+# CONFIG_XEN is not set
+
+#
+# Boot options
+#
+CONFIG_USE_OF=y
+# CONFIG_ATAGS is not set
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+# CONFIG_ARM_APPENDED_DTB is not set
+CONFIG_CMDLINE=""
+# CONFIG_XIP_KERNEL is not set
+CONFIG_KEXEC=y
+# CONFIG_CRASH_DUMP is not set
+# CONFIG_AUTO_ZRELADDR is not set
+
+#
+# CPU Power Management
+#
+# CONFIG_CPU_IDLE is not set
+# CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_FPE_NWFPE is not set
+# CONFIG_FPE_FASTFPE is not set
+CONFIG_VFP=y
+CONFIG_VFPv3=y
+CONFIG_NEON=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE=y
+CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+CONFIG_COREDUMP=y
+
+#
+# Power management options
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_PM_SLEEP=y
+# CONFIG_PM_AUTOSLEEP is not set
+# CONFIG_PM_WAKELOCKS is not set
+CONFIG_PM_RUNTIME=y
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+# CONFIG_APM_EMULATION is not set
+CONFIG_PM_CLK=y
+CONFIG_PM_GENERIC_DOMAINS=y
+CONFIG_PM_GENERIC_DOMAINS_SLEEP=y
+CONFIG_PM_GENERIC_DOMAINS_RUNTIME=y
+CONFIG_CPU_PM=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARM_CPU_SUSPEND=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_DIAG is not set
+CONFIG_UNIX=y
+# CONFIG_UNIX_DIAG is not set
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_NET_IPVTI is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+CONFIG_INET_TUNNEL=m
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+CONFIG_INET_LRO=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_INET_UDP_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=m
+# CONFIG_IPV6_PRIVACY is not set
+# CONFIG_IPV6_ROUTER_PREF is not set
+# CONFIG_IPV6_OPTIMISTIC_DAD is not set
+# CONFIG_INET6_AH is not set
+# CONFIG_INET6_ESP is not set
+# CONFIG_INET6_IPCOMP is not set
+# CONFIG_IPV6_MIP6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+CONFIG_INET6_XFRM_MODE_TRANSPORT=m
+CONFIG_INET6_XFRM_MODE_TUNNEL=m
+CONFIG_INET6_XFRM_MODE_BEET=m
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+CONFIG_IPV6_SIT=m
+# CONFIG_IPV6_SIT_6RD is not set
+CONFIG_IPV6_NDISC_NODETYPE=y
+# CONFIG_IPV6_TUNNEL is not set
+# CONFIG_IPV6_GRE is not set
+# CONFIG_IPV6_MULTIPLE_TABLES is not set
+# CONFIG_IPV6_MROUTE is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+CONFIG_HAVE_NET_DSA=y
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+CONFIG_DNS_RESOLVER=y
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+CONFIG_BQL=y
+# CONFIG_BPF_JIT is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+CONFIG_IRDA=y
+
+#
+# IrDA protocols
+#
+# CONFIG_IRLAN is not set
+# CONFIG_IRCOMM is not set
+# CONFIG_IRDA_ULTRA is not set
+
+#
+# IrDA options
+#
+# CONFIG_IRDA_CACHE_LAST_LSAP is not set
+# CONFIG_IRDA_FAST_RR is not set
+# CONFIG_IRDA_DEBUG is not set
+
+#
+# Infrared-port device drivers
+#
+
+#
+# SIR device drivers
+#
+# CONFIG_IRTTY_SIR is not set
+
+#
+# Dongle support
+#
+# CONFIG_KINGSUN_DONGLE is not set
+# CONFIG_KSDAZZLE_DONGLE is not set
+# CONFIG_KS959_DONGLE is not set
+
+#
+# FIR device drivers
+#
+# CONFIG_USB_IRDA is not set
+# CONFIG_SIGMATEL_FIR is not set
+# CONFIG_MCS_FIR is not set
+CONFIG_SH_IRDA=y
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_WIRELESS=y
+# CONFIG_CFG80211 is not set
+# CONFIG_LIB80211 is not set
+
+#
+# CFG80211 needs to be enabled for MAC80211
+#
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+CONFIG_HAVE_BPF_JIT=y
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+# CONFIG_DEVTMPFS is not set
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_GENERIC_CPU_DEVICES is not set
+CONFIG_REGMAP=y
+CONFIG_REGMAP_I2C=y
+CONFIG_REGMAP_SPI=y
+# CONFIG_DMA_SHARED_BUFFER is not set
+# CONFIG_CMA is not set
+
+#
+# Bus devices
+#
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+# CONFIG_MTD_AFS_PARTS is not set
+CONFIG_MTD_OF_PARTS=y
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_SM_FTL is not set
+# CONFIG_MTD_OOPS is not set
+# CONFIG_MTD_SWAP is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+CONFIG_MTD_CFI_AMDSTD=y
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+CONFIG_MTD_PHYSMAP=y
+# CONFIG_MTD_PHYSMAP_COMPAT is not set
+# CONFIG_MTD_PHYSMAP_OF is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+CONFIG_MTD_M25P80=y
+CONFIG_M25PXX_USE_FAST_READ=y
+# CONFIG_MTD_SST25L is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOCG3 is not set
+# CONFIG_MTD_NAND is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+# CONFIG_MTD_UBI is not set
+CONFIG_DTC=y
+CONFIG_OF=y
+
+#
+# Device Tree and Open Firmware support
+#
+# CONFIG_PROC_DEVICETREE is not set
+# CONFIG_OF_SELFTEST is not set
+CONFIG_OF_FLATTREE=y
+CONFIG_OF_EARLY_FLATTREE=y
+CONFIG_OF_ADDRESS=y
+CONFIG_OF_IRQ=y
+CONFIG_OF_DEVICE=y
+CONFIG_OF_I2C=y
+CONFIG_OF_NET=y
+CONFIG_OF_MDIO=y
+CONFIG_OF_MTD=y
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_DRBD is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MG_DISK is not set
+# CONFIG_BLK_DEV_RBD is not set
+
+#
+# Misc devices
+#
+# CONFIG_SENSORS_LIS3LV02D is not set
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_ATMEL_PWM is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1780 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_TI_DAC7512 is not set
+# CONFIG_BMP085_I2C is not set
+# CONFIG_BMP085_SPI is not set
+# CONFIG_USB_SWITCH_FSA9480 is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_AT25 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_EEPROM_93XX46 is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_TI_ST is not set
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
+
+#
+# Altera FPGA firmware download module
+#
+# CONFIG_ALTERA_STAPL is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_ISCSI_BOOT_SYSFS is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+# CONFIG_TARGET_CORE is not set
+CONFIG_NETDEVICES=y
+CONFIG_NET_CORE=y
+# CONFIG_BONDING is not set
+# CONFIG_DUMMY is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_MII=y
+# CONFIG_NET_TEAM is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_VXLAN is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+
+#
+# CAIF transport drivers
+#
+
+#
+# Distributed Switch Architecture drivers
+#
+# CONFIG_NET_DSA_MV88E6XXX is not set
+# CONFIG_NET_DSA_MV88E6060 is not set
+# CONFIG_NET_DSA_MV88E6XXX_NEED_PPU is not set
+# CONFIG_NET_DSA_MV88E6131 is not set
+# CONFIG_NET_DSA_MV88E6123_61_65 is not set
+CONFIG_ETHERNET=y
+CONFIG_NET_CADENCE=y
+# CONFIG_ARM_AT91_ETHER is not set
+# CONFIG_MACB is not set
+CONFIG_NET_VENDOR_BROADCOM=y
+# CONFIG_B44 is not set
+# CONFIG_NET_CALXEDA_XGMAC is not set
+CONFIG_NET_VENDOR_CIRRUS=y
+# CONFIG_CS89x0 is not set
+# CONFIG_DM9000 is not set
+# CONFIG_DNET is not set
+CONFIG_NET_VENDOR_FARADAY=y
+# CONFIG_FTMAC100 is not set
+# CONFIG_FTGMAC100 is not set
+CONFIG_NET_VENDOR_INTEL=y
+CONFIG_NET_VENDOR_I825XX=y
+CONFIG_NET_VENDOR_MARVELL=y
+# CONFIG_MVMDIO is not set
+CONFIG_NET_VENDOR_MICREL=y
+# CONFIG_KS8842 is not set
+# CONFIG_KS8851 is not set
+# CONFIG_KS8851_MLL is not set
+CONFIG_NET_VENDOR_MICROCHIP=y
+# CONFIG_ENC28J60 is not set
+CONFIG_NET_VENDOR_NATSEMI=y
+CONFIG_NET_VENDOR_8390=y
+# CONFIG_AX88796 is not set
+# CONFIG_ETHOC is not set
+CONFIG_SH_ETH=y
+CONFIG_NET_VENDOR_SEEQ=y
+# CONFIG_SEEQ8005 is not set
+CONFIG_NET_VENDOR_SMSC=y
+# CONFIG_SMC91X is not set
+# CONFIG_SMC911X is not set
+# CONFIG_SMSC911X is not set
+CONFIG_NET_VENDOR_STMICRO=y
+# CONFIG_STMMAC_ETH is not set
+CONFIG_NET_VENDOR_WIZNET=y
+# CONFIG_WIZNET_W5100 is not set
+# CONFIG_WIZNET_W5300 is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_AT803X_PHY is not set
+# CONFIG_AMD_PHY is not set
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_BCM87XX_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_MICREL_PHY is not set
+# CONFIG_FIXED_PHY is not set
+CONFIG_MDIO_BITBANG=y
+CONFIG_MDIO_GPIO=y
+# CONFIG_MDIO_BUS_MUX_GPIO is not set
+# CONFIG_MDIO_BUS_MUX_MMIOREG is not set
+# CONFIG_MICREL_KS8995MA is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_IPHETH is not set
+CONFIG_WLAN=y
+# CONFIG_USB_ZD1201 is not set
+# CONFIG_HOSTAP is not set
+# CONFIG_WL_TI is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+CONFIG_INPUT_SPARSEKMAP=y
+# CONFIG_INPUT_MATRIXKMAP is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ADP5588 is not set
+# CONFIG_KEYBOARD_ADP5589 is not set
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_QT1070 is not set
+# CONFIG_KEYBOARD_QT2160 is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+CONFIG_KEYBOARD_GPIO=y
+# CONFIG_KEYBOARD_TCA6416 is not set
+# CONFIG_KEYBOARD_TCA8418 is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_LM8323 is not set
+# CONFIG_KEYBOARD_LM8333 is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_MCS is not set
+# CONFIG_KEYBOARD_MPR121 is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_SAMSUNG is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_SH_KEYSC is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=y
+CONFIG_MOUSE_PS2_ALPS=y
+CONFIG_MOUSE_PS2_LOGIPS2PP=y
+CONFIG_MOUSE_PS2_SYNAPTICS=y
+CONFIG_MOUSE_PS2_TRACKPOINT=y
+# CONFIG_MOUSE_PS2_ELANTECH is not set
+# CONFIG_MOUSE_PS2_SENTELIC is not set
+# CONFIG_MOUSE_PS2_TOUCHKIT is not set
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_APPLETOUCH is not set
+# CONFIG_MOUSE_BCM5974 is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_MOUSE_GPIO is not set
+# CONFIG_MOUSE_SYNAPTICS_I2C is not set
+# CONFIG_MOUSE_SYNAPTICS_USB is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_SERIO_ARC_PS2 is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_VT_CONSOLE_SLEEP=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+CONFIG_DEVKMEM=y
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_MAX310X is not set
+CONFIG_SERIAL_SH_SCI=y
+CONFIG_SERIAL_SH_SCI_NR_UARTS=8
+CONFIG_SERIAL_SH_SCI_CONSOLE=y
+# CONFIG_SERIAL_SH_SCI_DMA is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_SCCNXP is not set
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_IFX6X60 is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_SERIAL_ARC is not set
+# CONFIG_TTY_PRINTK is not set
+# CONFIG_HVC_DCC is not set
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=m
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+# CONFIG_HW_RANDOM_ATMEL is not set
+# CONFIG_HW_RANDOM_EXYNOS is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+CONFIG_I2C_CHARDEV=y
+# CONFIG_I2C_MUX is not set
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_CBUS_GPIO is not set
+# CONFIG_I2C_DESIGNWARE_PLATFORM is not set
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_PXA_PCI is not set
+# CONFIG_I2C_SH_MOBILE is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+# CONFIG_I2C_RCAR is not set
+CONFIG_I2C_RIIC=y
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_DIOLAN_U2C is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_ALTERA is not set
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_SPI_GPIO is not set
+# CONFIG_SPI_OC_TINY is not set
+# CONFIG_SPI_PXA2XX_PCI is not set
+CONFIG_SPI_RSPI=y
+CONFIG_SPI_SH_SPIBSC=y
+# CONFIG_SPI_SC18IS602 is not set
+# CONFIG_SPI_SH_MSIOF is not set
+# CONFIG_SPI_SH_HSPI is not set
+# CONFIG_SPI_XCOMM is not set
+# CONFIG_SPI_XILINX is not set
+# CONFIG_SPI_DESIGNWARE is not set
+
+#
+# SPI Protocol Masters
+#
+CONFIG_SPI_SPIDEV=y
+# CONFIG_SPI_TLE62X0 is not set
+# CONFIG_HSI is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+# CONFIG_PTP_1588_CLOCK is not set
+
+#
+# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
+#
+# CONFIG_PTP_1588_CLOCK_PCH is not set
+CONFIG_PINCTRL=y
+
+#
+# Pin controllers
+#
+CONFIG_PINMUX=y
+CONFIG_PINCONF=y
+# CONFIG_DEBUG_PINCTRL is not set
+# CONFIG_PINCTRL_SINGLE is not set
+# CONFIG_PINCTRL_EXYNOS is not set
+# CONFIG_PINCTRL_EXYNOS5440 is not set
+CONFIG_ARCH_HAVE_CUSTOM_GPIO_H=y
+CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB=y
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+CONFIG_OF_GPIO=y
+# CONFIG_DEBUG_GPIO is not set
+CONFIG_GPIO_SYSFS=y
+
+#
+# Memory mapped GPIO drivers:
+#
+# CONFIG_GPIO_GENERIC_PLATFORM is not set
+# CONFIG_GPIO_EM is not set
+# CONFIG_GPIO_TS5500 is not set
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_SX150X is not set
+# CONFIG_GPIO_ADP5588 is not set
+# CONFIG_GPIO_ADNP is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MCP23S08 is not set
+# CONFIG_GPIO_MC33880 is not set
+# CONFIG_GPIO_74X164 is not set
+
+#
+# AC97 GPIO expanders:
+#
+
+#
+# MODULbus GPIO expanders:
+#
+
+#
+# USB GPIO expanders:
+#
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_POWER_AVS is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+# CONFIG_SENSORS_AD7314 is not set
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADCXX is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7410 is not set
+# CONFIG_SENSORS_ADT7411 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7475 is not set
+# CONFIG_SENSORS_ASC7621 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS620 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_G760A is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_GPIO_FAN is not set
+# CONFIG_SENSORS_HIH6130 is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_JC42 is not set
+# CONFIG_SENSORS_LINEAGE is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM70 is not set
+# CONFIG_SENSORS_LM73 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LTC4151 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LTC4261 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_LM95245 is not set
+# CONFIG_SENSORS_MAX1111 is not set
+# CONFIG_SENSORS_MAX16065 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX1668 is not set
+# CONFIG_SENSORS_MAX197 is not set
+# CONFIG_SENSORS_MAX6639 is not set
+# CONFIG_SENSORS_MAX6642 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_MCP3021 is not set
+# CONFIG_SENSORS_NTC_THERMISTOR is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_PMBUS is not set
+# CONFIG_SENSORS_SHT15 is not set
+# CONFIG_SENSORS_SHT21 is not set
+# CONFIG_SENSORS_SMM665 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_EMC1403 is not set
+# CONFIG_SENSORS_EMC2103 is not set
+# CONFIG_SENSORS_EMC6W201 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SCH56XX_COMMON is not set
+# CONFIG_SENSORS_ADS1015 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_ADS7871 is not set
+# CONFIG_SENSORS_AMC6821 is not set
+# CONFIG_SENSORS_INA2XX is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_TMP102 is not set
+# CONFIG_SENSORS_TMP401 is not set
+# CONFIG_SENSORS_TMP421 is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83795 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_THERMAL is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_88PM800 is not set
+# CONFIG_MFD_88PM805 is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_MFD_TI_AM335X_TSCADC is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_MFD_LM3533 is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS65217 is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_MFD_TPS65910 is not set
+# CONFIG_MFD_TPS65912_I2C is not set
+# CONFIG_MFD_TPS65912_SPI is not set
+# CONFIG_MFD_TPS80031 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_TWL6040_CORE is not set
+# CONFIG_MFD_STMPE is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_SMSC is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_DA9052_SPI is not set
+# CONFIG_MFD_DA9052_I2C is not set
+# CONFIG_MFD_DA9055 is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_LP8788 is not set
+# CONFIG_MFD_MAX77686 is not set
+# CONFIG_MFD_MAX77693 is not set
+# CONFIG_MFD_MAX8907 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_MFD_SEC_CORE is not set
+# CONFIG_MFD_ARIZONA_I2C is not set
+# CONFIG_MFD_ARIZONA_SPI is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM831X_SPI is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_MC13XXX_SPI is not set
+# CONFIG_MFD_MC13XXX_I2C is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_TPS65090 is not set
+# CONFIG_MFD_AAT2870_CORE is not set
+# CONFIG_MFD_RC5T583 is not set
+# CONFIG_MFD_SYSCON is not set
+# CONFIG_MFD_PALMAS is not set
+# CONFIG_MFD_VIPERBOARD is not set
+# CONFIG_MFD_RETU is not set
+# CONFIG_MFD_AS3711 is not set
+# CONFIG_MFD_RAA730300 is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_DRM is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+# CONFIG_FB_CFB_FILLRECT is not set
+# CONFIG_FB_CFB_COPYAREA is not set
+# CONFIG_FB_CFB_IMAGEBLIT is not set
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+CONFIG_FB_SYS_FILLRECT=y
+CONFIG_FB_SYS_COPYAREA=y
+CONFIG_FB_SYS_IMAGEBLIT=y
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+CONFIG_FB_SYS_FOPS=y
+# CONFIG_FB_WMT_GE_ROPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_SH_MOBILE_LCDC is not set
+# CONFIG_FB_SMSCUFX is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_FB_AUO_K190X is not set
+CONFIG_FB_VDC5=y
+# CONFIG_EXYNOS_VIDEO is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+CONFIG_LOGO=y
+CONFIG_LOGO_LINUX_MONO=y
+CONFIG_LOGO_LINUX_VGA16=y
+CONFIG_LOGO_LINUX_CLUT224=y
+# CONFIG_FB_SH_MOBILE_MERAM is not set
+# CONFIG_FB_SSD1307 is not set
+CONFIG_SOUND=y
+# CONFIG_SOUND_OSS_CORE is not set
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_COMPRESS_OFFLOAD=y
+CONFIG_SND_JACK=y
+# CONFIG_SND_SEQUENCER is not set
+# CONFIG_SND_MIXER_OSS is not set
+# CONFIG_SND_PCM_OSS is not set
+# CONFIG_SND_HRTIMER is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+CONFIG_SND_DRIVERS=y
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_ALOOP is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+CONFIG_SND_ARM=y
+CONFIG_SND_SPI=y
+CONFIG_SND_USB=y
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_UA101 is not set
+# CONFIG_SND_USB_CAIAQ is not set
+# CONFIG_SND_USB_6FIRE is not set
+CONFIG_SND_SOC=y
+# CONFIG_SND_DESIGNWARE_I2S is not set
+
+#
+# SoC Audio support for SuperH
+#
+# CONFIG_SND_SOC_SH4_FSI is not set
+CONFIG_SND_SOC_SCUX=y
+CONFIG_SND_SCUX_GENMAI=y
+CONFIG_SND_SCUX_WM8978=y
+CONFIG_SND_SOC_I2C_AND_SPI=y
+# CONFIG_SND_SOC_ALL_CODECS is not set
+CONFIG_SND_SOC_WM8978=y
+# CONFIG_SND_SIMPLE_CARD is not set
+# CONFIG_SOUND_PRIME is not set
+
+#
+# HID support
+#
+CONFIG_HID=y
+# CONFIG_HIDRAW is not set
+# CONFIG_UHID is not set
+CONFIG_HID_GENERIC=y
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_ACRUX is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_AUREAL is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_PRODIKEYS is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EMS_FF is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_HOLTEK is not set
+# CONFIG_HID_KEYTOUCH is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_UCLOGIC is not set
+# CONFIG_HID_WALTOP is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LCPOWER is not set
+# CONFIG_HID_LENOVO_TPKBD is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_PRIMAX is not set
+# CONFIG_HID_ROCCAT is not set
+# CONFIG_HID_SAITEK is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SONY is not set
+# CONFIG_HID_SPEEDLINK is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TIVO is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+# CONFIG_HID_SENSOR_HUB is not set
+
+#
+# USB HID support
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# I2C HID support
+#
+# CONFIG_I2C_HID is not set
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+# CONFIG_USB_ARCH_HAS_XHCI is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_COMMON=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_SUSPEND is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+CONFIG_USB_R8A66597_HCD=y
+# CONFIG_USB_CHIPIDEA is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_REALTEK is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_STORAGE_ENE_UB6250 is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+# CONFIG_USB_EZUSB_FX2 is not set
+
+#
+# USB Physical Layer drivers
+#
+# CONFIG_USB_ISP1301 is not set
+# CONFIG_USB_RCAR_PHY is not set
+# CONFIG_USB_GADGET is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_USB_ULPI is not set
+# CONFIG_NOP_USB_XCEIV is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+# CONFIG_MMC_CLKGATE is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_MINORS=8
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MMC_SDHCI_PXAV3 is not set
+# CONFIG_MMC_SDHCI_PXAV2 is not set
+CONFIG_MMC_TMIO_CORE=y
+CONFIG_MMC_SDHI=y
+CONFIG_MMC_GENMAI_SD_CARD_DETECT=y
+# CONFIG_MMC_DW is not set
+CONFIG_MMC_SH_MMCIF=y
+# CONFIG_MMC_VUB300 is not set
+# CONFIG_MMC_USHC is not set
+# CONFIG_MEMSTICK is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_LM3530 is not set
+# CONFIG_LEDS_LM3642 is not set
+# CONFIG_LEDS_PCA9532 is not set
+# CONFIG_LEDS_GPIO is not set
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_LP5521 is not set
+# CONFIG_LEDS_LP5523 is not set
+# CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_PCA9633 is not set
+# CONFIG_LEDS_DAC124S085 is not set
+# CONFIG_LEDS_BD2802 is not set
+# CONFIG_LEDS_LT3593 is not set
+# CONFIG_LEDS_RENESAS_TPU is not set
+# CONFIG_LEDS_TCA6507 is not set
+# CONFIG_LEDS_LM355x is not set
+# CONFIG_LEDS_OT200 is not set
+# CONFIG_LEDS_BLINKM is not set
+# CONFIG_LEDS_TRIGGERS is not set
+
+#
+# LED Triggers
+#
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_EDAC is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8523 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T93 is not set
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_DS3234 is not set
+# CONFIG_RTC_DRV_PCF2123 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+# CONFIG_RTC_DRV_DS2404 is not set
+
+#
+# on-CPU RTC drivers
+#
+CONFIG_RTC_DRV_SH=y
+# CONFIG_RTC_DRV_SNVS is not set
+CONFIG_DMADEVICES=y
+# CONFIG_DMADEVICES_DEBUG is not set
+
+#
+# DMA Devices
+#
+# CONFIG_DW_DMAC is not set
+CONFIG_SH_DMAE=y
+CONFIG_RZA1_DMAE=y
+# CONFIG_TIMB_DMA is not set
+CONFIG_DMA_ENGINE=y
+
+#
+# DMA Clients
+#
+# CONFIG_NET_DMA is not set
+# CONFIG_ASYNC_TX_DMA is not set
+# CONFIG_DMATEST is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+
+#
+# Virtio drivers
+#
+# CONFIG_VIRTIO_MMIO is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+CONFIG_STAGING=y
+# CONFIG_USBIP_CORE is not set
+# CONFIG_ECHO is not set
+# CONFIG_ASUS_OLED is not set
+# CONFIG_RTLLIB is not set
+# CONFIG_R8712U is not set
+# CONFIG_RTS5139 is not set
+# CONFIG_TRANZPORT is not set
+# CONFIG_LINE6_USB is not set
+# CONFIG_VT6656 is not set
+
+#
+# IIO staging drivers
+#
+# CONFIG_IIO_ST_HWMON is not set
+# CONFIG_IIO_SW_RING is not set
+
+#
+# Accelerometers
+#
+# CONFIG_ADIS16201 is not set
+# CONFIG_ADIS16203 is not set
+# CONFIG_ADIS16204 is not set
+# CONFIG_ADIS16209 is not set
+# CONFIG_ADIS16220 is not set
+# CONFIG_ADIS16240 is not set
+# CONFIG_KXSD9 is not set
+# CONFIG_LIS3L02DQ is not set
+# CONFIG_SCA3000 is not set
+
+#
+# Analog to digital converters
+#
+# CONFIG_AD7291 is not set
+# CONFIG_AD7606 is not set
+# CONFIG_AD799X is not set
+# CONFIG_AD7780 is not set
+# CONFIG_AD7816 is not set
+# CONFIG_AD7192 is not set
+# CONFIG_ADT7410 is not set
+# CONFIG_AD7280 is not set
+
+#
+# Analog digital bi-direction converters
+#
+# CONFIG_ADT7316 is not set
+
+#
+# Capacitance to digital converters
+#
+# CONFIG_AD7150 is not set
+# CONFIG_AD7152 is not set
+# CONFIG_AD7746 is not set
+
+#
+# Direct Digital Synthesis
+#
+# CONFIG_AD5930 is not set
+# CONFIG_AD9832 is not set
+# CONFIG_AD9834 is not set
+# CONFIG_AD9850 is not set
+# CONFIG_AD9852 is not set
+# CONFIG_AD9910 is not set
+# CONFIG_AD9951 is not set
+
+#
+# Digital gyroscope sensors
+#
+# CONFIG_ADIS16060 is not set
+# CONFIG_ADIS16080 is not set
+# CONFIG_ADIS16130 is not set
+# CONFIG_ADIS16260 is not set
+# CONFIG_ADXRS450 is not set
+
+#
+# Network Analyzer, Impedance Converters
+#
+# CONFIG_AD5933 is not set
+
+#
+# Inertial measurement units
+#
+# CONFIG_ADIS16400 is not set
+
+#
+# Light sensors
+#
+# CONFIG_SENSORS_ISL29018 is not set
+# CONFIG_SENSORS_ISL29028 is not set
+# CONFIG_SENSORS_TSL2563 is not set
+# CONFIG_TSL2583 is not set
+# CONFIG_TSL2x7x is not set
+
+#
+# Magnetometer sensors
+#
+# CONFIG_SENSORS_AK8975 is not set
+# CONFIG_SENSORS_HMC5843 is not set
+
+#
+# Active energy metering IC
+#
+# CONFIG_ADE7753 is not set
+# CONFIG_ADE7754 is not set
+# CONFIG_ADE7758 is not set
+# CONFIG_ADE7759 is not set
+# CONFIG_ADE7854 is not set
+
+#
+# Resolver to digital converters
+#
+# CONFIG_AD2S90 is not set
+# CONFIG_AD2S1200 is not set
+# CONFIG_AD2S1210 is not set
+
+#
+# Triggers - standalone
+#
+# CONFIG_IIO_PERIODIC_RTC_TRIGGER is not set
+# CONFIG_IIO_GPIO_TRIGGER is not set
+# CONFIG_IIO_SYSFS_TRIGGER is not set
+# CONFIG_IIO_SIMPLE_DUMMY is not set
+# CONFIG_ZSMALLOC is not set
+# CONFIG_USB_ENESTORAGE is not set
+# CONFIG_BCM_WIMAX is not set
+# CONFIG_FT1000 is not set
+
+#
+# Speakup console speech
+#
+# CONFIG_SPEAKUP is not set
+# CONFIG_TOUCHSCREEN_CLEARPAD_TM1217 is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI4 is not set
+# CONFIG_STAGING_MEDIA is not set
+
+#
+# Android
+#
+# CONFIG_ANDROID is not set
+# CONFIG_USB_WPAN_HCD is not set
+# CONFIG_WIMAX_GDM72XX is not set
+# CONFIG_CED1401 is not set
+# CONFIG_DGRP is not set
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_HAVE_MACH_CLKDEV=y
+
+#
+# Hardware Spinlock drivers
+#
+CONFIG_IOMMU_SUPPORT=y
+CONFIG_OF_IOMMU=y
+
+#
+# Remoteproc drivers (EXPERIMENTAL)
+#
+# CONFIG_STE_MODEM_RPROC is not set
+
+#
+# Rpmsg drivers (EXPERIMENTAL)
+#
+# CONFIG_VIRT_DRIVERS is not set
+# CONFIG_PM_DEVFREQ is not set
+# CONFIG_EXTCON is not set
+# CONFIG_MEMORY is not set
+CONFIG_IIO=y
+CONFIG_IIO_BUFFER=y
+CONFIG_IIO_BUFFER_CB=y
+CONFIG_IIO_KFIFO_BUF=y
+CONFIG_IIO_TRIGGERED_BUFFER=y
+CONFIG_IIO_TRIGGER=y
+CONFIG_IIO_CONSUMERS_PER_TRIGGER=2
+
+#
+# Accelerometers
+#
+
+#
+# Analog to digital converters
+#
+# CONFIG_AD7266 is not set
+# CONFIG_AD7298 is not set
+# CONFIG_AD7791 is not set
+# CONFIG_AD7793 is not set
+# CONFIG_AD7476 is not set
+# CONFIG_AD7887 is not set
+# CONFIG_MAX1363 is not set
+# CONFIG_TI_ADC081C is not set
+CONFIG_SH_ADC=y
+
+#
+# Amplifiers
+#
+# CONFIG_AD8366 is not set
+
+#
+# Hid Sensor IIO Common
+#
+
+#
+# Digital to analog converters
+#
+# CONFIG_AD5064 is not set
+# CONFIG_AD5360 is not set
+# CONFIG_AD5380 is not set
+# CONFIG_AD5421 is not set
+# CONFIG_AD5624R_SPI is not set
+# CONFIG_AD5446 is not set
+# CONFIG_AD5449 is not set
+# CONFIG_AD5504 is not set
+# CONFIG_AD5755 is not set
+# CONFIG_AD5764 is not set
+# CONFIG_AD5791 is not set
+# CONFIG_AD5686 is not set
+# CONFIG_MAX517 is not set
+# CONFIG_MCP4725 is not set
+
+#
+# Frequency Synthesizers DDS/PLL
+#
+
+#
+# Clock Generator/Distribution
+#
+# CONFIG_AD9523 is not set
+
+#
+# Phase-Locked Loop (PLL) frequency synthesizers
+#
+# CONFIG_ADF4350 is not set
+
+#
+# Digital gyroscope sensors
+#
+# CONFIG_ADIS16136 is not set
+
+#
+# Inertial measurement units
+#
+# CONFIG_ADIS16480 is not set
+
+#
+# Light sensors
+#
+# CONFIG_ADJD_S311 is not set
+# CONFIG_VCNL4000 is not set
+
+#
+# Magnetometer sensors
+#
+# CONFIG_PWM is not set
+# CONFIG_IPACK_BUS is not set
+
+#
+# File systems
+#
+CONFIG_DCACHE_WORD_ACCESS=y
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_DEFAULTS_TO_ORDERED=y
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+# CONFIG_EXT4_FS is not set
+CONFIG_JBD=y
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_FANOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTACTL is not set
+# CONFIG_AUTOFS4_FS is not set
+CONFIG_FUSE_FS=y
+# CONFIG_CUSE is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+# CONFIG_MSDOS_FS is not set
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_TMPFS_XATTR is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_ECRYPT_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+# CONFIG_LOGFS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX6FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_PSTORE is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_F2FS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V2=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+# CONFIG_NFS_SWAP is not set
+CONFIG_NFS_V4_1=y
+CONFIG_PNFS_FILE_LAYOUT=m
+CONFIG_NFS_V4_1_IMPLEMENTATION_ID_DOMAIN="kernel.org"
+CONFIG_ROOT_NFS=y
+# CONFIG_NFS_USE_LEGACY_DNS is not set
+CONFIG_NFS_USE_KERNEL_DNS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_ACL_SUPPORT=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+CONFIG_SUNRPC_BACKCHANNEL=y
+# CONFIG_SUNRPC_DEBUG is not set
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_MAC_ROMAN is not set
+# CONFIG_NLS_MAC_CELTIC is not set
+# CONFIG_NLS_MAC_CENTEURO is not set
+# CONFIG_NLS_MAC_CROATIAN is not set
+# CONFIG_NLS_MAC_CYRILLIC is not set
+# CONFIG_NLS_MAC_GAELIC is not set
+# CONFIG_NLS_MAC_GREEK is not set
+# CONFIG_NLS_MAC_ICELAND is not set
+# CONFIG_NLS_MAC_INUIT is not set
+# CONFIG_NLS_MAC_ROMANIAN is not set
+# CONFIG_NLS_MAC_TURKISH is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_READABLE_ASM is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_PANIC_ON_OOPS is not set
+CONFIG_PANIC_ON_OOPS_VALUE=0
+# CONFIG_DETECT_HUNG_TASK is not set
+CONFIG_SCHED_DEBUG=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+# CONFIG_DEBUG_KMEMLEAK is not set
+CONFIG_DEBUG_PREEMPT=y
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_PROVE_RCU_DELAY is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_HIGHMEM is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_TRACE is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_PREEMPT_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_ENABLE_DEFAULT_TRACERS is not set
+# CONFIG_FTRACE_SYSCALLS is not set
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_PROBE_EVENTS is not set
+# CONFIG_RBTREE_TEST is not set
+# CONFIG_INTERVAL_TREE_TEST is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_STRICT_DEVMEM is not set
+CONFIG_ARM_UNWIND=y
+# CONFIG_DEBUG_USER is not set
+# CONFIG_DEBUG_LL is not set
+CONFIG_DEBUG_LL_INCLUDE="mach/debug-macro.S"
+# CONFIG_PID_IN_CONTEXTIDR is not set
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+# CONFIG_ENCRYPTED_KEYS is not set
+# CONFIG_KEYS_DEBUG_PROC_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=m
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_USER is not set
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA1_ARM is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_AES_ARM is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+CONFIG_CRYPTO_ANSI_CPRNG=m
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_ASYMMETRIC_KEY_TYPE is not set
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_GENERIC_IO=y
+CONFIG_PERCPU_RWSEM=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+# CONFIG_CRC8 is not set
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+# CONFIG_XZ_DEC is not set
+# CONFIG_XZ_DEC_BCJ is not set
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_DMA=y
+CONFIG_DQL=y
+CONFIG_NLATTR=y
+CONFIG_ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE=y
+# CONFIG_AVERAGE is not set
+# CONFIG_CORDIC is not set
+# CONFIG_DDR is not set
diff --git a/arch/arm/mach-shmobile/Kconfig b/arch/arm/mach-shmobile/Kconfig
index 9255546..963792d 100644
--- a/arch/arm/mach-shmobile/Kconfig
+++ b/arch/arm/mach-shmobile/Kconfig
@@ -38,6 +38,15 @@ config ARCH_EMEV2
 	select ARM_GIC
 	select CPU_V7
 
+config ARCH_RZA1
+	bool "RZA1"
+	select ARCH_WANT_OPTIONAL_GPIOLIB
+	select ARM_GIC
+	select CPU_V7
+	select SH_CLK_CPG
+	select I2C
+	select SH_TIMER_MTU2
+
 comment "SH-Mobile Board Type"
 
 config MACH_AP4EVB
@@ -116,6 +125,13 @@ config MACH_KZM9G
 	select SND_SOC_AK4642 if SND_SIMPLE_CARD
 	select USE_OF
 
+config MACH_RSKRZA1
+	bool "RSKRZA1 board"
+	depends on ARCH_RZA1
+	select ARCH_REQUIRE_GPIOLIB
+	select REGULATOR_FIXED_VOLTAGE if REGULATOR
+	select USE_OF
+
 comment "SH-Mobile System Configuration"
 
 config CPU_HAS_INTEVT
@@ -182,6 +198,11 @@ config EM_TIMER_STI
 	help
 	  This enables build of the STI timer driver.
 
+config SH_TIMER_MTU2
+	bool "MTU2 timer driver"
+	help
+	  This enables build of the MTU2 timer driver.
+
 endmenu
 
 config SH_CLK_CPG
diff --git a/arch/arm/mach-shmobile/Makefile b/arch/arm/mach-shmobile/Makefile
index 0b71479..786fb7f 100644
--- a/arch/arm/mach-shmobile/Makefile
+++ b/arch/arm/mach-shmobile/Makefile
@@ -8,6 +8,7 @@ obj-y				:= timer.o console.o clock.o
 # CPU objects
 obj-$(CONFIG_ARCH_SH7372)	+= setup-sh7372.o clock-sh7372.o intc-sh7372.o
 obj-$(CONFIG_ARCH_SH73A0)	+= setup-sh73a0.o clock-sh73a0.o intc-sh73a0.o
+obj-$(CONFIG_ARCH_RZA1)		+= setup-rza1.o clock-rza1.o intc-rza1.o pfc-rza1.o
 obj-$(CONFIG_ARCH_R8A7740)	+= setup-r8a7740.o clock-r8a7740.o intc-r8a7740.o
 obj-$(CONFIG_ARCH_R8A7779)	+= setup-r8a7779.o clock-r8a7779.o intc-r8a7779.o
 obj-$(CONFIG_ARCH_EMEV2)	+= setup-emev2.o clock-emev2.o
@@ -48,6 +49,7 @@ obj-$(CONFIG_MACH_MARZEN)	+= board-marzen.o
 obj-$(CONFIG_MACH_ARMADILLO800EVA)	+= board-armadillo800eva.o
 obj-$(CONFIG_MACH_KZM9D)	+= board-kzm9d.o
 obj-$(CONFIG_MACH_KZM9G)	+= board-kzm9g.o
+obj-$(CONFIG_MACH_RSKRZA1)	+= board-rskrza1.o
 
 # Framework support
 obj-$(CONFIG_SMP)		+= $(smp-y)
diff --git a/arch/arm/mach-shmobile/board-rskrza1.c b/arch/arm/mach-shmobile/board-rskrza1.c
new file mode 100644
index 0000000..150d45f
--- /dev/null
+++ b/arch/arm/mach-shmobile/board-rskrza1.c
@@ -0,0 +1,400 @@
+/*
+ * rskrza1 board support
+ *
+ * Copyright (C) 2013  Renesas Solutions Corp.
+ * Copyright (C) 2010  Magnus Damm
+ * Copyright (C) 2008  Yoshihiro Shimoda
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include <asm/hardware/gic.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <linux/export.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/physmap.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/fixed.h>
+#include <linux/regulator/machine.h>
+#include <linux/spi/smanalog.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/sh_mmcif.h>
+#include <linux/mmc/sh_mobile_sdhi.h>
+#include <linux/mfd/tmio.h>
+#include <linux/platform_data/dma-rza1.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <mach/common.h>
+#include <mach/rza1.h>
+#include <linux/i2c.h>
+#include <linux/sh_intc.h>
+#include <../sound/soc/codecs/wm8978.h>
+#include <video/vdc5fb.h>
+
+/* MTD */
+static struct mtd_partition nor_flash_partitions[] = {
+	{
+		.name		= "loader",
+		.offset		= 0x00000000,
+		.size		= 256 * 1024 * 2,
+	},
+	{
+		.name		= "bootenv",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= 128 * 1024 * 2,
+		.mask_flags	= MTD_WRITEABLE,
+	},
+	{
+		.name		= "kernel",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= 4 * 1024 * 1024,
+	},
+	{
+		.name		= "data",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= MTDPART_SIZ_FULL,
+	},
+};
+
+static struct physmap_flash_data nor_flash_data = {
+	.width		= 2,
+	.parts		= nor_flash_partitions,
+	.nr_parts	= ARRAY_SIZE(nor_flash_partitions),
+};
+
+static struct resource nor_flash_resources[] = {
+	[0]	= {
+		.start	= 0x00000000,
+		.end	= 0x08000000 - 1,
+		.flags	= IORESOURCE_MEM,
+	}
+};
+
+static struct platform_device nor_flash_device = {
+	.name		= "physmap-flash",
+	.dev		= {
+		.platform_data	= &nor_flash_data,
+	},
+	.num_resources	= ARRAY_SIZE(nor_flash_resources),
+	.resource	= nor_flash_resources,
+};
+
+/* MMCIF */
+static struct resource sh_mmcif_resources[] = {
+	[0] = {
+		.name	= "MMCIF",
+		.start	= 0xe804c800,
+		.end	= 0xe804c8ff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= 300,
+		.flags	= IORESOURCE_IRQ,
+	},
+	[2] = {
+		.start	= 301,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct sh_mmcif_plat_data sh_mmcif_platdata = {
+	.ocr		= MMC_VDD_32_33,
+	.caps		= MMC_CAP_4_BIT_DATA |
+			  MMC_CAP_8_BIT_DATA |
+				MMC_CAP_NONREMOVABLE,
+	/*.slave_id_tx	= RZA1DMA_SLAVE_MMCIF_TX,*/
+	/*.slave_id_rx	= RZA1DMA_SLAVE_MMCIF_RX,*/
+};
+
+static struct platform_device mmc_device = {
+	.name		= "sh_mmcif",
+	.id		= -1,
+	.dev		= {
+		.dma_mask		= NULL,
+		.coherent_dma_mask	= 0xffffffff,
+		.platform_data		= &sh_mmcif_platdata,
+	},
+	.num_resources	= ARRAY_SIZE(sh_mmcif_resources),
+	.resource	= sh_mmcif_resources,
+};
+
+/* SDHI0 */
+static struct sh_mobile_sdhi_info sdhi0_info = {
+	.dma_slave_tx	= RZA1DMA_SLAVE_SDHI0_TX,
+	.dma_slave_rx	= RZA1DMA_SLAVE_SDHI0_RX,
+	.tmio_caps	= MMC_CAP_SD_HIGHSPEED | MMC_CAP_SDIO_IRQ,
+	.tmio_ocr_mask	= MMC_VDD_32_33,
+	.tmio_flags	= TMIO_MMC_HAS_IDLE_WAIT,
+};
+
+static struct resource sdhi0_resources[] = {
+	[0] = {
+		.name	= "SDHI0",
+		.start	= 0xe804e000,
+		.end	= 0xe804e0ff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.name   = SH_MOBILE_SDHI_IRQ_CARD_DETECT,
+		.start	= 302,
+		.flags	= IORESOURCE_IRQ,
+	},
+	[2] = {
+		.name   = SH_MOBILE_SDHI_IRQ_SDCARD,
+		.start	= 303,
+		.flags	= IORESOURCE_IRQ,
+	},
+	[3] = {
+		.name   = SH_MOBILE_SDHI_IRQ_SDIO,
+		.start	= 304,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device sdhi0_device = {
+	.name		= "sh_mobile_sdhi",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(sdhi0_resources),
+	.resource	= sdhi0_resources,
+	.dev	= {
+		.platform_data	= &sdhi0_info,
+	},
+};
+
+#include "rskrza1-vdc5fb.c"
+
+static struct platform_device *rskrza1_devices[] __initdata = {
+	&nor_flash_device,
+	&mmc_device,
+	&sdhi0_device,
+};
+
+static struct mtd_partition spibsc0_flash_partitions[] = {
+	{
+		.name		= "spibsc0_loader",
+		.offset		= 0x00000000,
+		.size		= 0x00080000,
+		/* .mask_flags	= MTD_WRITEABLE, */
+	},
+	{
+		.name		= "spibsc0_bootenv",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= 0x00040000,
+	},
+	{
+		.name		= "spibsc0_kernel",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= 0x00400000,
+	},
+	{
+		.name		= "spibsc0_rootfs",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= MTDPART_SIZ_FULL,
+	},
+};
+
+
+
+static struct flash_platform_data spi_flash_data0 = {
+	.name	= "m25p80",
+	.parts	= spibsc0_flash_partitions,
+	.nr_parts = ARRAY_SIZE(spibsc0_flash_partitions),
+	.type = "s25fl512s",
+};
+
+
+static struct spi_board_info rskrza1_spi_devices[] __initdata = {
+#if (defined(CONFIG_SPI_MASTER) && defined(CONFIG_MACH_RSKRZA1))
+	{
+		.modalias = "wm8978",
+		.max_speed_hz = 3125000,
+				/* max spi clock (SCK) speed in HZ */
+		.bus_num = 4,
+		.chip_select = 0,
+		.mode = SPI_MODE_3,
+	},
+#endif
+	{
+		/* spidev */
+		.modalias		= "spidev",
+		.chip_select		= 0,
+		.max_speed_hz		= 5000000,
+		.bus_num		= 1,
+		.mode			= SPI_MODE_3,
+		.clk_delay		= 2,
+		.cs_negate_delay	= 2,
+		.next_access_delay	= 2,
+	},
+	{
+		/* SPI Flash */
+		.modalias = "m25p80",
+		/* .max_speed_hz = 25000000, */
+		.bus_num = 5,
+		.chip_select = 0,
+		.platform_data = &spi_flash_data0,
+	},
+};
+
+static void __init rskrza1_init_spi(void)
+{
+	/* register SPI device information */
+	spi_register_board_info(rskrza1_spi_devices,
+		ARRAY_SIZE(rskrza1_spi_devices));
+}
+
+void __init rskrza1_init(void)
+{
+	if (disable_sdhi)
+		sdhi0_device.name = "mobile_sdhi(hidden)";
+
+	platform_add_devices(rskrza1_devices, ARRAY_SIZE(rskrza1_devices));
+
+	rza1_pinmux_setup();
+
+	rza1_devices_setup();
+
+	/* GPIO settings. */
+#if defined(CONFIG_SND_SCUX_GENMAI)
+	/* Audio Codec(WM8978) is use SSIF0(P4_4-P4_7) */
+	rza1_pfc_pin_bidirection(P4_4, true);      /* SSISCK0 */
+	rza1_pfc_pin_assign(P4_4, ALT5, DIR_PIPC); /* SSISCK0 */
+	rza1_pfc_pin_bidirection(P4_5, true);      /* SSIWS0 */
+	rza1_pfc_pin_assign(P4_5, ALT5, DIR_PIPC); /* SSIWS0 */
+	rza1_pfc_pin_bidirection(P4_6, true);      /* SSIRxD0 */
+	rza1_pfc_pin_assign(P4_6, ALT5, DIR_PIPC); /* SSIRxD0 */
+	rza1_pfc_pin_bidirection(P4_7, true);      /* SSITxD0 */
+	rza1_pfc_pin_assign(P4_7, ALT5, DIR_PIPC); /* SSITxD0 */
+#else
+	rza1_pfc_pin_bidirection(P4_4, true);      /* SPI RSPCK1 */
+	rza1_pfc_pin_assign(P4_4, ALT2, DIR_PIPC); /* SPI RSPCK1 */
+	rza1_pfc_pin_bidirection(P4_5, true);      /* SPI SSL10 */
+	rza1_pfc_pin_assign(P4_5, ALT2, DIR_PIPC); /* SPI SSL10 */
+	rza1_pfc_pin_bidirection(P4_6, true);      /* SPI MOSI1 */
+	rza1_pfc_pin_assign(P4_6, ALT2, DIR_PIPC); /* SPI MOSI1 */
+	rza1_pfc_pin_bidirection(P4_7, true);      /* SPI MISO1 */
+	rza1_pfc_pin_assign(P4_7, ALT2, DIR_PIPC); /* SPI MISO1 */
+#endif
+
+	/* ADC */
+	rza1_pfc_pin_assign(P1_8, ALT1, DIR_PIPC);	/* AN0 */
+	rza1_pfc_pin_assign(P1_9, ALT1, DIR_PIPC);	/* AN1 */
+	rza1_pfc_pin_assign(P1_10, ALT1, DIR_PIPC);	/* AN2 */
+	rza1_pfc_pin_assign(P1_11, ALT1, DIR_PIPC);	/* AN3 */
+
+	/* input GPIO */
+/*	rza1_pfc_pin_assign(P0_0, PMODE, DIR_IN);	*/
+/*	rza1_pfc_pin_assign(P0_1, PMODE, DIR_IN);	*/
+/*	rza1_pfc_pin_assign(P7_0, PMODE, DIR_IN);	*/
+
+#if defined(CONFIG_SND_SCUX_GENMAI)
+	/* Audio Codec(WM8978) is use RSPCK4 */
+	rza1_pfc_pin_assign(P4_0, ALT7, DIR_PIPC);	/* RSPCK4*/
+	rza1_pfc_pin_assign(P4_1, ALT7, DIR_PIPC);	/* SSL40 */
+	rza1_pfc_pin_assign(P4_2, ALT7, DIR_PIPC);	/* MOSI4 */
+#else
+	/* set MMCIF pfc configuration */
+	rza1_pfc_pin_assign(P3_8, ALT8, DIR_PIPC);	/* MMC_CD */
+	rza1_pfc_pin_assign(P3_10, ALT8, DIR_PIPC);	/* MMC_D1 */
+	rza1_pfc_pin_assign(P3_11, ALT8, DIR_PIPC);	/* MMC_D0 */
+	rza1_pfc_pin_assign(P3_12, ALT8, DIR_PIPC);	/* MMC_CLK */
+	rza1_pfc_pin_assign(P3_13, ALT8, DIR_PIPC);	/* MMC_CMD */
+	rza1_pfc_pin_assign(P3_14, ALT8, DIR_PIPC);	/* MMC_D3 */
+	rza1_pfc_pin_assign(P3_15, ALT8, DIR_PIPC);	/* MMC_D2 */
+	rza1_pfc_pin_assign(P4_0, ALT8, DIR_PIPC);	/* MMC_D4 */
+	rza1_pfc_pin_assign(P4_1, ALT8, DIR_PIPC);	/* MMC_D5 */
+	rza1_pfc_pin_assign(P4_2, ALT8, DIR_PIPC);	/* MMC_D6 */
+	rza1_pfc_pin_assign(P4_3, ALT8, DIR_PIPC);	/* MMC_D7 */
+#endif
+
+#if defined(CONFIG_MMC)
+	/* set SDHI0 pfc configuration */
+	rza1_pfc_pin_assign(P4_8, ALT3, DIR_PIPC);	/* SD_CD_0 */
+	rza1_pfc_pin_assign(P4_9, ALT3, DIR_PIPC);	/* SD_WP_0 */
+	rza1_pfc_pin_bidirection(P4_10, true);		/* SD_D1_0 */
+	rza1_pfc_pin_assign(P4_10, ALT3, DIR_PIPC);	/* SD_D1_0 */
+	rza1_pfc_pin_bidirection(P4_11, true);		/* SD_D0_0 */
+	rza1_pfc_pin_assign(P4_11, ALT3, DIR_PIPC);	/* SD_D0_0 */
+	rza1_pfc_pin_assign(P4_12, ALT3, DIR_PIPC);	/* SD_CLK_0 */
+	rza1_pfc_pin_bidirection(P4_13, true);		/* SD_CMD_0 */
+	rza1_pfc_pin_assign(P4_13, ALT3, DIR_PIPC);	/* SD_CMD_0 */
+	rza1_pfc_pin_bidirection(P4_14, true);		/* SD_D3_0 */
+	rza1_pfc_pin_assign(P4_14, ALT3, DIR_PIPC);	/* SD_D3_0 */
+	rza1_pfc_pin_bidirection(P4_15, true);		/* SD_D2_0 */
+	rza1_pfc_pin_assign(P4_15, ALT3, DIR_PIPC);	/* SD_D2_0 */
+#else
+	/* GPIO */
+	rza1_pfc_pin_assign(P4_10, PMODE, DIR_OUT);	/* LED1 */
+	rza1_pfc_pin_assign(P4_11, PMODE, DIR_OUT);	/* LED2 */
+#endif
+
+#if defined(CONFIG_SPI_MASTER)
+	rskrza1_init_spi();
+#endif
+
+#if defined(CONFIG_FB_VDC5)
+	vdc5fb_setup();
+#endif
+}
+
+int rskrza1_board_i2c_pfc_assign(int id)
+{
+	/* set I2C pfc configuration */
+	switch (id) {
+	case 0:
+		rza1_pfc_pin_bidirection(P1_0, true);		/* I2C SCL0 */
+		rza1_pfc_pin_assign(P1_0, ALT1, DIR_PIPC);	/* I2C SCL0 */
+		rza1_pfc_pin_bidirection(P1_1, true);		/* I2C SDA0 */
+		rza1_pfc_pin_assign(P1_1, ALT1, DIR_PIPC);	/* I2C SDA0 */
+		break;
+	case 1:
+		rza1_pfc_pin_bidirection(P1_2, true);		/* I2C SCL1 */
+		rza1_pfc_pin_assign(P1_2, ALT1, DIR_PIPC);	/* I2C SCL1 */
+		rza1_pfc_pin_bidirection(P1_3, true);		/* I2C SDA1 */
+		rza1_pfc_pin_assign(P1_3, ALT1, DIR_PIPC);	/* I2C SDA1 */
+		break;
+	case 2:
+		rza1_pfc_pin_bidirection(P1_4, true);		/* I2C SCL2 */
+		rza1_pfc_pin_assign(P1_4, ALT1, DIR_PIPC);	/* I2C SCL2 */
+		rza1_pfc_pin_bidirection(P1_5, true);		/* I2C SDA2 */
+		rza1_pfc_pin_assign(P1_5, ALT1, DIR_PIPC);	/* I2C SDA2 */
+		break;
+	case 3:
+		rza1_pfc_pin_bidirection(P1_6, true);		/* I2C SCL3 */
+		rza1_pfc_pin_assign(P1_6, ALT1, DIR_PIPC);	/* I2C SCL3 */
+		rza1_pfc_pin_bidirection(P1_7, true);		/* I2C SDA3 */
+		rza1_pfc_pin_assign(P1_7, ALT1, DIR_PIPC);	/* I2C SDA3 */
+		break;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(rskrza1_board_i2c_pfc_assign);
+
+static const char *rskrza1_boards_compat_dt[] __initdata = {
+	"renesas,rskrza1",
+	NULL,
+};
+
+DT_MACHINE_START(RSKRZA1_DT, "rskrza1")
+	.nr_irqs	= NR_IRQS_LEGACY,
+	.map_io		= rza1_map_io,
+	.init_early	= rza1_add_early_devices,
+	.init_irq	= rza1_init_irq,
+	.handle_irq	= gic_handle_irq,
+	.init_machine	= rskrza1_init,
+	.init_late	= shmobile_init_late,
+	.timer		= &shmobile_timer,
+	.dt_compat	= rskrza1_boards_compat_dt,
+MACHINE_END
diff --git a/arch/arm/mach-shmobile/clock-rza1.c b/arch/arm/mach-shmobile/clock-rza1.c
new file mode 100644
index 0000000..39508f1
--- /dev/null
+++ b/arch/arm/mach-shmobile/clock-rza1.c
@@ -0,0 +1,275 @@
+/*
+ * RZA1 clock framework support
+ *
+ * Copyright (C) 2013  Renesas Solutions Corp.
+ * Copyright (C) 2012  Phil Edworthy
+ * Copyright (C) 2011  Magnus Damm
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/io.h>
+#include <linux/sh_clk.h>
+#include <linux/clkdev.h>
+#include <mach/common.h>
+
+/* registers */
+#define FRQCR		0xfcfe0010
+#define FRQCR2		0xfcfe0014
+#define STBCR3		0xfcfe0420
+#define STBCR4		0xfcfe0424
+#define STBCR5		0xfcfe0428
+#define STBCR6		0xfcfe042c
+#define STBCR7		0xfcfe0430
+#define STBCR8		0xfcfe0434
+#define STBCR9		0xfcfe0438
+#define STBCR10		0xfcfe043c
+#define STBCR11		0xfcfe0440
+#define STBCR12		0xfcfe0444
+
+#define PLL_RATE 30
+
+/* Fixed 32 KHz root clock for RTC */
+static struct clk r_clk = {
+	.rate		= 32768,
+};
+
+/*
+ * Default rate for the root input clock, reset this with clk_set_rate()
+ * from the platform code.
+ */
+static struct clk extal_clk = {
+	.rate		= 13330000,
+};
+
+static unsigned long pll_recalc(struct clk *clk)
+{
+	return clk->parent->rate * PLL_RATE;
+}
+
+static struct sh_clk_ops pll_clk_ops = {
+	.recalc		= pll_recalc,
+};
+
+static struct clk pll_clk = {
+	.ops		= &pll_clk_ops,
+	.parent		= &extal_clk,
+	.flags		= CLK_ENABLE_ON_INIT,
+};
+
+static unsigned long bus_recalc(struct clk *clk)
+{
+	return clk->parent->rate * 2 / 3;
+}
+
+static struct sh_clk_ops bus_clk_ops = {
+	.recalc		= bus_recalc,
+};
+
+static struct clk bus_clk = {
+	.ops		= &bus_clk_ops,
+	.parent		= &pll_clk,
+	.flags		= CLK_ENABLE_ON_INIT,
+};
+
+static unsigned long peripheral0_recalc(struct clk *clk)
+{
+	return clk->parent->rate / 12;
+}
+
+static struct sh_clk_ops peripheral0_clk_ops = {
+	.recalc		= peripheral0_recalc,
+};
+
+static struct clk peripheral0_clk = {
+	.ops		= &peripheral0_clk_ops,
+	.parent		= &pll_clk,
+	.flags		= CLK_ENABLE_ON_INIT,
+};
+
+static unsigned long peripheral1_recalc(struct clk *clk)
+{
+	return clk->parent->rate / 6;
+}
+
+static struct sh_clk_ops peripheral1_clk_ops = {
+	.recalc		= peripheral1_recalc,
+};
+
+static struct clk peripheral1_clk = {
+	.ops		= &peripheral1_clk_ops,
+	.parent		= &pll_clk,
+	.flags		= CLK_ENABLE_ON_INIT,
+};
+
+struct clk *main_clks[] = {
+	&r_clk,
+	&extal_clk,
+	&pll_clk,
+	&bus_clk,
+	&peripheral0_clk,
+	&peripheral1_clk,
+};
+
+static int div2[] = { 1, 3, 0, 3 }; /* 1, 2/3, reserve, 1/3 */
+static int multipliers[] = { 1, 2, 1, 1 };
+
+static struct clk_div_mult_table div4_div_mult_table = {
+	.divisors = div2,
+	.nr_divisors = ARRAY_SIZE(div2),
+	.multipliers = multipliers,
+	.nr_multipliers = ARRAY_SIZE(multipliers),
+};
+
+static struct clk_div4_table div4_table = {
+	.div_mult_table = &div4_div_mult_table,
+};
+
+enum { DIV4_I,
+	DIV4_NR };
+
+#define DIV4(_reg, _bit, _mask, _flags) \
+	SH_CLK_DIV4(&pll_clk, _reg, _bit, _mask, _flags)
+
+/* The mask field specifies the div2 entries that are valid */
+struct clk div4_clks[DIV4_NR] = {
+	[DIV4_I]  = DIV4(FRQCR, 8, 0xB, CLK_ENABLE_REG_16BIT
+					| CLK_ENABLE_ON_INIT),
+};
+
+enum { MSTP51, MSTP50,
+	MSTP71, MSTP70,
+	MSTP47, MSTP46, MSTP45, MSTP44, MSTP43, MSTP42, MSTP41, MSTP40,
+	MSTP33, MSTP67, MSTP60,
+	MSTP84,
+	MSTP92, MSTP93,
+#if defined(CONFIG_FB_VDC5)
+	MSTP90, MSTP91,
+#endif
+	MSTP94, MSTP95, MSTP96, MSTP97,
+	MSTP107, MSTP106, MSTP105, MSTP104, MSTP103,
+	MSTP123, MSTP122, MSTP121, MSTP120,
+	MSTP81,		/* SCUX */
+	MSTP115,	/* SSIF0 */
+	MSTP_NR };
+
+static struct clk mstp_clks[MSTP_NR] = {
+	[MSTP107] = SH_CLK_MSTP8(&peripheral1_clk, STBCR10, 7, 0), /* RSPI0 */
+	[MSTP106] = SH_CLK_MSTP8(&peripheral1_clk, STBCR10, 6, 0), /* RSPI1 */
+	[MSTP105] = SH_CLK_MSTP8(&peripheral1_clk, STBCR10, 5, 0), /* RSPI2 */
+	[MSTP104] = SH_CLK_MSTP8(&peripheral1_clk, STBCR10, 4, 0), /* RSPI3 */
+	[MSTP103] = SH_CLK_MSTP8(&peripheral1_clk, STBCR10, 3, 0), /* RSPI4 */
+	[MSTP51] = SH_CLK_MSTP8(&peripheral0_clk, STBCR5, 0, 0),   /* OST0 */
+	[MSTP50] = SH_CLK_MSTP8(&peripheral0_clk, STBCR5, 1, 0),   /* OST1 */
+	[MSTP71] = SH_CLK_MSTP8(&peripheral1_clk, STBCR7, 1, 0),   /* USB0 */
+	[MSTP70] = SH_CLK_MSTP8(&peripheral1_clk, STBCR7, 0, 0),   /* USB1 */
+	[MSTP47] = SH_CLK_MSTP8(&peripheral1_clk, STBCR4, 7, 0),   /* SCIF0 */
+	[MSTP46] = SH_CLK_MSTP8(&peripheral1_clk, STBCR4, 6, 0),   /* SCIF1 */
+	[MSTP45] = SH_CLK_MSTP8(&peripheral1_clk, STBCR4, 5, 0),   /* SCIF2 */
+	[MSTP44] = SH_CLK_MSTP8(&peripheral1_clk, STBCR4, 4, 0),   /* SCIF3 */
+	[MSTP43] = SH_CLK_MSTP8(&peripheral1_clk, STBCR4, 3, 0),   /* SCIF4 */
+	[MSTP42] = SH_CLK_MSTP8(&peripheral1_clk, STBCR4, 2, 0),   /* SCIF5 */
+	[MSTP41] = SH_CLK_MSTP8(&peripheral1_clk, STBCR4, 1, 0),   /* SCIF6 */
+	[MSTP40] = SH_CLK_MSTP8(&peripheral1_clk, STBCR4, 0, 0),   /* SCIF7 */
+	[MSTP33] = SH_CLK_MSTP8(&peripheral0_clk, STBCR3, 3, 0),   /* MTU2 */
+	[MSTP67] = SH_CLK_MSTP8(&peripheral1_clk, STBCR6, 7, 0),   /* ADC */
+	[MSTP60] = SH_CLK_MSTP8(&r_clk, STBCR6, 0, 0),		   /* RTC */
+	[MSTP123] = SH_CLK_MSTP8(&peripheral1_clk, STBCR12, 3, 0), /* SDHI00 */
+	[MSTP122] = SH_CLK_MSTP8(&peripheral1_clk, STBCR12, 2,
+			CLK_ENABLE_ON_INIT),			   /* SDHI01 */
+	[MSTP121] = SH_CLK_MSTP8(&peripheral1_clk, STBCR12, 1, 0), /* SDHI10 */
+	[MSTP120] = SH_CLK_MSTP8(&peripheral1_clk, STBCR12, 0,
+			CLK_ENABLE_ON_INIT),			   /* SDHI11 */
+	[MSTP84] = SH_CLK_MSTP8(&peripheral1_clk, STBCR8, 4, 0),   /* MMC */
+#if defined(CONFIG_FB_VDC5)
+	[MSTP90] = SH_CLK_MSTP8(&peripheral1_clk, STBCR9, 0, 0),   /* SPIBSC1 */
+	[MSTP91] = SH_CLK_MSTP8(&peripheral1_clk, STBCR9, 1, 0),   /* SPIBSC1 */
+#endif
+	[MSTP92] = SH_CLK_MSTP8(&bus_clk, STBCR9, 2, 0),	   /* SPIBSC1 */
+	[MSTP93] = SH_CLK_MSTP8(&bus_clk, STBCR9, 3, 0),	   /* SPIBSC0 */
+	[MSTP94] = SH_CLK_MSTP8(&peripheral0_clk, STBCR9, 4, 0),   /* RIIC3 */
+	[MSTP95] = SH_CLK_MSTP8(&peripheral0_clk, STBCR9, 5, 0),   /* RIIC2 */
+	[MSTP96] = SH_CLK_MSTP8(&peripheral0_clk, STBCR9, 6, 0),   /* RIIC1 */
+	[MSTP97] = SH_CLK_MSTP8(&peripheral0_clk, STBCR9, 7, 0),   /* RIIC0 */
+	[MSTP81] = SH_CLK_MSTP8(&peripheral0_clk, STBCR8, 1,
+			CLK_ENABLE_ON_INIT),			   /* SCUX */
+	[MSTP115] = SH_CLK_MSTP8(&peripheral0_clk, STBCR11, 5,
+			CLK_ENABLE_ON_INIT),			   /* SSIF0 */
+};
+
+static struct clk_lookup lookups[] = {
+	/* main clocks */
+	CLKDEV_CON_ID("rclk", &r_clk),
+	CLKDEV_CON_ID("extal", &extal_clk),
+	CLKDEV_CON_ID("pll_clk", &pll_clk),
+	CLKDEV_CON_ID("peripheral_clk", &peripheral1_clk),
+
+	/* DIV4 clocks */
+	CLKDEV_CON_ID("cpu_clk", &div4_clks[DIV4_I]),
+
+	/* MSTP clocks */
+	CLKDEV_ICK_ID("sci_fck", "sh-sci.0", &mstp_clks[MSTP47]),
+	CLKDEV_ICK_ID("sci_fck", "sh-sci.1", &mstp_clks[MSTP46]),
+	CLKDEV_ICK_ID("sci_fck", "sh-sci.2", &mstp_clks[MSTP45]),
+	CLKDEV_ICK_ID("sci_fck", "sh-sci.3", &mstp_clks[MSTP44]),
+	CLKDEV_ICK_ID("sci_fck", "sh-sci.4", &mstp_clks[MSTP43]),
+	CLKDEV_ICK_ID("sci_fck", "sh-sci.5", &mstp_clks[MSTP42]),
+	CLKDEV_ICK_ID("sci_fck", "sh-sci.6", &mstp_clks[MSTP41]),
+	CLKDEV_ICK_ID("sci_fck", "sh-sci.7", &mstp_clks[MSTP40]),
+	CLKDEV_CON_ID("usb0", &mstp_clks[MSTP71]),
+	CLKDEV_CON_ID("usb1", &mstp_clks[MSTP70]),
+	CLKDEV_CON_ID("mtu2_fck", &mstp_clks[MSTP33]),
+	CLKDEV_CON_ID("adc0", &mstp_clks[MSTP67]),
+	CLKDEV_CON_ID("rtc0", &mstp_clks[MSTP60]),
+	CLKDEV_DEV_ID("sh_mmcif", &mstp_clks[MSTP84]),
+	CLKDEV_DEV_ID("sh_mobile_sdhi.0", &mstp_clks[MSTP123]),
+	CLKDEV_DEV_ID("sh_mobile_sdhi.1", &mstp_clks[MSTP121]),
+	CLKDEV_CON_ID("riic0", &mstp_clks[MSTP97]),
+	CLKDEV_CON_ID("riic1", &mstp_clks[MSTP96]),
+	CLKDEV_CON_ID("riic2", &mstp_clks[MSTP95]),
+	CLKDEV_CON_ID("riic3", &mstp_clks[MSTP94]),
+	CLKDEV_CON_ID("spibsc0", &mstp_clks[MSTP93]),
+	CLKDEV_CON_ID("spibsc1", &mstp_clks[MSTP92]),
+	CLKDEV_CON_ID("rspi0", &mstp_clks[MSTP107]),
+	CLKDEV_CON_ID("rspi1", &mstp_clks[MSTP106]),
+	CLKDEV_CON_ID("rspi2", &mstp_clks[MSTP105]),
+	CLKDEV_CON_ID("rspi3", &mstp_clks[MSTP104]),
+	CLKDEV_CON_ID("rspi4", &mstp_clks[MSTP103]),
+	CLKDEV_CON_ID("scux", &mstp_clks[MSTP81]),	/* SCUX */
+	CLKDEV_CON_ID("ssif0", &mstp_clks[MSTP115]),	/* SSIF0 */
+#if defined(CONFIG_FB_VDC5)
+	CLKDEV_CON_ID("lvds", &mstp_clks[MSTP91]),
+	CLKDEV_CON_ID("vdc5fb.0", &mstp_clks[MSTP91]),
+	CLKDEV_CON_ID("vdc5fb.1", &mstp_clks[MSTP90]),
+#endif
+};
+
+int __init rza1_clock_init(void)
+{
+	int k, ret = 0;
+
+	for (k = 0; !ret && (k < ARRAY_SIZE(main_clks)); k++)
+		ret = clk_register(main_clks[k]);
+
+	clkdev_add_table(lookups, ARRAY_SIZE(lookups));
+
+	if (!ret)
+		ret = sh_clk_div4_register(div4_clks, DIV4_NR, &div4_table);
+
+	if (!ret)
+		ret = sh_clk_mstp_register(mstp_clks, MSTP_NR);
+
+	if (!ret)
+		shmobile_clk_init();
+	else
+		panic("failed to setup rza1 clocks\n");
+	return ret;
+}
diff --git a/arch/arm/mach-shmobile/include/mach/rtc.h b/arch/arm/mach-shmobile/include/mach/rtc.h
new file mode 100644
index 0000000..2e1664c
--- /dev/null
+++ b/arch/arm/mach-shmobile/include/mach/rtc.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2013 Renesas Solutions Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef _ASM_RTC_H
+#define _ASM_RTC_H
+
+void time_init(void);
+extern void (*board_time_init)(void);
+extern void (*rtc_sh_get_time)(struct timespec *);
+extern int (*rtc_sh_set_time)(const time_t);
+
+/* some dummy definitions */
+#define RTC_BATT_BAD 0x100	/* battery bad */
+#define RTC_SQWE 0x08		/* enable square-wave output */
+#define RTC_DM_BINARY 0x04	/* all time/date values are BCD if clear */
+#define RTC_24H 0x02		/* 24 hour mode - else hours bit 7 means pm */
+#define RTC_DST_EN 0x01	        /* auto switch DST - works f. USA only */
+
+struct rtc_time;
+unsigned int get_rtc_time(struct rtc_time *);
+int set_rtc_time(struct rtc_time *);
+
+#define RTC_CAP_4_DIGIT_YEAR	(1 << 0)
+
+struct sh_rtc_platform_info {
+	unsigned long capabilities;
+};
+
+#define rtc_reg_size            sizeof(u16)
+
+#define RTC_BIT_INVERTED        0x40    /* bug on SH7750, SH7750S */
+#define RTC_DEF_CAPABILITIES    RTC_CAP_4_DIGIT_YEAR
+
+#endif /* _ASM_RTC_H */
diff --git a/arch/arm/mach-shmobile/include/mach/rza1.h b/arch/arm/mach-shmobile/include/mach/rza1.h
new file mode 100644
index 0000000..4887ddf
--- /dev/null
+++ b/arch/arm/mach-shmobile/include/mach/rza1.h
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2013 Renesas Solutions Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef __ASM_RZA1_H__
+#define __ASM_RZA1_H__
+
+enum pfc_pin_number {
+	P0_0, P0_1, P0_2, P0_3, P0_4, P0_5,
+	P1_0, P1_1, P1_2, P1_3, P1_4, P1_5, P1_6, P1_7, P1_8,
+	P1_9, P1_10, P1_11, P1_12, P1_13, P1_14, P1_15,
+	P2_0, P2_1, P2_2, P2_3, P2_4, P2_5, P2_6, P2_7, P2_8,
+	P2_9, P2_10, P2_11, P2_12, P2_13, P2_14, P2_15,
+	P3_0, P3_1, P3_2, P3_3, P3_4, P3_5, P3_6, P3_7, P3_8,
+	P3_9, P3_10, P3_11, P3_12, P3_13, P3_14, P3_15,
+	P4_0, P4_1, P4_2, P4_3, P4_4, P4_5, P4_6, P4_7, P4_8,
+	P4_9, P4_10, P4_11, P4_12, P4_13, P4_14, P4_15,
+	P5_0, P5_1, P5_2, P5_3, P5_4, P5_5, P5_6, P5_7, P5_8,
+	P5_9, P5_10,
+	P6_0, P6_1, P6_2, P6_3, P6_4, P6_5, P6_6, P6_7, P6_8,
+	P6_9, P6_10, P6_11, P6_12, P6_13, P6_14, P6_15,
+	P7_0, P7_1, P7_2, P7_3, P7_4, P7_5, P7_6, P7_7, P7_8,
+	P7_9, P7_10, P7_11, P7_12, P7_13, P7_14, P7_15,
+	P8_0, P8_1, P8_2, P8_3, P8_4, P8_5, P8_6, P8_7, P8_8,
+	P8_9, P8_10, P8_11, P8_12, P8_13, P8_14, P8_15,
+	P9_0, P9_1, P9_2, P9_3, P9_4, P9_5, P9_6, P9_7,
+	P10_0, P10_1, P10_2, P10_3, P10_4, P10_5, P10_6, P10_7, P10_8,
+	P10_9, P10_10, P10_11, P10_12, P10_13, P10_14, P10_15,
+	P11_0, P11_1, P11_2, P11_3, P11_4, P11_5, P11_6, P11_7, P11_8,
+	P11_9, P11_10, P11_11, P11_12, P11_13, P11_14, P11_15,
+	GPIO_NR,
+};
+
+enum pfc_mode {
+	PMODE = 0,
+	ALT1, ALT2, ALT3, ALT4, ALT5, ALT6, ALT7, ALT8,
+	PINMUX_STATE_NUM,
+};
+
+
+enum pfc_direction {
+	DIR_OUT = 0,
+	DIR_IN,
+	DIR_PIPC,
+};
+
+extern int disable_ether;
+
+extern void rza1_add_early_devices(void);
+extern void rza1_clock_init(void);
+extern void rza1_devices_setup(void);
+extern void rza1_init_irq(void);
+extern void rza1_map_io(void);
+extern int rza1_pinmux_setup(void);
+extern int rza1_pfc_pin_assign(enum pfc_pin_number pinnum, enum pfc_mode mode,
+			       enum pfc_direction dir);
+extern int rza1_pfc_pin_bidirection(enum pfc_pin_number pinnum, bool bidirection);
+int rskrza1_board_i2c_pfc_assign(int id);
+
+#endif /* __ASM_RZA1_H__ */
diff --git a/arch/arm/mach-shmobile/intc-rza1.c b/arch/arm/mach-shmobile/intc-rza1.c
new file mode 100644
index 0000000..64375a0
--- /dev/null
+++ b/arch/arm/mach-shmobile/intc-rza1.c
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2011-2013 Renesas Solutions Corp.
+ * Copyright (C) 2011  Magnus Damm
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <asm/hardware/gic.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <mach/intc.h>
+#include <mach/irqs.h>
+#include <mach/rza1.h>
+
+static int rza1_set_wake(struct irq_data *data, unsigned int on)
+{
+	return 0; /* always allow wakeup */
+}
+
+void __init rza1_init_irq(void)
+{
+	void __iomem *gic_dist_base = IOMEM(0xe8201000);
+	void __iomem *gic_cpu_base = IOMEM(0xe8202000);
+
+	/* Initialize GIC. */
+	gic_init(0, 29, gic_dist_base, gic_cpu_base);
+	gic_arch_extn.irq_set_wake = rza1_set_wake;
+
+}
diff --git a/arch/arm/mach-shmobile/pfc-rza1.c b/arch/arm/mach-shmobile/pfc-rza1.c
new file mode 100644
index 0000000..d5c5495
--- /dev/null
+++ b/arch/arm/mach-shmobile/pfc-rza1.c
@@ -0,0 +1,300 @@
+/*
+ * Copyright (C) 2013  Renesas Solutions Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include <asm/io.h>
+#include <linux/export.h>
+#include <linux/gpio.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/mutex.h>
+#include <mach/rza1.h>
+
+#define GPIO_CHIP_NAME "RZA1_INTERNAL_PFC"
+
+#define RZA1_BASE	IOMEM(0xfcfe3000)
+#define RZA1_BASE_P0	IOMEM(0xfcfe7b00)
+#define PORT_OFFSET	0x4
+#define PORT(p)		(0x0000 + (p) * PORT_OFFSET)
+#define PPR(p)		(0x0200 + (p) * PORT_OFFSET)
+#define PM(p)		(0x0300 + (p) * PORT_OFFSET)
+#define PMC(p)		(0x0400 + (p) * PORT_OFFSET)
+#define PFC(p)		(0x0500 + (p) * PORT_OFFSET)
+#define PFCE(p)		(0x0600 + (p) * PORT_OFFSET)
+#define PFCAE(p)	(0x0a00 + (p) * PORT_OFFSET)
+#define PIBC(p)		(0x4000 + (p) * PORT_OFFSET)
+#define PBDC(p)     (0x4100 + (p) * PORT_OFFSET)
+#define PIPC(p)		(0x4200 + (p) * PORT_OFFSET)
+
+static struct mutex	mutex;
+
+enum {
+	REG_PMC = 0,
+	REG_PFC,
+	REG_PFCE,
+	REG_PFCAE,
+	REG_NUM,
+};
+
+static bool mode_regset[][REG_NUM] = {
+      /* PMC,	PFC,	PFCE,	PFCAE */
+	{false,	false,	false,	false	}, /* port mode */
+	{true,	false,	false,	false	}, /* alt true */
+	{true,	true,	false,	false	}, /* alt 2 */
+	{true,	false,	true,	false	}, /* alt 3 */
+	{true,	true,	true,	false	}, /* alt 4 */
+	{true,	false,	false,	true	}, /* alt 5 */
+	{true,	true,	false,	true	}, /* alt 6 */
+	{true,	false,	true,	true	}, /* alt 7 */
+	{true,	true,	true,	true	}, /* alt 8 */
+};
+
+static unsigned int regs_addr[][REG_NUM] = {
+	{PMC(0), PFC(0), PFCE(0), PFCAE(0)},
+	{PMC(1), PFC(1), PFCE(1), PFCAE(1)},
+	{PMC(2), PFC(2), PFCE(2), PFCAE(2)},
+	{PMC(3), PFC(3), PFCE(3), PFCAE(3)},
+	{PMC(4), PFC(4), PFCE(4), PFCAE(4)},
+	{PMC(5), PFC(5), PFCE(5), PFCAE(5)},
+	{PMC(6), PFC(6), PFCE(6), PFCAE(6)},
+	{PMC(7), PFC(7), PFCE(7), PFCAE(7)},
+	{PMC(8), PFC(8), PFCE(8), PFCAE(8)},
+	{PMC(9), PFC(9), PFCE(9), PFCAE(9)},
+	{PMC(10), PFC(10), PFCE(10), PFCAE(10)},
+	{PMC(11), PFC(11), PFCE(11), PFCAE(11)},
+};
+
+static unsigned int port_nbit[] = {
+	6, 16, 16, 16, 16, 11, 16, 16, 16, 8, 16, 16,
+};
+
+
+static inline int _bit_modify(void __iomem *addr, int bit, bool data)
+{
+	__raw_writel((__raw_readl(addr) & ~(0x1 << bit)) | (data << bit), addr);
+	return 0;
+}
+
+static inline int bit_modify_P0(unsigned int addr, int bit, bool data)
+{
+	return _bit_modify(RZA1_BASE_P0 + addr, bit, data);
+}
+
+static inline int bit_modify(unsigned int addr, int bit, bool data)
+{
+	return _bit_modify(RZA1_BASE + addr, bit, data);
+}
+
+static int set_direction(unsigned int port, int bit, enum pfc_direction dir)
+{
+	if((port == 0) && (dir != DIR_IN))	/* p0 is input only */
+		return -1;
+
+	if (dir == DIR_IN) {
+		bit_modify(PM(port), bit, true);
+		bit_modify(PIBC(port), bit, true);
+	} else {
+		bit_modify(PM(port), bit, false);
+		bit_modify(PIBC(port), bit, false);
+	}
+
+	return 0;
+}
+
+static int set_bidirection(unsigned int port, int bit, bool bidirection)
+{
+	if(port <= 0)
+		return -1;
+
+	bit_modify(PBDC(port), bit, bidirection);
+
+	return 0;
+}
+
+static int get_port_bitshift(int *offset)
+{
+	unsigned int i;
+	for (i = 0; *offset >= port_nbit[i]; *offset -= port_nbit[i++])
+		if (i > ARRAY_SIZE(port_nbit))
+			return -1;
+	return i;
+}
+
+static int chip_gpio_get(struct gpio_chip *chip, unsigned offset)
+{
+	int port;
+	unsigned int d;
+
+	port = get_port_bitshift(&offset);
+
+
+	d = __raw_readl(RZA1_BASE + PPR(port));
+
+	return (d &= (0x1 << offset)) ? 1 : 0;
+}
+
+static void chip_gpio_set(struct gpio_chip *chip, unsigned offset, int val)
+{
+	int port;
+
+	port = get_port_bitshift(&offset);
+	if (port <= 0)	/* p0 is input only */
+		return;
+
+	bit_modify(PORT(port), offset, val);
+	return;
+}
+
+static int chip_direction_input(struct gpio_chip *chip, unsigned offset)
+{
+	int port;
+
+	port = get_port_bitshift(&offset);
+
+	mutex_lock(&mutex);
+	set_direction(port, offset, DIR_IN);
+	mutex_unlock(&mutex);
+
+	return 0;
+}
+
+static int chip_direction_output(struct gpio_chip *chip, unsigned offset,
+				 int val)
+{
+	int port;
+
+	port = get_port_bitshift(&offset);
+	if (port <= 0)	/* case : p0 is input only && negative value*/
+		return -1;
+
+	mutex_lock(&mutex);
+	bit_modify(PORT(port), offset, val);
+	set_direction(port, offset, DIR_OUT);
+	mutex_unlock(&mutex);
+
+	return 0;
+}
+
+static const char * const gpio_names[] = {
+	"P0_0", "P0_1", "P0_2", "P0_3", "P0_4", "P0_5",
+	"P1_0", "P1_1", "P1_2", "P1_3", "P1_4", "P1_5", "P1_6", "P1_7", "P1_8",
+	"P1_9", "P1_10", "P1_11", "P1_12", "P1_13", "P1_14", "P1_15",
+	"P2_0", "P2_1", "P2_2", "P2_3", "P2_4", "P2_5", "P2_6", "P2_7", "P2_8",
+	"P2_9", "P2_10", "P2_11", "P2_12", "P2_13", "P2_14", "P2_15",
+	"P3_0", "P3_1", "P3_2", "P3_3", "P3_4", "P3_5", "P3_6", "P3_7", "P3_8",
+	"P3_9", "P3_10", "P3_11", "P3_12", "P3_13", "P3_14", "P3_15",
+	"P4_0", "P4_1", "P4_2", "P4_3", "P4_4", "P4_5", "P4_6", "P4_7", "P4_8",
+	"P4_9", "P4_10", "P4_11", "P4_12", "P4_13", "P4_14", "P4_15",
+	"P5_0", "P5_1", "P5_2", "P5_3", "P5_4", "P5_5", "P5_6", "P5_7", "P5_8",
+	"P5_9", "P5_10",
+	"P6_0", "P6_1", "P6_2", "P6_3", "P6_4", "P6_5", "P6_6", "P6_7", "P6_8",
+	"P6_9", "P6_10", "P6_11", "P6_12", "P6_13", "P6_14", "P6_15",
+	"P7_0", "P7_1", "P7_2", "P7_3", "P7_4", "P7_5", "P7_6", "P7_7", "P7_8",
+	"P7_9", "P7_10", "P7_11", "P7_12", "P7_13", "P7_14", "P7_15",
+	"P8_0", "P8_1", "P8_2", "P8_3", "P8_4", "P8_5", "P8_6", "P8_7", "P8_8",
+	"P8_9", "P8_10", "P8_11", "P8_12", "P8_13", "P8_14", "P8_15",
+	"P9_0", "P9_1", "P9_2", "P9_3", "P9_4", "P9_5", "P9_6", "P9_7",
+	"P10_0", "P10_1", "P10_2", "P10_3", "P10_4", "P10_5", "P10_6", "P10_7",
+	"P10_8", "P10_9", "P10_10", "P10_11", "P10_12", "P10_13", "P10_14",
+	"P10_15",
+	"P11_0", "P11_1", "P11_2", "P11_3", "P11_4", "P11_5", "P11_6", "P11_7",
+	"P11_8", "P11_9", "P11_10", "P11_11", "P11_12", "P11_13", "P11_14",
+	"P11_15",
+};
+
+static struct gpio_chip chip = {
+	.label = GPIO_CHIP_NAME,
+	.names = gpio_names,
+	.base = 0,
+	.ngpio = GPIO_NR,
+
+	.get = chip_gpio_get,
+	.set = chip_gpio_set,
+
+	.direction_input = chip_direction_input,
+	.direction_output = chip_direction_output,
+};
+
+int rza1_pinmux_setup(void)
+{
+	int retval;
+	mutex_init(&mutex);
+	retval = gpiochip_add(&chip);
+	return retval;
+}
+
+static int set_mode(unsigned int port, int bit, int mode)
+{
+	unsigned int reg;
+
+	if(port < 0)
+		return -1;
+
+	if (port == 0) {
+		bit_modify_P0(regs_addr[port][REG_PMC], bit,
+				mode_regset[mode][REG_PMC]);
+		return 0;
+	}
+
+	for (reg = REG_PMC; reg < REG_NUM; reg++)
+		bit_modify(regs_addr[port][reg], bit, mode_regset[mode][reg]);
+
+	return 0;
+}
+
+static int ip_controlled_driver(unsigned int port, int bit, bool enable)
+{
+	if (port <= 0)
+		return -1;
+
+	bit_modify(PIPC(port), bit, enable);
+	return 0;
+}
+
+/*
+ * @pinnum: a pin number.
+ * @mode:   port mode or alternative N mode.
+ * @dir:    data direction (0:output, 1:input, 2:enable pipc)
+ *          PIPC enable SoC IP to control a direction.
+ */
+int rza1_pfc_pin_assign(enum pfc_pin_number pinnum, enum pfc_mode mode,
+			enum pfc_direction dir)
+{
+	int port, bit = (int)pinnum;
+
+	port = get_port_bitshift(&bit);
+	if (dir == DIR_PIPC)
+		ip_controlled_driver(port, bit, true);
+	else {
+		ip_controlled_driver(port, bit, false);
+		set_direction(port, bit, dir);
+	}
+
+	return set_mode(port, bit, mode);
+}
+EXPORT_SYMBOL(rza1_pfc_pin_assign);
+
+/*
+ * @pinnum: a pin number. 
+ * @bidirection:  Bidirection mode (0:disabled, 1:enabled) 
+ */
+int rza1_pfc_pin_bidirection(enum pfc_pin_number pinnum, bool bidirection)
+{
+	int port, bit = (int)pinnum;
+
+	port = get_port_bitshift(&bit);
+	set_bidirection(port, bit, bidirection);
+
+	return 0; 
+}
+EXPORT_SYMBOL(rza1_pfc_pin_bidirection);
+
diff --git a/arch/arm/mach-shmobile/rskrza1-vdc5fb.c b/arch/arm/mach-shmobile/rskrza1-vdc5fb.c
new file mode 100644
index 0000000..3f00f4d
--- /dev/null
+++ b/arch/arm/mach-shmobile/rskrza1-vdc5fb.c
@@ -0,0 +1,639 @@
+/*
+ * Frame Buffer Device Driver for VDC5
+ *
+ * Copyright (C) 2013 Renesas Solutions Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#if 0
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/fb.h>
+#include <mach/common.h>
+#include <mach/rza1.h>
+#include <video/vdc5fb.h>
+#endif
+
+/*************************************************************************/
+/* RESOURCES */
+
+/* CHANNEL 0 */
+static struct resource vdc5fb_resources_ch0[VDC5FB_NUM_RES] = {
+	[0] = {
+		.name	= "vdc5fb.0: reg",
+		.start	= VDC5FB_REG_BASE(0),
+		.end	= (VDC5FB_REG_BASE(0) + VDC5FB_REG_SIZE - 1),
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.name	= "vdc5fb.0: fb",
+		.start	= 0x60200000,
+		.end	= 0x605fffff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[2] = {
+		.name	= "vdc5fb.0: irq",
+		.start	= VDC5FB_IRQ_BASE(0),
+		.end	= (VDC5FB_IRQ_BASE(0) + VDC5FB_IRQ_SIZE - 1),
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+#if (VDC5FB_NUM_CH > 1)
+/* CHANNEL 1 */
+static struct resource vdc5fb_resources_ch1[VDC5FB_NUM_RES] = {
+	[0] = {
+		.name	= "vdc5fb.1: reg",
+		.start	= VDC5FB_REG_BASE(1),
+		.end	= (VDC5FB_REG_BASE(1) + VDC5FB_REG_SIZE - 1),
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.name	= "vdc5fb.1: fb",
+		.start	= 0x60600000,
+		.end	= 0x609fffff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[2] = {
+		.name	= "vdc5fb.1: irq",
+		.start	= VDC5FB_IRQ_BASE(1),
+		.end	= (VDC5FB_IRQ_BASE(1) + VDC5FB_IRQ_SIZE - 1),
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+#endif
+
+/*************************************************************************/
+/* LCD MONITOR */
+
+#define	P1CLK			((13330000 * 30) / 6)
+#define	PIXCLOCK(hz, div)	\
+	(u32)(1000000000000 / ((double)(hz) / (double)(div)))
+
+/* VIDEOMODE */
+
+#if 0
+static struct fb_videomode videomode_wxga = {
+	.name		= "WXGA",
+	.refresh	= -1,
+	.xres		= 1280,
+	.yres		= 768,
+	.pixclock	= PIXCLOCK(P1CLK, -1),
+	.left_margin	= -1,
+	.right_margin	= -1,
+	.upper_margin	= -1,
+	.lower_margin	= -1,
+	.hsync_len	= -1,
+	.vsync_len	= -1,
+	.sync		= -1,
+	.vmode		= -1,
+	.flag		= -1,
+};
+#endif
+/* Based on VESA TMD v1r11 1024x768@60Hz */
+static struct fb_videomode videomode_xga = {
+	.name		= "XGA",
+	.refresh	= 61,	/* calculated */
+	.xres		= 1024,
+	.yres		= 768,
+	.pixclock	= PIXCLOCK(P1CLK, 1),
+	.left_margin	= 32,	/* 160, */
+	.right_margin	= 152,	/* 24, */
+	.upper_margin	= 29,
+	.lower_margin	= 3,
+	.hsync_len	= 136,
+	.vsync_len	= 6,
+	.sync		= 0,
+	.vmode		= FB_VMODE_NONINTERLACED,
+	.flag		= 0,
+};
+
+#if 0
+static struct fb_videomode videomode_svga = {
+	.name		= "SVGA",
+	.refresh	= -1,	/* unsued */
+	.xres		= 800,
+	.yres		= 600,
+	.pixclock	= PIXCLOCK(P1CLK, -1),
+	.left_margin	= -1,
+	.right_margin	= -1,
+	.upper_margin	= -1,
+	.lower_margin	= -1,
+	.hsync_len	= -1,
+	.vsync_len	= -1,
+	.sync		= -1,
+	.vmode		= -1,
+	.flag		= -1,
+};
+#endif
+
+static int vdc5fb_pinmux_vga(struct platform_device *pdev);
+
+static struct vdc5fb_pdata vdc5fb_pdata_ch0_vga = {
+	.name			= "VESA VGA",
+	.videomode		= &videomode_xga,
+	.panel_icksel		= ICKSEL_P1CLK,
+	.bpp			= 16,
+	.panel_width		= 0,	/* unused */
+	.panel_height		= 0,	/* unused */
+	.flm_max		= 1,
+	.out_format		= OUT_FORMAT_RGB888,
+	.use_lvds		= 0,
+	.tcon_sel		= {
+		[LCD_TCON0]	= TCON_SEL_STH,		/* HSYNC */
+		[LCD_TCON1]	= TCON_SEL_STVA,	/* VSYNC */
+		[LCD_TCON2]	= TCON_SEL_UNUSED,	/* NC */
+		[LCD_TCON3]	= TCON_SEL_UNUSED,	/* NC */
+		[LCD_TCON4]	= TCON_SEL_UNUSED,	/* NC */
+		[LCD_TCON5]	= TCON_SEL_UNUSED,	/* NC */
+		[LCD_TCON6]	= TCON_SEL_UNUSED,	/* NC */
+	},
+	.pinmux			= vdc5fb_pinmux_vga,
+	.reset			= NULL,
+};
+static struct vdc5fb_pdata vdc5fb_pdata_ch1_vga = {
+	.name			= "VESA VGA",
+	.videomode		= &videomode_xga,
+	.panel_icksel		= ICKSEL_P1CLK,
+	.bpp			= 16,
+	.panel_width		= 0,	/* unused */
+	.panel_height		= 0,	/* unused */
+	.flm_max		= 1,
+	.out_format		= OUT_FORMAT_RGB888,
+	.use_lvds		= 0,
+	.tcon_sel		= {
+		[LCD_TCON0]	= TCON_SEL_UNUSED,	/* NC */
+		[LCD_TCON1]	= TCON_SEL_STVA,	/* VSYNC */
+		[LCD_TCON2]	= TCON_SEL_UNUSED,	/* NC */
+		[LCD_TCON3]	= TCON_SEL_UNUSED,	/* NC */
+		[LCD_TCON4]	= TCON_SEL_UNUSED,	/* NC */
+		[LCD_TCON5]	= TCON_SEL_STH,		/* HSYNC */
+		[LCD_TCON6]	= TCON_SEL_UNUSED,	/* NC */
+	},
+	.pinmux			= vdc5fb_pinmux_vga,
+	.reset			= NULL,
+};
+
+static int vdc5fb_pinmux_lcd(struct platform_device *pdev, int rgb)
+{
+	struct vdc5fb_pdata *pdata
+	    = (struct vdc5fb_pdata *)pdev->dev.platform_data;
+
+	if (pdev->id == 0) {	/* VDC5 CHANNEL 0 */
+		/* LCD0_EXTCLK */
+		if (pdata->panel_icksel == ICKSEL_EXTCLK0)
+			rza1_pfc_pin_assign(P5_8, ALT1, DIR_PIPC);
+		/* LCD0_DATA0 - LCD0_DATA17 */
+		rza1_pfc_pin_assign(P11_7, ALT5, DIR_PIPC);
+		rza1_pfc_pin_assign(P11_6, ALT5, DIR_PIPC);
+		rza1_pfc_pin_assign(P11_5, ALT5, DIR_PIPC);
+		rza1_pfc_pin_assign(P11_4, ALT5, DIR_PIPC);
+		rza1_pfc_pin_assign(P11_3, ALT5, DIR_PIPC);
+		rza1_pfc_pin_assign(P11_2, ALT5, DIR_PIPC);
+		rza1_pfc_pin_assign(P11_1, ALT5, DIR_PIPC);
+		rza1_pfc_pin_assign(P11_0, ALT5, DIR_PIPC);
+		rza1_pfc_pin_assign(P10_15, ALT5, DIR_PIPC);
+		rza1_pfc_pin_assign(P10_14, ALT5, DIR_PIPC);
+		rza1_pfc_pin_assign(P10_13, ALT5, DIR_PIPC);
+		rza1_pfc_pin_assign(P10_12, ALT5, DIR_PIPC);
+		rza1_pfc_pin_assign(P10_11, ALT5, DIR_PIPC);
+		rza1_pfc_pin_assign(P10_10, ALT5, DIR_PIPC);
+		rza1_pfc_pin_assign(P10_9, ALT5, DIR_PIPC);
+		rza1_pfc_pin_assign(P10_8, ALT5, DIR_PIPC);
+		rza1_pfc_pin_assign(P10_7, ALT5, DIR_PIPC);
+		rza1_pfc_pin_assign(P10_6, ALT5, DIR_PIPC);
+		if (rgb == 24) {
+			/* LCD0_DATA18 - LCD0_DATA23 */
+			rza1_pfc_pin_assign(P10_5, ALT5, DIR_PIPC);
+			rza1_pfc_pin_assign(P10_4, ALT5, DIR_PIPC);
+			rza1_pfc_pin_assign(P10_3, ALT5, DIR_PIPC);
+			rza1_pfc_pin_assign(P10_2, ALT5, DIR_PIPC);
+			rza1_pfc_pin_assign(P10_1, ALT5, DIR_PIPC);
+			rza1_pfc_pin_assign(P10_0, ALT5, DIR_PIPC);
+		}
+		/* LCD0_CLK (CLOCK) */
+		rza1_pfc_pin_assign(P11_15, ALT5, DIR_PIPC);
+		/* LCD0_TCON0 - LCD0_TCON6 */
+		if (pdata->tcon_sel[LCD_TCON0] != TCON_SEL_UNUSED)
+			rza1_pfc_pin_assign(P11_14, ALT5, DIR_PIPC);
+		if (pdata->tcon_sel[LCD_TCON1] != TCON_SEL_UNUSED)
+			rza1_pfc_pin_assign(P11_13, ALT5, DIR_PIPC);
+		if (pdata->tcon_sel[LCD_TCON2] != TCON_SEL_UNUSED)
+			rza1_pfc_pin_assign(P11_12, ALT5, DIR_PIPC);
+		if (pdata->tcon_sel[LCD_TCON3] != TCON_SEL_UNUSED)
+			rza1_pfc_pin_assign(P11_11, ALT5, DIR_PIPC);
+		if (pdata->tcon_sel[LCD_TCON4] != TCON_SEL_UNUSED)
+			rza1_pfc_pin_assign(P11_10, ALT5, DIR_PIPC);
+		if (pdata->tcon_sel[LCD_TCON5] != TCON_SEL_UNUSED)
+			rza1_pfc_pin_assign(P11_9, ALT5, DIR_PIPC);
+		if (pdata->tcon_sel[LCD_TCON6] != TCON_SEL_UNUSED)
+			rza1_pfc_pin_assign(P11_8, ALT5, DIR_PIPC);
+		return 0;
+	}
+#if (VDC5FB_NUM_CH > 1)
+	if (pdev->id == 1) {	/* VDC5 CHANNEL 1 */
+		/* LCD1_EXTCLK */
+		if (pdata->panel_icksel == ICKSEL_EXTCLK1)
+			rza1_pfc_pin_assign(P3_7, ALT4, DIR_PIPC);
+		/*LCD1_DATA0 - LCD1_DATA17 */
+		rza1_pfc_pin_assign(P5_0, ALT2, DIR_PIPC);
+		rza1_pfc_pin_assign(P5_1, ALT2, DIR_PIPC);
+		rza1_pfc_pin_assign(P5_2, ALT2, DIR_PIPC);
+		rza1_pfc_pin_assign(P5_3, ALT2, DIR_PIPC);
+		rza1_pfc_pin_assign(P5_4, ALT2, DIR_PIPC);
+		rza1_pfc_pin_assign(P5_5, ALT2, DIR_PIPC);
+		rza1_pfc_pin_assign(P5_6, ALT2, DIR_PIPC);
+		rza1_pfc_pin_assign(P5_7, ALT2, DIR_PIPC);
+		rza1_pfc_pin_assign(P2_8, ALT6, DIR_PIPC);
+		rza1_pfc_pin_assign(P2_9, ALT6, DIR_PIPC);
+		rza1_pfc_pin_assign(P2_10, ALT6, DIR_PIPC);
+		rza1_pfc_pin_assign(P2_11, ALT6, DIR_PIPC);
+		rza1_pfc_pin_assign(P2_12, ALT7, DIR_PIPC);
+		rza1_pfc_pin_assign(P2_13, ALT7, DIR_PIPC);
+		rza1_pfc_pin_assign(P2_14, ALT7, DIR_PIPC);
+		rza1_pfc_pin_assign(P2_15, ALT7, DIR_PIPC);
+		rza1_pfc_pin_assign(P5_9, ALT7, DIR_PIPC);
+		rza1_pfc_pin_assign(P5_10, ALT7, DIR_PIPC);
+		if (rgb == 24) {
+			/* LCD1_DATA18 - LCD1_DATA23 */
+			rza1_pfc_pin_assign(P9_2, ALT1, DIR_PIPC);
+			rza1_pfc_pin_assign(P9_3, ALT1, DIR_PIPC);
+			rza1_pfc_pin_assign(P9_4, ALT1, DIR_PIPC);
+			rza1_pfc_pin_assign(P9_5, ALT1, DIR_PIPC);
+			rza1_pfc_pin_assign(P9_6, ALT1, DIR_PIPC);
+			rza1_pfc_pin_assign(P9_7, ALT1, DIR_PIPC);
+		}
+		/* LCD1_CLK (CLOCK) */
+		rza1_pfc_pin_assign(P4_12,  ALT2, DIR_PIPC);
+		/* LCD0_TCON0 - LCD0_TCON6 */
+		if (pdata->tcon_sel[LCD_TCON0] != TCON_SEL_UNUSED)
+			rza1_pfc_pin_assign(P4_13,  ALT2, DIR_PIPC);
+		if (pdata->tcon_sel[LCD_TCON1] != TCON_SEL_UNUSED)
+			rza1_pfc_pin_assign(P4_14,  ALT2, DIR_PIPC);
+		if (pdata->tcon_sel[LCD_TCON2] != TCON_SEL_UNUSED)
+			rza1_pfc_pin_assign(P4_15,  ALT2, DIR_PIPC);
+		if (pdata->tcon_sel[LCD_TCON3] != TCON_SEL_UNUSED)
+			rza1_pfc_pin_assign(P4_8,  ALT2, DIR_PIPC);
+		if (pdata->tcon_sel[LCD_TCON4] != TCON_SEL_UNUSED)
+			rza1_pfc_pin_assign(P4_9,  ALT2, DIR_PIPC);
+		if (pdata->tcon_sel[LCD_TCON5] != TCON_SEL_UNUSED)
+			rza1_pfc_pin_assign(P4_10,  ALT2, DIR_PIPC);
+		if (pdata->tcon_sel[LCD_TCON6] != TCON_SEL_UNUSED)
+			rza1_pfc_pin_assign(P4_11,  ALT2, DIR_PIPC);
+		return 0;
+	}
+#endif /* VDC5FB_NUM_CH > 1 */
+	return -ENODEV;
+}
+
+static int vdc5fb_pinmux_vga(struct platform_device *pdev)
+{
+	return vdc5fb_pinmux_lcd(pdev, 24);
+}
+
+/*************************************************************************/
+/* LCD-KIT-B01 */
+
+static struct fb_videomode videomode_wvga_lcd_kit_b01 = {
+	.name		= "WVGA",
+	.refresh	= 60,	/* unsued */
+	.xres		= 800,
+	.yres		= 480,
+	.pixclock	= PIXCLOCK(P1CLK, 2),
+	.left_margin	= 0,
+	.right_margin	= 64,
+	.upper_margin	= 18,
+	.lower_margin	= 18,
+	.hsync_len	= 128,
+	.vsync_len	= 4,
+	.sync		= 0,	/* to be fixed */
+	.vmode		= 0,	/* to be fixed */
+	.flag		= 0,	/* to be fixed */
+};
+
+static int vdc5fb_pinmux_lcd_kit_b01(struct platform_device *pdev);
+static int vdc5fb_reset_lcd_kit_b01(struct platform_device *pdev);
+
+static struct vdc5fb_pdata vdc5fb_pdata_ch0_lcd_kit_b01 = {
+	.name			= "LCD-KIT-B01",
+	.videomode		= &videomode_wvga_lcd_kit_b01,
+	.panel_icksel		= ICKSEL_P1CLK,
+	.bpp			= 32,
+	.panel_width		= 184,	/* mm, unused */
+	.panel_height		= 132,	/* mm, unused */
+	.flm_max		= 1,
+	.out_format		= OUT_FORMAT_RGB666,
+	.use_lvds		= 0,
+	.tcon_sel		= {
+		[LCD_TCON0]	= TCON_SEL_UNUSED,	/* RESET */
+		[LCD_TCON1]	= TCON_SEL_UNUSED,	/* INT */
+		[LCD_TCON2]	= TCON_SEL_DE,		/* DE */
+		[LCD_TCON3]	= TCON_SEL_STH,		/* HSYNC(NC) */
+		[LCD_TCON4]	= TCON_SEL_STVA,	/* VSYNC(NC) */
+		[LCD_TCON5]	= TCON_SEL_UNUSED,	/* NC */
+		[LCD_TCON6]	= TCON_SEL_UNUSED,	/* NC */
+	},
+	.pinmux			= vdc5fb_pinmux_lcd_kit_b01,
+	.reset			= vdc5fb_reset_lcd_kit_b01,
+};
+static struct vdc5fb_pdata vdc5fb_pdata_ch1_lcd_kit_b01 = {
+	.name			= "LCD-KIT-B01",
+	.videomode		= &videomode_wvga_lcd_kit_b01,
+	.panel_icksel		= ICKSEL_P1CLK,
+	.bpp			= 32,
+	.panel_width		= 184,	/* mm, unused */
+	.panel_height		= 132,	/* mm, unused */
+	.flm_max		= 1,
+	.out_format		= OUT_FORMAT_RGB666,
+	.use_lvds		= 0,
+	.tcon_sel		= {
+		[LCD_TCON0]	= TCON_SEL_STH,		/* HSYNC(NC) */
+		[LCD_TCON1]	= TCON_SEL_DE,		/* DE */
+		[LCD_TCON2]	= TCON_SEL_STVA,	/* VSYNC(NC) */
+		[LCD_TCON3]	= TCON_SEL_UNUSED,	/* INT */
+		[LCD_TCON4]	= TCON_SEL_UNUSED,	/* RESET */
+		[LCD_TCON5]	= TCON_SEL_UNUSED,	/* NC */
+		[LCD_TCON6]	= TCON_SEL_UNUSED,	/* NC */
+	},
+	.pinmux			= vdc5fb_pinmux_lcd_kit_b01,
+	.reset			= vdc5fb_reset_lcd_kit_b01,
+};
+
+static int vdc5fb_pinmux_lcd_kit_b01(struct platform_device *pdev)
+{
+	vdc5fb_pinmux_lcd(pdev, 18);
+
+	if (pdev->id == 0) {
+		/* RIIC0SCL and RIIC0SDA should be initialized by I2C */
+
+		/* LCD0_TCON0 (RESET) */
+		/* This should be initailized by pdata->reset func, */
+
+		/* LCD0_TCON1 (INT) */
+		rza1_pfc_pin_assign(P11_13, PMODE, DIR_IN);
+		return 0;
+	}
+#if (VDC5FB_NUM_CH > 1)
+	if (pdev->id == 1) {
+		/* RIIC3SCL and RIIC3SDA should be initialized by I2C */
+
+		/* LCD1_TCON4 (RESET) */
+		/* This should be initailized by pdata->reset func, */
+
+		/* LCD1_TCON3 (INT) */
+		rza1_pfc_pin_assign(P4_8, PMODE, DIR_IN);
+		return 0;
+	}
+#endif /* VDC5FB_NUM_CH > 1 */
+	return -ENODEV;
+}
+
+static int vdc5fb_reset_lcd_kit_b01(struct platform_device *pdev)
+{
+	void *PSR;
+	u32 tmp;
+
+	if (pdev->id == 0) {
+		/* VDC5 CHANNEL 0 (RESET is P11_14) */
+		PSR = (void *)(0xFCFE3000 + 0x012C);
+
+		tmp = (1u << (16 + 14)) | (1u << 14);
+		iowrite32(tmp, PSR);
+		/* LCD0_TCON0 (RESET) */
+		rza1_pfc_pin_assign(P11_14, PMODE, DIR_OUT);
+		udelay(500);
+		tmp = (1u << (16 + 14)) | (0u << 14);
+		iowrite32(tmp, PSR);
+		udelay(500);
+		tmp = (1u << (16 + 14)) | (1u << 14);
+		iowrite32(tmp, PSR);
+		return 0;
+	}
+#if (VDC5FB_NUM_CH > 1)
+	if (pdev->id == 1) {
+		/* VDC5 CHANNEL 1 (RESET is P4_9) */
+		PSR = (void *)(0xFCFE3000 + 0x0110);
+
+		tmp = (1u << (16 + 9)) | (1u << 9);
+		iowrite32(tmp, PSR);
+		/* LCD1_TCON4 (RESET) */
+		rza1_pfc_pin_assign(P4_9, PMODE, DIR_OUT);
+		udelay(500);
+		tmp = (1u << (16 + 9)) | (0u << 9);
+		iowrite32(tmp, PSR);
+		udelay(500);
+		tmp = (1u << (16 + 9)) | (1u << 9);
+		iowrite32(tmp, PSR);
+		return 0;
+	}
+#endif /* VDC5FB_NUM_CH > 1 */
+	return -ENODEV;
+}
+
+/*************************************************************************/
+/* PLATFORM DATA */
+
+/* Based on VESA TMD v1r11 800x600@56Hz */
+static struct fb_videomode videomode_wvga_r0p7724le0011rl = {
+	.name		= "WVGA",
+	.refresh	= -1,	/* not fixed */
+	.xres		= 800,
+	.yres		= 480,
+	.pixclock	= PIXCLOCK(P1CLK, 2),
+	.left_margin	= 128,
+	.right_margin	= 24,
+	.upper_margin	= 22,
+	.lower_margin	= 1,
+	.hsync_len	= 72,
+	.vsync_len	= 2,
+	.sync		= (FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT),
+	.vmode		= FB_VMODE_NONINTERLACED,
+	.flag		= 0,
+};
+
+static int vdc5fb_pinmux_r0p7724le0011rl(struct platform_device *pdev);
+
+#if (VDC5FB_NUM_CH > 1)
+/* CHANNEL 1 */
+static struct vdc5fb_pdata vdc5fb_pdata_r0p7724le0011rl = {
+	.name			= "R0P7724LE0011RL",
+	.videomode		= &videomode_wvga_r0p7724le0011rl,
+	.panel_icksel		= ICKSEL_P1CLK,
+	.bpp			= 32,
+	.panel_width		= 165,	/* mm, unused */
+	.panel_height		= 106,	/* mm, unused */
+	.flm_max		= 1,
+	.out_format		= OUT_FORMAT_RGB666,
+	.use_lvds		= 0,
+	.tcon_sel		= {
+		[LCD_TCON0]	= TCON_SEL_UNUSED,	/* NC */
+		[LCD_TCON1]	= TCON_SEL_UNUSED,	/* NC*/
+		[LCD_TCON2]	= TCON_SEL_UNUSED,	/* NC*/
+		[LCD_TCON3]	= TCON_SEL_STVA,	/* LCDVSYN */
+		[LCD_TCON4]	= TCON_SEL_STH,		/* LCDHSYN */
+		[LCD_TCON5]	= TCON_SEL_DE,		/* LCDDISP(DE) */
+		[LCD_TCON6]	= TCON_SEL_UNUSED,	/* TP_IRQ# */
+	},
+	.pinmux			= vdc5fb_pinmux_r0p7724le0011rl,
+	.reset			= NULL,
+};
+#endif /* (VDC5FB_NUM_CH > 1) */
+
+static int vdc5fb_pinmux_r0p7724le0011rl(struct platform_device *pdev)
+{
+	vdc5fb_pinmux_lcd(pdev, 18);
+
+#if (VDC5FB_NUM_CH > 1)
+	if (pdev->id == 1) {
+		/* RIIC3SCL and RIIC3SDA should be initialized by I2C */
+
+		/* LCD1_TCON6 (TP_IRQ#) */
+		rza1_pfc_pin_assign(P4_11, PMODE, DIR_IN);
+		return 0;
+	}
+#endif /* VDC5FB_NUM_CH > 1 */
+	return -ENODEV;
+}
+
+/*************************************************************************/
+/* PLATFORM DEVICES */
+
+static struct platform_device vdc5fb_devices[VDC5FB_NUM_CH] = {
+	[0] = {
+		.name		= "vdc5fb",
+		.id		= 0,
+		.num_resources	= ARRAY_SIZE(vdc5fb_resources_ch0),
+		.resource	= vdc5fb_resources_ch0,
+		.dev = {
+			.dma_mask		= NULL,
+			.coherent_dma_mask	= 0xffffffff,
+			.platform_data		= &vdc5fb_pdata_ch0_lcd_kit_b01,
+		},
+	},
+#if (VDC5FB_NUM_CH > 1)
+	[1] = {
+		.name		= "vdc5fb",
+		.id		= 1,
+		.num_resources	= ARRAY_SIZE(vdc5fb_resources_ch1),
+		.resource	= vdc5fb_resources_ch1,
+		.dev = {
+			.dma_mask		= NULL,
+			.coherent_dma_mask	= 0xffffffff,
+			.platform_data		= &vdc5fb_pdata_ch1_vga,
+		},
+	},
+#endif /* VDC5FB_NUM_CH > 1 */
+};
+
+/*************************************************************************/
+/* BOOT OPTIONS */
+
+int disable_ether /* = 0 */;
+static int disable_sdhi /* = 0 */;
+static unsigned int vdc5fb0_opts = 1;
+static unsigned int vdc5fb1_opts /* = 0 */;
+
+int __init early_vdc5fb0(char *str)
+{
+	get_option(&str, &vdc5fb0_opts);
+	return 0;
+}
+early_param("vdc5fb0", early_vdc5fb0);
+
+int __init early_vdc5fb1(char *str)
+{
+	get_option(&str, &vdc5fb1_opts);
+	if (vdc5fb1_opts != 0) {
+		disable_ether = 1;
+		disable_sdhi = 1;
+	}
+	return 0;
+}
+early_param("vdc5fb1", early_vdc5fb1);
+
+/*************************************************************************/
+/* SETUP */
+
+static struct platform_device *display_devices[] __initdata = {
+#if defined(CONFIG_FB_VDC5)
+	&vdc5fb_devices[0],
+#if (VDC5FB_NUM_CH > 1)
+	&vdc5fb_devices[1],
+#endif
+#endif
+};
+
+static int vdc5fb_setup(void)
+{
+	struct platform_device *pdev;
+	int n;
+
+	for (n = 0; n < VDC5FB_NUM_CH; n++) {
+		pdev = &vdc5fb_devices[n];
+
+		if (pdev->id == 0) {		/* VDC5 CHANNEL 0 */
+			switch (vdc5fb0_opts) {
+			case 0:	/* Turn off */
+				dev_info(&pdev->dev,
+					"vdc5fb.%d: channel 0 is turned off\n",
+					pdev->id);
+				pdev->name = "vdc5fb.0(hidden)";
+				break;
+			case 1:	/* LCD_KIT_B01 (default) */
+				pdev->dev.platform_data =
+					&vdc5fb_pdata_ch0_lcd_kit_b01;
+				break;
+			case 2:	/* LCD Monitor (VGA) */
+				pdev->dev.platform_data =
+					&vdc5fb_pdata_ch0_vga;
+				break;
+			case 3:	/* Add channel 1 first */
+				break;
+			default:
+				break;
+			}
+		}
+#if (VDC5FB_NUM_CH > 1)
+		else if (pdev->id == 1) {	/* VDC5 CHANNEL 1 */
+			switch (vdc5fb1_opts) {
+			case 0:	/* Turn off (default) */
+				dev_info(&pdev->dev,
+					"vdc5fb.%d: channel 1 is turned off\n",
+					pdev->id);
+				pdev->name = "vdc5fb.1(hidden)";
+				break;
+			case 1:	/* LCD-KIT-B01 */
+				pdev->dev.platform_data =
+					&vdc5fb_pdata_ch1_lcd_kit_b01;
+				break;
+			case 2:	/* R0P7724LE0011RL */
+				pdev->dev.platform_data =
+					&vdc5fb_pdata_r0p7724le0011rl;
+				break;
+			case 3:	/* LCD monitor */
+				pdev->dev.platform_data =
+					&vdc5fb_pdata_ch1_vga;
+				break;
+			default:
+				break;
+			}
+		}
+#endif
+	}
+	platform_add_devices(display_devices, ARRAY_SIZE(display_devices));
+	return 0;
+}
+
diff --git a/arch/arm/mach-shmobile/setup-rza1.c b/arch/arm/mach-shmobile/setup-rza1.c
new file mode 100644
index 0000000..5b5c96d
--- /dev/null
+++ b/arch/arm/mach-shmobile/setup-rza1.c
@@ -0,0 +1,1016 @@
+/*
+ * rskrza1 board support
+ *
+ * Copyright (C) 2012-2013 Renesas Solutions Corp.
+ * Copyright (C) 2012  Renesas Electronics Europe Ltd
+ * Copyright (C) 2012  Phil Edworthy
+ * Copyright (C) 2012 Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
+ * Copyright (C) 2010  Magnus Damm
+ * Copyright (C) 2008  Yoshihiro Shimoda
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <asm/mach/map.h>
+#include <asm/mach-types.h>
+#include <asm/mach/time.h>
+#include <linux/init.h>
+#include <linux/i2c/riic.h>
+#include <linux/io.h>
+#include <linux/platform_data/sh_adc.h>
+#include <linux/platform_device.h>
+#include <linux/serial.h>
+#include <linux/serial_sci.h>
+#include <linux/spi/rspi.h>
+#include <linux/sh_eth.h>
+#include <linux/sh_timer.h>
+#include <linux/usb/r8a66597.h>
+#include <linux/spi/sh_spibsc.h>
+#include <linux/platform_data/dma-rza1.h>
+#include <mach/common.h>
+#include <mach/hardware.h>
+#include <mach/irqs.h>
+#include <mach/rza1.h>
+#include <sound/sh_scux.h>
+
+static struct map_desc rza1_io_desc[] __initdata = {
+	/* create a 1:1 entity map for 0xe8xxxxxx
+	 * used by INTC.
+	 */
+	{
+		.virtual	= 0xe8000000,
+		.pfn		= __phys_to_pfn(0xe8000000),
+		.length		= 256 << 20,
+		.type		= MT_DEVICE_NONSHARED
+	},
+	/* create a 1:1 entity map for 0xfcffxxxx
+	 * used by MTU2, RTC.
+	 */
+	{
+		.virtual	= 0xfcff0000,
+		.pfn		= __phys_to_pfn(0xfcff0000),
+		.length		= 256 << 8,
+		.type		= MT_DEVICE_NONSHARED
+	},
+	/* create a 1:1 entity map for 0xfcfexxxx
+	 * used by MSTP, CPG.
+	 */
+	{
+		.virtual	= 0xfcfe0000,
+		.pfn		= __phys_to_pfn(0xfcfe0000),
+		.length		= (256 << 8) - 1,
+		.type		= MT_DEVICE_NONSHARED
+	},
+};
+
+void __init rza1_map_io(void)
+{
+	iotable_init(rza1_io_desc, ARRAY_SIZE(rza1_io_desc));
+}
+
+static struct plat_sci_port scif0_platform_data = {
+	.mapbase	= 0xe8007000,
+	.flags		= UPF_BOOT_AUTOCONF,
+	.scscr		= SCSCR_RIE | SCSCR_TIE | SCSCR_RE | SCSCR_TE |
+			  SCSCR_REIE,
+	.scbrr_algo_id	= SCBRR_ALGO_2,
+	.type		= PORT_SCIF,
+	.irqs		=  { 222, 223, 224, 221 },
+	.regtype	= SCIx_SH2_SCIF_FIFODATA_REGTYPE,
+};
+
+static struct platform_device scif0_device = {
+	.name		= "sh-sci",
+	.id		= 0,
+	.dev		= {
+		.platform_data	= &scif0_platform_data,
+	},
+};
+
+static struct plat_sci_port scif1_platform_data = {
+	.mapbase	= 0xe8007800,
+	.flags		= UPF_BOOT_AUTOCONF,
+	.scscr		= SCSCR_RIE | SCSCR_TIE | SCSCR_RE | SCSCR_TE |
+			  SCSCR_REIE,
+	.scbrr_algo_id	= SCBRR_ALGO_2,
+	.type		= PORT_SCIF,
+	.irqs		=  { 226, 227, 228, 225 },
+	.regtype	= SCIx_SH2_SCIF_FIFODATA_REGTYPE,
+};
+
+static struct platform_device scif1_device = {
+	.name		= "sh-sci",
+	.id		= 1,
+	.dev		= {
+		.platform_data	= &scif1_platform_data,
+	},
+};
+
+static struct plat_sci_port scif2_platform_data = {
+	.mapbase	= 0xe8008000,
+	.flags		= UPF_BOOT_AUTOCONF,
+	.scscr		= SCSCR_RIE | SCSCR_TIE | SCSCR_RE | SCSCR_TE |
+			  SCSCR_REIE,
+	.scbrr_algo_id	= SCBRR_ALGO_2,
+	.type		= PORT_SCIF,
+	.irqs		=  { 230, 231, 232, 229 },
+	.regtype	= SCIx_SH2_SCIF_FIFODATA_REGTYPE,
+};
+
+static struct platform_device scif2_device = {
+	.name		= "sh-sci",
+	.id		= 2,
+	.dev		= {
+		.platform_data	= &scif2_platform_data,
+	},
+};
+
+static struct plat_sci_port scif3_platform_data = {
+	.mapbase	= 0xe8008800,
+	.flags		= UPF_BOOT_AUTOCONF,
+	.scscr		= SCSCR_RIE | SCSCR_TIE | SCSCR_RE | SCSCR_TE |
+			  SCSCR_REIE,
+	.scbrr_algo_id	= SCBRR_ALGO_2,
+	.type		= PORT_SCIF,
+	.irqs		=  { 234, 235, 236, 233 },
+	.regtype	= SCIx_SH2_SCIF_FIFODATA_REGTYPE,
+};
+
+static struct platform_device scif3_device = {
+	.name		= "sh-sci",
+	.id		= 3,
+	.dev		= {
+		.platform_data	= &scif3_platform_data,
+	},
+};
+
+static struct plat_sci_port scif4_platform_data = {
+	.mapbase	= 0xe8009000,
+	.flags		= UPF_BOOT_AUTOCONF,
+	.scscr		= SCSCR_RIE | SCSCR_TIE | SCSCR_RE | SCSCR_TE |
+			  SCSCR_REIE,
+	.scbrr_algo_id	= SCBRR_ALGO_2,
+	.type		= PORT_SCIF,
+	.irqs		=  { 238, 239, 240, 237 },
+	.regtype	= SCIx_SH2_SCIF_FIFODATA_REGTYPE,
+};
+
+static struct platform_device scif4_device = {
+	.name		= "sh-sci",
+	.id		= 4,
+	.dev		= {
+		.platform_data	= &scif4_platform_data,
+	},
+};
+
+static struct plat_sci_port scif5_platform_data = {
+	.mapbase	= 0xe8009800,
+	.flags		= UPF_BOOT_AUTOCONF,
+	.scscr		= SCSCR_RIE | SCSCR_TIE | SCSCR_RE | SCSCR_TE |
+			  SCSCR_REIE,
+	.scbrr_algo_id	= SCBRR_ALGO_2,
+	.type		= PORT_SCIF,
+	.irqs		=  { 242, 243, 244, 241 },
+	.regtype	= SCIx_SH2_SCIF_FIFODATA_REGTYPE,
+};
+
+static struct platform_device scif5_device = {
+	.name		= "sh-sci",
+	.id		= 5,
+	.dev		= {
+		.platform_data	= &scif5_platform_data,
+	},
+};
+
+static struct plat_sci_port scif6_platform_data = {
+	.mapbase	= 0xe800a000,
+	.flags		= UPF_BOOT_AUTOCONF,
+	.scscr		= SCSCR_RIE | SCSCR_TIE | SCSCR_RE | SCSCR_TE |
+			  SCSCR_REIE,
+	.scbrr_algo_id	= SCBRR_ALGO_2,
+	.type		= PORT_SCIF,
+	.irqs		=  { 246, 247, 248, 245 },
+	.regtype	= SCIx_SH2_SCIF_FIFODATA_REGTYPE,
+};
+
+static struct platform_device scif6_device = {
+	.name		= "sh-sci",
+	.id		= 6,
+	.dev		= {
+		.platform_data	= &scif6_platform_data,
+	},
+};
+
+static struct plat_sci_port scif7_platform_data = {
+	.mapbase	= 0xe800a800,
+	.flags		= UPF_BOOT_AUTOCONF,
+	.scscr		= SCSCR_RIE | SCSCR_TIE | SCSCR_RE | SCSCR_TE |
+			  SCSCR_REIE,
+	.scbrr_algo_id	= SCBRR_ALGO_2,
+	.type		= PORT_SCIF,
+	.irqs		=  { 250, 251, 252, 249 },
+	.regtype	= SCIx_SH2_SCIF_FIFODATA_REGTYPE,
+};
+
+static struct platform_device scif7_device = {
+	.name		= "sh-sci",
+	.id		= 7,
+	.dev		= {
+		.platform_data	= &scif7_platform_data,
+	},
+};
+
+static struct sh_timer_config mtu2_0_platform_data = {
+	.channel_offset = -0x80,
+	.timer_bit = 0,
+	.clockevent_rating = 200,
+};
+
+static struct resource mtu2_0_resources[] = {
+	[0] = {
+		.start	= 0xfcff0300,
+		.end	= 0xfcff0326,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= 139,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device mtu2_0_device = {
+	.name		= "sh_mtu2",
+	.id		= 0,
+	.dev = {
+		.platform_data = &mtu2_0_platform_data,
+	},
+	.resource	= mtu2_0_resources,
+	.num_resources	= ARRAY_SIZE(mtu2_0_resources),
+};
+
+/* RTC */
+static struct resource rtc_resources[] = {
+	[0] = {
+		.start	= 0xfcff1000,
+		.end	= 0xfcff102d,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		/* Period IRQ */
+		.start	= 309,
+		.flags	= IORESOURCE_IRQ,
+	},
+	[2] = {
+		/* Carry IRQ */
+		.start	= 310,
+		.flags	= IORESOURCE_IRQ,
+	},
+	[3] = {
+		/* Alarm IRQ */
+		.start	= 308,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device rtc_device = {
+	.name		= "sh-rtc",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(rtc_resources),
+	.resource	= rtc_resources,
+};
+
+/* USB Host */
+static struct r8a66597_platdata r8a66597_data = {
+	.endian = 0,
+	.on_chip = 1,
+	.xtal = R8A66597_PLATDATA_XTAL_48MHZ,
+};
+
+static struct resource r8a66597_usb_host0_resources[] = {
+	[0] = {
+		.start	= 0xe8010000,
+		.end	= 0xe80101a0 - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= 73,
+		.end	= 73,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device r8a66597_usb_host0_device = {
+	.name		= "r8a66597_hcd",
+	.id		= 0,
+	.dev = {
+		.dma_mask		= NULL,		/*  not use dma */
+		.coherent_dma_mask	= 0xffffffff,
+		.platform_data		= &r8a66597_data,
+	},
+	.num_resources	= ARRAY_SIZE(r8a66597_usb_host0_resources),
+	.resource	= r8a66597_usb_host0_resources,
+};
+
+static struct resource r8a66597_usb_host1_resources[] = {
+	[0] = {
+		.start	= 0xe8207000,
+		.end	= 0xe82071a0 - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= 74,
+		.end	= 74,
+		.flags	= IORESOURCE_IRQ,
+	}
+};
+
+static struct platform_device r8a66597_usb_host1_device = {
+	.name		= "r8a66597_hcd",
+	.id		= 1,
+	.dev = {
+		.dma_mask		= NULL,		/*  not use dma */
+		.coherent_dma_mask	= 0xffffffff,
+		.platform_data		= &r8a66597_data,
+	},
+	.num_resources	= ARRAY_SIZE(r8a66597_usb_host1_resources),
+	.resource	= r8a66597_usb_host1_resources,
+};
+
+/* Ether */
+static struct sh_eth_plat_data sh_eth_platdata = {
+	.phy			= 0x00,
+	.edmac_endian		= EDMAC_LITTLE_ENDIAN,
+	.register_type		= SH_ETH_REG_GIGABIT,
+	.phy_interface		= PHY_INTERFACE_MODE_MII,
+};
+
+static struct resource sh_eth_resources[] = {
+	[0] = {
+		.start	= 0xe8203000,
+		.end	= 0xe8204a00 - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= 359,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device sh_eth_device = {
+	.name = "sh-eth",
+	.id = 0,
+	.dev = {
+		.platform_data = &sh_eth_platdata,
+	},
+	.resource = sh_eth_resources,
+	.num_resources = ARRAY_SIZE(sh_eth_resources),
+};
+
+/* riic(i2c) */
+static struct resource i2c_resources0[] = {
+	[0] = {
+		.start	= 0xfcfee000,
+		.end	= 0xfcfee400 - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= 189,
+		.end	= 189,
+		.flags	= IORESOURCE_IRQ,
+	},
+	[2] = {
+		.start	= 190,
+		.end	= 191,
+		.flags	= IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHEDGE,
+	},
+	[3] = {
+		.start	= 192,
+		.end	= 196,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct riic_platform_data pdata0 = {
+	/* Transfer Rate 100 or 400 [kbps] */
+	.clock			= 100,
+};
+
+static struct platform_device i2c_device0 = {
+	.name		= "i2c-riic",
+	.id		= 0,
+	.dev.platform_data = &pdata0,
+	.num_resources	= ARRAY_SIZE(i2c_resources0),
+	.resource	= i2c_resources0,
+};
+
+static struct resource i2c_resources1[] = {
+	[0] = {
+		.start	= 0xfcfee400,
+		.end	= 0xfcfee800 - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= 197,
+		.end	= 197,
+		.flags	= IORESOURCE_IRQ,
+	},
+	[2] = {
+		.start	= 198,
+		.end	= 199,
+		.flags	= IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHEDGE,
+	},
+	[3] = {
+		.start	= 200,
+		.end	= 204,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct riic_platform_data pdata1 = {
+	/* Transfer Rate 100 or 400 [kbps] */
+	.clock			= 100,
+};
+
+static struct platform_device i2c_device1 = {
+	.name		= "i2c-riic",
+	.id		= 1,
+	.dev.platform_data = &pdata1,
+	.num_resources	= ARRAY_SIZE(i2c_resources1),
+	.resource	= i2c_resources1,
+};
+
+static struct resource i2c_resources2[] = {
+	[0] = {
+		.start	= 0xfcfee800,
+		.end	= 0xfcfeec00 - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= 205,
+		.end	= 205,
+		.flags	= IORESOURCE_IRQ,
+	},
+	[2] = {
+		.start	= 206,
+		.end	= 207,
+		.flags	= IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHEDGE,
+	},
+	[3] = {
+		.start	= 208,
+		.end	= 212,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct riic_platform_data pdata2 = {
+	/* Transfer Rate 100 or 400 [kbps] */
+	.clock			= 100,
+};
+
+static struct platform_device i2c_device2 = {
+	.name		= "i2c-riic",
+	.id		= 2,
+	.dev.platform_data = &pdata2,
+	.num_resources	= ARRAY_SIZE(i2c_resources2),
+	.resource	= i2c_resources2,
+};
+
+static struct resource i2c_resources3[] = {
+	[0] = {
+		.start	= 0xfcfeec00,
+		.end	= 0xfcfeefff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= 213,
+		.end	= 213,
+		.flags	= IORESOURCE_IRQ,
+	},
+	[2] = {
+		.start	= 214,
+		.end	= 215,
+		.flags	= IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHEDGE,
+	},
+	[3] = {
+		.start	= 216,
+		.end	= 220,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct riic_platform_data pdata3 = {
+	/* Transfer Rate 100 or 400 [kbps] */
+	.clock			= 100,
+};
+
+static struct platform_device i2c_device3 = {
+	.name		= "i2c-riic",
+	.id		= 3,
+	.dev.platform_data = &pdata3,
+	.num_resources	= ARRAY_SIZE(i2c_resources3),
+	.resource	= i2c_resources3,
+};
+
+/* SPI */
+static struct resource spi0_resources[] = {
+	[0] = {
+		.start	= 0xe800c800,
+		.end	= 0xe800c8ff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= 270,
+		.end	= 272,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct rspi_plat_data rspi_pdata = {
+	.data_width = 8,
+	.spcr = false,
+	.txmode = false,
+};
+
+static struct platform_device spi0_device = {
+	.name	= "rspi",
+	.id	= 0,
+	.dev	= {
+		.platform_data		= &rspi_pdata,
+	},
+	.num_resources	= ARRAY_SIZE(spi0_resources),
+	.resource	= spi0_resources,
+};
+
+static struct resource spi1_resources[] = {
+	[0] = {
+		.start	= 0xe800d000,
+		.end	= 0xe800d0ff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= 273,
+		.end	= 275,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device spi1_device = {
+	.name	= "rspi",
+	.id	= 1,
+	.dev	= {
+		.platform_data		= &rspi_pdata,
+	},
+	.num_resources	= ARRAY_SIZE(spi1_resources),
+	.resource	= spi1_resources,
+};
+
+static struct resource spi2_resources[] = {
+	[0] = {
+		.start	= 0xe800d800,
+		.end	= 0xe800d8ff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= 276,
+		.end	= 278,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device spi2_device = {
+	.name	= "rspi",
+	.id	= 2,
+	.dev	= {
+		.platform_data		= &rspi_pdata,
+	},
+	.num_resources	= ARRAY_SIZE(spi2_resources),
+	.resource	= spi2_resources,
+};
+
+static struct resource spi3_resources[] = {
+	[0] = {
+		.start	= 0xe800e000,
+		.end	= 0xe800e0ff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= 279,
+		.end	= 281,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device spi3_device = {
+	.name	= "rspi",
+	.id	= 3,
+	.dev	= {
+		.platform_data		= &rspi_pdata,
+	},
+	.num_resources	= ARRAY_SIZE(spi3_resources),
+	.resource	= spi3_resources,
+};
+
+static struct resource spi4_resources[] = {
+	[0] = {
+		.start	= 0xe800e800,
+		.end	= 0xe800e8ff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= 282,
+		.end	= 284,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device spi4_device = {
+	.name	= "rspi",
+	.id	= 4,
+	.dev	= {
+		.platform_data		= &rspi_pdata,
+	},
+	.num_resources	= ARRAY_SIZE(spi4_resources),
+	.resource	= spi4_resources,
+};
+
+/* ADC */
+static struct resource adc0_resources[] = {
+	[0] = {
+		.start	= 0xe8005800,
+		.end	= 0xe80058ff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = { /* mtu2 share regs */
+		.start	= 0xfcff0280,
+		.end	= 0xfcff0285,
+		.flags	= IORESOURCE_MEM,
+	},
+	[2] = { /* mtu2 ch.1 regs */
+		.start	= 0xfcff0380,
+		.end	= 0xfcff03a0,
+		.flags	= IORESOURCE_MEM,
+	},
+	[3] = {
+		.start	= 170,
+		.end	= 171,
+		.flags	= IORESOURCE_IRQ,
+	},
+	[4] = { /* mtu2 */
+		.start	= 146,
+		.end	= 146,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct sh_adc_data adc_data = {
+	.num_channels = 8,
+	.mtu2_ch = 1,
+};
+
+static struct platform_device adc0_device = {
+	.name	= "sh_adc",
+	.id	= 0,
+	.dev	= {
+		.platform_data		= &adc_data,
+		.dma_mask		= NULL,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.num_resources	= ARRAY_SIZE(adc0_resources),
+	.resource	= adc0_resources,
+};
+
+/* spibsc */
+static struct sh_spibsc_info spibsc0_info = {
+	.bus_num	= 5,
+};
+
+static struct resource spibsc0_resources[] = {
+	[0] = {
+		.start	= 0x3fefa000,
+		.end	= 0x3fefa0ff,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device spibsc0_device = {
+	.name		= "spibsc",
+	.id		= 0,
+	.dev.platform_data = &spibsc0_info,
+	.num_resources	= ARRAY_SIZE(spibsc0_resources),
+	.resource	= spibsc0_resources,
+};
+
+static struct sh_spibsc_info spibsc1_info = {
+	.bus_num	= 6,
+};
+
+static struct resource spibsc1_resources[] = {
+	[0] = {
+		.start	= 0x3fefb000,
+		.end	= 0x3fefb0ff,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device spibsc1_device = {
+	.name		= "spibsc",
+	.id		= 1,
+	.dev.platform_data = &spibsc1_info,
+	.num_resources	= ARRAY_SIZE(spibsc1_resources),
+	.resource	= spibsc1_resources,
+};
+
+/* DMA */
+#define CHCFG(reqd_v, loen_v, hien_v, lvl_v, am_v, sds_v, dds_v, tm_v)\
+	{								\
+		.reqd	=	reqd_v,					\
+		.loen	=	loen_v,					\
+		.hien	=	hien_v,					\
+		.lvl	=	lvl_v,					\
+		.am	=	am_v,					\
+		.sds	=	sds_v,					\
+		.dds	=	dds_v,					\
+		.tm	=	tm_v,					\
+	}
+#define DMARS(rid_v, mid_v)	\
+	{								\
+		.rid	= rid_v,					\
+		.mid	= mid_v,					\
+	}
+
+static const struct rza1_dma_slave_config rza1_dma_slaves[] = {
+	{
+		.slave_id	= RZA1DMA_SLAVE_SDHI0_TX,
+		.addr		= 0xe804e030,
+		.chcfg		= CHCFG(0x1, 0x0, 0x1, 0x1, 0x1, 0x2, 0x2, 0x0),
+		.dmars		= DMARS(0x1, 0x30),
+	},
+	{
+		.slave_id	= RZA1DMA_SLAVE_SDHI0_RX,
+		.addr		= 0xe804e030,
+		.chcfg		= CHCFG(0x0, 0x0, 0x1, 0x1, 0x1, 0x2, 0x2, 0x0),
+		.dmars		= DMARS(0x2, 0x30),
+	},
+	{
+		.slave_id	= RZA1DMA_SLAVE_SDHI1_TX,
+		.addr		= 0xe804e830,
+		.chcfg		= CHCFG(0x1, 0x0, 0x1, 0x1, 0x1, 0x2, 0x2, 0x0),
+		.dmars		= DMARS(0x1, 0x31),
+	},
+	{
+		.slave_id	= RZA1DMA_SLAVE_SDHI1_RX,
+		.addr		= 0xe804e830,
+		.chcfg		= CHCFG(0x0, 0x0, 0x1, 0x1, 0x1, 0x2, 0x2, 0x0),
+		.dmars		= DMARS(0x2, 0x31),
+	},
+	{
+		.slave_id	= RZA1DMA_SLAVE_MMCIF_TX,
+		.addr		= 0xe804c834,
+		.chcfg		= CHCFG(0x1, 0x0, 0x1, 0x1, 0x1, 0x2, 0x2, 0x0),
+		.dmars		= DMARS(0x1, 0x32),
+	},
+	{
+		.slave_id	= RZA1DMA_SLAVE_MMCIF_RX,
+		.addr		= 0xe804c834,
+		.chcfg		= CHCFG(0x0, 0x0, 0x1, 0x1, 0x1, 0x2, 0x2, 0x0),
+		.dmars		= DMARS(0x2, 0x32),
+	},
+	{
+		.slave_id	= RZA1DMA_SLAVE_PCM_MEM_SSI0,
+		.addr		= 0xe820b018,		/* SSIFTDR_0 */
+		.chcfg		= CHCFG(0x1, 0x0, 0x1, 0x1, 0x1, 0x2, 0x2, 0x0),
+		.dmars		= DMARS(0x1, 0x38),
+	}, {
+		.slave_id	= RZA1DMA_SLAVE_PCM_MEM_SRC1,
+		.addr		= 0xe820970c,		/* DMATD1_CIM */
+		.chcfg		= CHCFG(0x1, 0x0, 0x1, 0x1, 0x1, 0x1, 0x1, 0x0),
+		.dmars		= DMARS(0x1, 0x41),
+	}, {
+		.slave_id	= RZA1DMA_SLAVE_PCM_SSI0_MEM,
+		.addr		= 0xe820b01c,		/* SSIFRDR_0 */
+		.chcfg		= CHCFG(0x0, 0x0, 0x1, 0x1, 0x1, 0x2, 0x2, 0x0),
+		.dmars		= DMARS(0x2, 0x38),
+	}, {
+		.slave_id	= RZA1DMA_SLAVE_PCM_SRC0_MEM,
+		.addr		= 0xe8209718,		/* DMATU0_CIM */
+		.chcfg		= CHCFG(0x0, 0x0, 0x1, 0x1, 0x1, 0x1, 0x1, 0x0),
+		.dmars		= DMARS(0x2, 0x40),
+	},
+};
+
+static struct rza1_dma_pdata dma_platform_data = {
+	.slave		= rza1_dma_slaves,
+	.slave_num	= ARRAY_SIZE(rza1_dma_slaves),
+	.channel_num	= 16,
+};
+
+static struct resource rza1_dma_resources[] = {
+	{
+		.start	= 0xe8200000,
+		.end	= 0xe8200fff,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.start	= 0xfcfe1000,
+		.end	= 0xfcfe1fff,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.start	= 41,
+		.end	= 56,
+		.flags	= IORESOURCE_IRQ,
+	},
+	{
+		.start	= 57,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device dma_device = {
+	.name		= "rza1-dma",
+	.id		= -1,
+	.resource	= rza1_dma_resources,
+	.num_resources	= ARRAY_SIZE(rza1_dma_resources),
+	.dev		= {
+		.platform_data	= &dma_platform_data,
+	},
+};
+
+/* Audio */
+static struct platform_device alsa_soc_platform_device = {
+	.name		= "genmai_alsa_soc_platform",
+
+	.id		= 0,
+};
+
+static struct resource scux_resources[] = {
+	[0] = {
+		.name   = "scux",
+		.start  = 0xe8208000,	/* SCUX Register Address */
+		.end    = 0xe8209777,
+		.flags  = IORESOURCE_MEM,
+	},
+	[1] = {
+		.name   = "ssif0",
+		.start  = 0xe820b000,	/* SSIF0 Register Address  */
+		.end    = 0xe820d82f,
+		.flags  = IORESOURCE_MEM,
+	},
+};
+
+/* Audio */
+static struct scu_config ssi_ch_value[] = {
+	{RP_MEM_SSI0,		SSI0},
+	{RP_MEM_SRC1_SSI0,	SSI0},
+	{RP_MEM_SRC1_DVC1_SSI0,	SSI0},
+	{RC_SSI0_MEM,		SSI0},
+	{RC_SSI0_SRC0_MEM,	SSI0},
+};
+
+static struct scu_config src_ch_value[] = {
+	{RP_MEM_SSI0,		-1},
+	{RP_MEM_SRC1_SSI0,	SRC1},
+	{RP_MEM_SRC1_DVC1_SSI0,	SRC1},
+	{RC_SSI0_MEM,		-1},
+	{RC_SSI0_SRC0_MEM,	SRC0},
+};
+
+static struct scu_config dvc_ch_value[] = {
+	{RP_MEM_SSI0,		-1},
+	{RP_MEM_SRC1_SSI0,	-1},
+	{RP_MEM_SRC1_DVC1_SSI0,	DVC1},
+	{RC_SSI0_MEM,		-1},
+	{RC_SSI0_SRC0_MEM,	-1},
+};
+
+static struct scu_config audma_slave_value[] = {
+	{RP_MEM_SSI0,		RZA1DMA_SLAVE_PCM_MEM_SSI0},
+	{RP_MEM_SRC1_SSI0,	RZA1DMA_SLAVE_PCM_MEM_SRC1},
+	{RP_MEM_SRC1_DVC1_SSI0,	RZA1DMA_SLAVE_PCM_MEM_SRC1},
+	{RC_SSI0_MEM,		RZA1DMA_SLAVE_PCM_SSI0_MEM},
+	{RC_SSI0_SRC0_MEM,	RZA1DMA_SLAVE_PCM_SRC0_MEM},
+};
+
+static struct scu_config ssi_depend_value[] = {
+	{RP_MEM_SSI0,		SSI_INDEPENDANT},
+	{RP_MEM_SRC1_SSI0,	SSI_DEPENDANT},
+	{RP_MEM_SRC1_DVC1_SSI0,	SSI_DEPENDANT},
+	{RC_SSI0_MEM,		SSI_INDEPENDANT},
+	{RC_SSI0_SRC0_MEM,	SSI_DEPENDANT},
+};
+
+static struct scu_config ssi_mode_value[] = {
+	{RP_MEM_SSI0,		SSI_MASTER},
+	{RP_MEM_SRC1_SSI0,	SSI_MASTER},
+	{RP_MEM_SRC1_DVC1_SSI0,	SSI_MASTER},
+	{RC_SSI0_MEM,		SSI_SLAVE},
+	{RC_SSI0_SRC0_MEM,	SSI_SLAVE},
+};
+
+static struct scu_config src_mode_value[] = {
+	{RP_MEM_SSI0,		SRC_CR_ASYNC},
+	{RP_MEM_SRC1_SSI0,	SRC_CR_ASYNC},
+	{RP_MEM_SRC1_DVC1_SSI0,	SRC_CR_ASYNC},
+	{RC_SSI0_MEM,		SRC_CR_ASYNC},
+	{RC_SSI0_SRC0_MEM,	SRC_CR_ASYNC},
+};
+
+
+static struct scu_platform_data scu_pdata = {
+	.ssi_master		= SSI0,
+	.ssi_slave		= SSI0,
+	.ssi_ch			= ssi_ch_value,
+	.ssi_ch_num		= ARRAY_SIZE(ssi_ch_value),
+	.src_ch			= src_ch_value,
+	.src_ch_num		= ARRAY_SIZE(src_ch_value),
+	.dvc_ch			= dvc_ch_value,
+	.dvc_ch_num		= ARRAY_SIZE(dvc_ch_value),
+	.dma_slave_maxnum	= RZA1DMA_SLAVE_PCM_MAX,
+	.audma_slave		= audma_slave_value,
+	.audma_slave_num	= ARRAY_SIZE(audma_slave_value),
+	.ssi_depend		= ssi_depend_value,
+	.ssi_depend_num		= ARRAY_SIZE(ssi_depend_value),
+	.ssi_mode		= ssi_mode_value,
+	.ssi_mode_num		= ARRAY_SIZE(ssi_mode_value),
+	.src_mode		= src_mode_value,
+	.src_mode_num		= ARRAY_SIZE(src_mode_value),
+};
+
+static struct platform_device scux_device = {
+	.name		= "scux-pcm-audio",
+	.id		= 0,
+	.dev.platform_data = &scu_pdata,
+	.num_resources	= ARRAY_SIZE(scux_resources),
+	.resource	= scux_resources,
+};
+
+static struct platform_device *rza1_devices[] __initdata = {
+	&i2c_device0,
+	&i2c_device1,
+	&i2c_device2,
+	&i2c_device3,
+	&r8a66597_usb_host0_device,
+	&r8a66597_usb_host1_device,
+	&sh_eth_device,
+	&spi0_device,
+	&spi1_device,
+	&spi2_device,
+	&spi3_device,
+	&spi4_device,
+	&adc0_device,
+	&spibsc0_device,
+	&spibsc1_device,
+};
+
+static struct platform_device *rza1_early_devices[] __initdata = {
+	&dma_device,
+	&scif0_device,
+	&scif1_device,
+	&scif2_device,
+	&scif3_device,
+	&scif4_device,
+	&scif5_device,
+	&scif6_device,
+	&scif7_device,
+	&mtu2_0_device,
+	&rtc_device,
+	&alsa_soc_platform_device,
+	&scux_device,
+};
+
+void __init rza1_devices_setup(void)
+{
+	if (disable_ether)
+		sh_eth_device.name = "sh-eth(hidden)";
+
+	platform_add_devices(rza1_early_devices,
+			    ARRAY_SIZE(rza1_early_devices));
+	platform_add_devices(rza1_devices,
+			    ARRAY_SIZE(rza1_devices));
+}
+
+static void __init rza1_earlytimer_init(void)
+{
+	rza1_clock_init();
+	shmobile_earlytimer_init();
+}
+
+void __init rza1_add_early_devices(void)
+{
+	early_platform_add_devices(rza1_early_devices,
+				   ARRAY_SIZE(rza1_early_devices));
+
+	/* setup early console here as well */
+	shmobile_setup_console();
+
+	/* override timer setup with soc-specific code */
+	shmobile_timer.init = rza1_earlytimer_init;
+}
diff --git a/arch/arm/tools/mach-types b/arch/arm/tools/mach-types
index 831e1fd..51025d5 100644
--- a/arch/arm/tools/mach-types
+++ b/arch/arm/tools/mach-types
@@ -1204,3 +1204,4 @@ baileys			MACH_BAILEYS		BAILEYS			4169
 familybox		MACH_FAMILYBOX		FAMILYBOX		4170
 ensemble_mx35		MACH_ENSEMBLE_MX35	ENSEMBLE_MX35		4171
 sc_sps_1		MACH_SC_SPS_1		SC_SPS_1		4172
+rskrza1			MACH_RSKRZA1		RSKRZA1			4533
diff --git a/drivers/dma/Kconfig b/drivers/dma/Kconfig
index d4c1218..79f6745 100644
--- a/drivers/dma/Kconfig
+++ b/drivers/dma/Kconfig
@@ -182,6 +182,14 @@ config SH_DMAE
 	help
 	  Enable support for the Renesas SuperH DMA controllers.
 
+config RZA1_DMAE
+	tristate "Renesas RZA1 DMAC support"
+	depends on (ARM && ARCH_SHMOBILE && ARCH_RZA1)
+	depends on !SH_DMA_API
+	select DMA_ENGINE
+	help
+	  Enable support for the Renesas RZA1 DMA controllers.
+
 config COH901318
 	bool "ST-Ericsson COH901318 DMA support"
 	select DMA_ENGINE
diff --git a/drivers/dma/Makefile b/drivers/dma/Makefile
index 7428fea..698c983 100644
--- a/drivers/dma/Makefile
+++ b/drivers/dma/Makefile
@@ -16,6 +16,7 @@ obj-$(CONFIG_AT_HDMAC) += at_hdmac.o
 obj-$(CONFIG_MX3_IPU) += ipu/
 obj-$(CONFIG_TXX9_DMAC) += txx9dmac.o
 obj-$(CONFIG_SH_DMAE) += sh/
+obj-$(CONFIG_RZA1_DMAE) += rza1dma.o
 obj-$(CONFIG_COH901318) += coh901318.o coh901318_lli.o
 obj-$(CONFIG_AMCC_PPC440SPE_ADMA) += ppc4xx/
 obj-$(CONFIG_IMX_SDMA) += imx-sdma.o
diff --git a/drivers/dma/rza1dma.c b/drivers/dma/rza1dma.c
new file mode 100644
index 0000000..3d32ac3
--- /dev/null
+++ b/drivers/dma/rza1dma.c
@@ -0,0 +1,996 @@
+/*
+ * Renesas RZA1 DMA Engine support
+ *
+ * base is drivers/dma/imx-dma.c
+ *
+ * Copyright (C) 2009-2013 Renesas Solutions Corp.
+ * Copyright 2012 Javier Martin, Vista Silicon <javier.martin@vista-silicon.com>
+ * Copyright (C) 2011-2012 Guennadi Liakhovetski <g.liakhovetski@gmx.de>
+ * Copyright 2010 Sascha Hauer, Pengutronix <s.hauer@pengutronix.de>
+ * Copyright (C) 2009 Nobuhiro Iwamatsu <iwamatsu.nobuhiro@renesas.com>
+ * Copyright (C) 2007 Freescale Semiconductor, Inc. All rights reserved.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/dmaengine.h>
+#include <linux/module.h>
+
+#include <asm/irq.h>
+#include <linux/platform_data/dma-rza1.h>
+
+#include "dmaengine.h"
+#define RZA1DMA_MAX_CHAN_DESCRIPTORS	16
+
+/* set the offset of regs */
+#define	CHSTAT	0x0024
+#define CHCTRL	0x0028
+#define	CHCFG	0x002c
+#define	CHITVL	0x0030
+#define	CHEXT	0x0034
+#define NXLA	0x0038
+#define	CRLA	0x003c
+
+#define	DCTRL		0x0000
+#define	DSTAT_EN	0x0010
+#define	DSTAT_ER	0x0014
+#define	DSTAT_END	0x0018
+#define	DSTAT_TC	0x001c
+#define	DSTAT_SUS	0x0020
+
+#define	EACH_CHANNEL_OFFSET		0x0040
+#define	CHANNEL_0_7_OFFSET		0x0000
+#define	CHANNEL_0_7_COMMON_BASE		0x0300
+#define CHANNEL_8_15_OFFSET		0x0400
+#define	CHANNEL_8_15_COMMON_BASE	0x0700
+
+/* set bit filds */
+/* CHSTAT */
+#define	CHSTAT_TC	(0x1 << 6)
+#define CHSTAT_END	(0x1 << 5)
+#define CHSTAT_ER	(0x1 << 4)
+
+/* CHCTRL */
+#define CHCTRL_CLRINTMSK	(0x1 << 17)
+#define	CHCTRL_SETINTMSK	(0x1 << 16)
+#define	CHCTRL_CLRSUS		(0x1 << 9)
+#define	CHCTRL_SETSUS		(0x1 << 8)
+#define CHCTRL_CLRTC		(0x1 << 6)
+#define	CHCTRL_CLREND		(0x1 << 5)
+#define	CHCTRL_CLRRQ		(0x1 << 4)
+#define	CHCTRL_SWRST		(0x1 << 3)
+#define	CHCTRL_STG		(0x1 << 2)
+#define	CHCTRL_CLREN		(0x1 << 1)
+#define	CHCTRL_SETEN		(0x1 << 0)
+#define	CHCTRL_DEFAULT	(CHCTRL_CLRINTMSK | \
+			CHCTRL_CLRSUS | \
+			CHCTRL_CLRTC | \
+			CHCTRL_CLREND | \
+			CHCTRL_CLRRQ | \
+			CHCTRL_SWRST | \
+			CHCTRL_CLREN)
+
+/* CHCFG */
+#define	CHCFG_DMS		(0x1 << 31)
+#define	CHCFG_DEM		(0x1 << 24)
+#define	CHCFG_TM(bit)		(bit << 22)
+#define	CHCFG_DAD		(0x1 << 21)
+#define	CHCFG_SAD		(0x1 << 20)
+#define	CHCFG_8BIT	(0x00)
+#define	CHCFG_16BIT	(0x01)
+#define	CHCFG_32BIT	(0x02)
+#define	CHCFG_64BIT	(0x03)
+#define CHCFG_128BIT	(0x04)
+#define	CHCFG_256BIT	(0x05)
+#define	CHCFG_512BIT	(0x06)
+#define	CHCFG_1024BIT	(0x07)
+#define	CHCFG_DDS(bit)		(bit << 16)
+#define	CHCFG_SDS(bit)		(bit << 12)
+#define	CHCFG_AM(bits)		(bits << 8)
+#define	CHCFG_LVL(bit)		(bit << 6)
+#define	CHCFG_HIEN(bit)		(bit << 5)
+#define	CHCFG_LOEN(bit)		(bit << 4)
+#define	CHCFG_REQD(bit)		(bit << 3)
+#define	CHCFG_SEL(bits)		((bits & 0x07) << 0)
+
+/* DCTRL */
+#define	DCTRL_LVINT		(0x1 << 1)
+#define	DCTRL_PR		(0x1 << 0)
+#define DCTRL_DEFAULT		(DCTRL_LVINT | DCTRL_PR)
+
+/* DMARS */
+#define	DMARS_RID(bit)		(bit << 0)
+#define	DMARS_MID(bit)		(bit << 2)
+
+/* LINK MODE DESCRIPTOR */
+#define	HEADER_DIM	(0x1 << 3)
+#define	HEADER_WBD	(0x1 << 2)
+#define	HEADER_LE	(0x1 << 1)
+#define	HEADER_LV	(0x1 << 0)
+
+#define to_rza1dma_chan(c) container_of(c, struct rza1dma_channel, chan)
+
+enum  rza1dma_prep_type {
+	RZA1DMA_DESC_MEMCPY,
+	RZA1DMA_DESC_SLAVE_SG,
+};
+
+struct format_desc {
+	u32	header;
+	u32	src_addr;
+	u32	dst_addr;
+	u32	trs_byte;
+	u32	config;
+	u32	interval;
+	u32	extension;
+	u32	next_lk_addr;
+};
+
+#define	FORMAT_DESC_NUM	64
+
+struct rza1dma_desc {
+	struct list_head		node;
+	struct dma_async_tx_descriptor	desc;
+	enum dma_status			status;
+	dma_addr_t			src;
+	dma_addr_t			dest;
+	size_t				len;
+	enum dma_transfer_direction	direction;
+	enum rza1dma_prep_type		type;
+	/* For memcpy */
+	unsigned int			config_port;
+	unsigned int			config_mem;
+	/* For slave sg */
+	struct scatterlist		*sg;
+	unsigned int			sgcount;
+};
+
+struct rza1dma_channel {
+	struct rza1dma_engine		*rza1dma;
+	unsigned int			channel;
+
+	struct tasklet_struct		dma_tasklet;
+	struct list_head		ld_free;
+	struct list_head		ld_queue;
+	struct list_head		ld_active;
+	int				descs_allocated;
+	enum dma_slave_buswidth		word_size;
+	dma_addr_t			per_address;
+	struct dma_chan			chan;
+	struct dma_async_tx_descriptor	desc;
+	enum dma_status			status;
+
+	const struct rza1_dma_slave_config	*slave;
+	void __iomem			*ch_base;
+	void __iomem			*ch_cmn_base;
+	struct format_desc		*desc_base;
+	dma_addr_t			desc_base_dma;
+
+	u32	chcfg;
+	u32	chctrl;
+};
+
+struct rza1dma_engine {
+	struct device			*dev;
+	struct device_dma_parameters	dma_parms;
+	struct dma_device		dma_device;
+	void __iomem			*base;
+	void __iomem			*ext_base;
+	spinlock_t			lock;
+	struct rza1dma_channel		*channel;
+	struct rza1_dma_pdata		*pdata;
+};
+
+static void rza1dma_writel(struct rza1dma_engine *rza1dma, unsigned val,
+				unsigned offset)
+{
+	__raw_writel(val, rza1dma->base + offset);
+}
+
+static void rza1dma_ext_writel(struct rza1dma_engine *rza1dma, unsigned val,
+				unsigned offset)
+{
+	__raw_writel(val, rza1dma->ext_base + offset);
+}
+
+static u32 rza1dma_ext_readl(struct rza1dma_engine *rza1dma, unsigned offset)
+{
+	return __raw_readl(rza1dma->ext_base + offset);
+}
+
+static void rza1dma_ch_writel(struct rza1dma_channel *rza1dmac, unsigned val,
+				unsigned offset, int which)
+{
+	if (which)
+		__raw_writel(val, rza1dmac->ch_base + offset);
+	else
+		__raw_writel(val, rza1dmac->ch_cmn_base + offset);
+}
+
+static u32 rza1dma_ch_readl(struct rza1dma_channel *rza1dmac, unsigned offset,
+				int which)
+{
+	if (which)
+		return __raw_readl(rza1dmac->ch_base + offset);
+	else
+		return __raw_readl(rza1dmac->ch_cmn_base + offset);
+}
+
+static void rza1dma_enable_hw(struct rza1dma_desc *d)
+{
+	struct dma_chan *chan = d->desc.chan;
+	struct rza1dma_channel *rza1dmac = to_rza1dma_chan(chan);
+	struct rza1dma_engine *rza1dma = rza1dmac->rza1dma;
+	int channel = rza1dmac->channel;
+	unsigned long flags;
+	u32 nxla = rza1dmac->desc_base_dma;
+	u32 chcfg = rza1dmac->chcfg;
+	u32 chctrl = rza1dmac->chctrl;
+
+	dev_dbg(rza1dma->dev, "%s channel %d\n", __func__, channel);
+
+	local_irq_save(flags);
+
+
+	if(chctrl & CHCTRL_SETEN){			/* When [SETEN]is "0".already before process add Descriptor */
+								/* Only add Descriptor case.skip write register */
+		rza1dma_ch_writel(rza1dmac, nxla, NXLA, 1);		/* NXLA reg */
+		rza1dma_ch_writel(rza1dmac, chcfg, CHCFG, 1);		/* CHCFG reg */
+
+		rza1dma_ch_writel(rza1dmac, CHCTRL_SWRST, CHCTRL, 1);	/* CHCTRL reg */
+		rza1dma_ch_writel(rza1dmac, chctrl, CHCTRL, 1);		/* CHCTRL reg */
+	}
+
+	local_irq_restore(flags);
+}
+
+static void rza1dma_disable_hw(struct rza1dma_channel *rza1dmac)
+{
+	struct rza1dma_engine *rza1dma = rza1dmac->rza1dma;
+	int channel = rza1dmac->channel;
+	unsigned long flags;
+
+	dev_dbg(rza1dma->dev, "%s channel %d\n", __func__, channel);
+
+	local_irq_save(flags);
+	rza1dma_ch_writel(rza1dmac, CHCTRL_DEFAULT, CHCTRL, 1); /* CHCTRL reg */
+	local_irq_restore(flags);
+}
+
+static void dma_irq_handle_channel(struct rza1dma_channel *rza1dmac)
+{
+	u32 chstat, chctrl;
+	struct rza1dma_engine *rza1dma = rza1dmac->rza1dma;
+	int channel = rza1dmac->channel;
+
+	chstat = rza1dma_ch_readl(rza1dmac, CHSTAT, 1);
+	if (chstat & CHSTAT_ER) {
+		dev_err(rza1dma->dev, "RZA1 DMAC error ocurred\n");
+		dev_err(rza1dma->dev, "CHSTAT_%d = %08X\n", channel, chstat);
+		rza1dma_ch_writel(rza1dmac,
+				CHCTRL_DEFAULT,
+				CHCTRL, 1);
+		goto schedule;
+	}
+	if (!(chstat & CHSTAT_END))
+		return;
+
+	chctrl = rza1dma_ch_readl(rza1dmac, CHCTRL, 1);
+	rza1dma_ch_writel(rza1dmac,
+			chctrl | CHCTRL_CLREND | CHCTRL_CLRRQ,
+			CHCTRL, 1);
+schedule:
+	/* Tasklet irq */
+	tasklet_schedule(&rza1dmac->dma_tasklet);
+}
+
+static irqreturn_t rza1dma_irq_handler(int irq, void *dev_id)
+{
+	struct rza1dma_engine *rza1dma = dev_id;
+	struct rza1_dma_pdata *pdata = rza1dma->pdata;
+	int i, channel_num = pdata->channel_num;
+
+	dev_dbg(rza1dma->dev, "%s called\n", __func__);
+
+	for (i = 0; i < channel_num; i++)
+		dma_irq_handle_channel(&rza1dma->channel[i]);
+
+	return IRQ_HANDLED;
+}
+
+static void set_dmars_register(struct rza1dma_engine *rza1dma,
+				int channel, u32 dmars)
+{
+	u32 dmars_offset = (channel / 2) * 4;
+	u32 dmars32;
+
+	dmars32 = rza1dma_ext_readl(rza1dma, dmars_offset);
+	if (channel % 2) {
+		dmars32 &= 0x0000ffff;
+		dmars32 |= dmars << 16;
+	} else {
+		dmars32 &= 0xffff0000;
+		dmars32 |= dmars;
+	}
+	rza1dma_ext_writel(rza1dma, dmars32, dmars_offset);
+	dmars32 = rza1dma_ext_readl(rza1dma, dmars_offset);
+}
+
+static void prepare_desc_for_memcpy(struct rza1dma_desc *d)
+{
+	struct dma_chan *chan = d->desc.chan;
+	struct rza1dma_channel *rza1dmac = to_rza1dma_chan(chan);
+	struct rza1dma_engine *rza1dma = rza1dmac->rza1dma;
+	struct format_desc *descs = rza1dmac->desc_base;
+	int channel = rza1dmac->channel;
+	u32 chcfg = 0x80400008;
+	u32 dmars = 0;
+
+	dev_dbg(rza1dma->dev, "%s called\n", __func__);
+
+	/* prepare descriptor */
+	descs[0].src_addr = d->src;
+	descs[0].dst_addr = d->dest;
+	descs[0].trs_byte = d->len;
+	descs[0].config = chcfg;
+	descs[0].interval = 0;
+	descs[0].extension = 0;
+	descs[0].header = HEADER_LV | HEADER_LE;
+	descs[0].next_lk_addr = 0;
+
+	/* and set DMARS register */
+	set_dmars_register(rza1dma, channel, dmars);
+
+	rza1dmac->chcfg = chcfg;
+	rza1dmac->chctrl = CHCTRL_STG | CHCTRL_SETEN;
+}
+
+static void prepare_descs_for_slave_sg(struct rza1dma_desc *d)
+{
+	struct dma_chan *chan = d->desc.chan;
+	struct rza1dma_channel *rza1dmac = to_rza1dma_chan(chan);
+	struct rza1dma_engine *rza1dma = rza1dmac->rza1dma;
+	struct format_desc *descs = rza1dmac->desc_base;
+	const struct rza1_dma_slave_config *slave = rza1dmac->slave;
+	const struct chcfg_reg *chcfg_p = &slave->chcfg;
+	const struct dmars_reg *dmars_p = &slave->dmars;
+	int channel = rza1dmac->channel;
+	struct scatterlist *sg, *sgl = d->sg;
+	unsigned int i, sg_len = d->sgcount;
+	u32 chcfg;
+	u32 dmars;
+
+	unsigned long flags;
+	
+	int seten_flag = 1, desc_add_flag = 0;
+
+	dev_dbg(rza1dma->dev, "%s called\n", __func__);
+
+	chcfg = (CHCFG_SEL(channel) |
+		CHCFG_REQD(chcfg_p->reqd) |
+		CHCFG_LOEN(chcfg_p->loen) |
+		CHCFG_HIEN(chcfg_p->hien) |
+		CHCFG_LVL(chcfg_p->lvl) |
+		CHCFG_AM(chcfg_p->am) |
+		CHCFG_SDS(chcfg_p->sds) |
+		CHCFG_DDS(chcfg_p->dds) |
+		CHCFG_TM(chcfg_p->tm) |
+		CHCFG_DEM |
+		CHCFG_DMS);
+
+	if (d->direction == DMA_DEV_TO_MEM)
+		chcfg |= CHCFG_SAD;	/* source address is fixed */
+	else
+		chcfg |= CHCFG_DAD;	/* distation address is fixed */
+
+	rza1dmac->per_address = slave->addr;	/* slave device address */
+
+	spin_lock_irqsave(&rza1dma->lock, flags);
+
+	if(sg_len == 1){	/*[sg_len = 1]other than normal process( come value "1" from Audio Driver) */
+		for (i = 0; i < FORMAT_DESC_NUM; i++, sg_len++) {
+			/* Descripter[0]-[1]is use only at first time.Back to 2 If you go up to 63 */
+			if(descs[i].header & HEADER_LE){	/* Link End? */
+				if(descs[i].header & HEADER_LV){
+					if(i >= 2){
+						if(i <= 3){
+							if(descs[(FORMAT_DESC_NUM - 4) + i].header & HEADER_LV){
+								desc_add_flag = 1;
+							}else{
+								if(descs[i - 2].header & HEADER_LV){
+									desc_add_flag = 1;
+								}
+							}
+						}else{
+							if(descs[i - 2].header & HEADER_LV){
+								desc_add_flag = 1;
+							}
+						}
+					}else{
+						desc_add_flag = 1;
+					}
+
+					if(desc_add_flag == 0){
+						dev_err(rza1dma->dev, "RZA1 DMAC Link End Now descs !!\n");
+						i = 0;
+						sg_len = 1;
+					}else{
+						descs[i].header &= ~HEADER_LE;	/* Link End Clear */
+						if(i >= FORMAT_DESC_NUM - 1){	/* if Descripter is over [63] */
+							descs[i].next_lk_addr = rza1dmac->desc_base_dma +
+										sizeof(struct format_desc) * 2;
+							i = 2;
+							sg_len = 3;
+							seten_flag = 0;
+						}else{
+							descs[i].next_lk_addr = rza1dmac->desc_base_dma +
+										sizeof(struct format_desc) * (i + 1);
+							if(i > 1){
+								seten_flag = 0;
+							}
+							i++;
+							sg_len++;
+						}
+					}
+				}else{
+					i = 0;
+					sg_len = 1;
+				}
+				break;
+			}
+		}
+
+		if(descs[i].header & HEADER_LV){
+			dev_err(rza1dma->dev, "RZA1 DMAC descs over flow!!\n");
+		}
+
+		if(i == FORMAT_DESC_NUM){
+			i = 0;
+			sg_len = 1;
+		}
+	}else{
+		i = 0;
+	}
+
+	/* Prepare descriptors */
+	for (sg = sgl; i < sg_len; i++, sg = sg_next(sg)) {
+		if (d->direction == DMA_DEV_TO_MEM) {
+			descs[i].src_addr = rza1dmac->per_address;
+			descs[i].dst_addr = sg_dma_address(sg);
+		} else {
+			descs[i].src_addr = sg_dma_address(sg);
+			descs[i].dst_addr = rza1dmac->per_address;
+		}
+
+		descs[i].trs_byte = sg_dma_len(sg);
+		descs[i].config = chcfg;
+		descs[i].interval = 0x00ff;
+		descs[i].extension = 0;
+		descs[i].next_lk_addr = rza1dmac->desc_base_dma +
+					sizeof(struct format_desc) * (i + 1);
+		descs[i].header = HEADER_LV;
+	}
+	descs[sg_len - 1].header |= HEADER_LE;
+	descs[sg_len - 1].config &= ~CHCFG_DEM;
+	descs[sg_len - 1].next_lk_addr = 0;
+
+	/* and set DMARS register */
+	dmars = DMARS_RID(dmars_p->rid) | DMARS_MID(dmars_p->mid);
+	set_dmars_register(rza1dma, channel, dmars);
+
+	rza1dmac->chcfg = descs[sg_len - 1].config;
+	if(seten_flag == 1){
+		rza1dmac->chctrl = CHCTRL_SETEN;
+	}else{
+		rza1dmac->chctrl = 0;
+	}
+
+	spin_unlock_irqrestore(&rza1dma->lock, flags);
+
+}
+
+static int rza1dma_xfer_desc(struct rza1dma_desc *d)
+{
+	/* Configure and enable */
+	switch (d->type) {
+	case RZA1DMA_DESC_MEMCPY:
+		prepare_desc_for_memcpy(d);
+		break;
+
+	case RZA1DMA_DESC_SLAVE_SG:
+		prepare_descs_for_slave_sg(d);
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	rza1dma_enable_hw(d);
+	return 0;
+}
+
+static void rza1dma_tasklet(unsigned long data)
+{
+	struct rza1dma_channel *rza1dmac = (void *)data;
+	struct rza1dma_engine *rza1dma = rza1dmac->rza1dma;
+	struct rza1dma_desc *desc;
+	unsigned long flags;
+
+	dev_dbg(rza1dma->dev, "%s called\n", __func__);
+
+	/* Protection of critical section */
+	spin_lock_irqsave(&rza1dma->lock, flags);
+
+	if (list_empty(&rza1dmac->ld_active)) {
+		/* Someone might have called terminate all */
+		goto out;
+	}
+
+	desc = list_first_entry(&rza1dmac->ld_active, struct rza1dma_desc, node);
+
+	if (desc->desc.callback)
+		desc->desc.callback(desc->desc.callback_param);
+
+	dma_cookie_complete(&desc->desc);
+
+
+	if (list_empty(&rza1dmac->ld_active)) {
+		goto out;
+	}else{
+		list_move_tail(rza1dmac->ld_active.next, &rza1dmac->ld_free);
+	}
+
+	if (!list_empty(&rza1dmac->ld_queue)) {
+		desc = list_first_entry(&rza1dmac->ld_queue, struct rza1dma_desc,
+					node);
+		if (rza1dma_xfer_desc(desc) < 0){
+			dev_warn(rza1dma->dev, "%s: channel: %d couldn't xfer desc\n",
+				 __func__, rza1dmac->channel);
+		}else{
+			list_move_tail(rza1dmac->ld_queue.next, &rza1dmac->ld_active);
+		}
+	}
+out:
+	spin_unlock_irqrestore(&rza1dma->lock, flags);
+}
+
+static int rza1dma_control(struct dma_chan *chan, enum dma_ctrl_cmd cmd,
+			unsigned long arg)
+{
+	struct rza1dma_channel *rza1dmac = to_rza1dma_chan(chan);
+	struct dma_slave_config *dmaengine_cfg = (void *)arg;
+	struct rza1dma_engine *rza1dma = rza1dmac->rza1dma;
+	unsigned long flags;
+
+	switch (cmd) {
+	case DMA_TERMINATE_ALL:
+		rza1dma_disable_hw(rza1dmac);
+
+		spin_lock_irqsave(&rza1dma->lock, flags);
+		list_splice_tail_init(&rza1dmac->ld_active, &rza1dmac->ld_free);
+		list_splice_tail_init(&rza1dmac->ld_queue, &rza1dmac->ld_free);
+		spin_unlock_irqrestore(&rza1dma->lock, flags);
+		return 0;
+	case DMA_SLAVE_CONFIG:
+		if (dmaengine_cfg->direction == DMA_DEV_TO_MEM) {
+			rza1dmac->per_address = dmaengine_cfg->src_addr;
+			rza1dmac->word_size = dmaengine_cfg->src_addr_width;
+		} else {
+			rza1dmac->per_address = dmaengine_cfg->dst_addr;
+			rza1dmac->word_size = dmaengine_cfg->dst_addr_width;
+		}
+		return 0;
+	default:
+		return -ENOSYS;
+	}
+
+	return -EINVAL;
+}
+
+static const struct rza1_dma_slave_config *dma_find_slave(
+		const struct rza1_dma_slave_config *slave,
+		int slave_num,
+		int slave_id)
+{
+	int i;
+
+	for (i = 0; i < slave_num; i++) {
+		const struct rza1_dma_slave_config *t = &slave[i];
+
+		if (slave_id == t->slave_id)
+			return t;
+	}
+
+	return NULL;
+}
+
+bool rza1dma_chan_filter(struct dma_chan *chan, void *arg)
+{
+	struct rza1dma_channel *rza1dmac = to_rza1dma_chan(chan);
+	struct rza1dma_engine *rza1dma = rza1dmac->rza1dma;
+	struct rza1_dma_pdata *pdata = rza1dma->pdata;
+	const struct rza1_dma_slave_config *slave = pdata->slave;
+	const struct rza1_dma_slave_config *hit;
+	int slave_num = pdata->slave_num;
+	int slave_id = (int)arg;
+
+	hit = dma_find_slave(slave, slave_num, slave_id);
+	if (hit) {
+		rza1dmac->slave = hit;
+		return true;
+	}
+	return false;
+}
+EXPORT_SYMBOL(rza1dma_chan_filter);
+
+static enum dma_status rza1dma_tx_status(struct dma_chan *chan,
+					dma_cookie_t cookie,
+					struct dma_tx_state *txstate)
+{
+	return dma_cookie_status(chan, cookie, txstate);
+}
+
+static dma_cookie_t rza1dma_tx_submit(struct dma_async_tx_descriptor *tx)
+{
+	struct dma_chan *chan = tx->chan;
+	struct rza1dma_channel *rza1dmac = to_rza1dma_chan(chan);
+	struct rza1dma_engine *rza1dma = rza1dmac->rza1dma;
+	dma_cookie_t cookie;
+	unsigned long flags;
+
+	spin_lock_irqsave(&rza1dma->lock, flags);
+	list_move_tail(rza1dmac->ld_free.next, &rza1dmac->ld_queue);
+	cookie = dma_cookie_assign(tx);
+	spin_unlock_irqrestore(&rza1dma->lock, flags);
+
+	return cookie;
+}
+
+static int rza1dma_alloc_chan_resources(struct dma_chan *chan)
+{
+	struct rza1dma_channel *rza1dmac = to_rza1dma_chan(chan);
+	struct rza1dma_engine *rza1dma = rza1dmac->rza1dma;
+	struct rza1_dma_pdata *pdata = rza1dma->pdata;
+	const struct rza1_dma_slave_config *slave = pdata->slave;
+	const struct rza1_dma_slave_config *hit;
+	int slave_num = pdata->slave_num;
+	int *slave_id = chan->private;
+
+	if (slave_id) {
+		hit = dma_find_slave(slave, slave_num, *slave_id);
+		if (!hit)
+			return -ENODEV;
+		rza1dmac->slave = hit;
+	}
+
+	while (rza1dmac->descs_allocated < RZA1DMA_MAX_CHAN_DESCRIPTORS) {
+		struct rza1dma_desc *desc;
+
+		desc = kzalloc(sizeof(*desc), GFP_KERNEL);
+		if (!desc)
+			break;
+		__memzero(&desc->desc, sizeof(struct dma_async_tx_descriptor));
+		dma_async_tx_descriptor_init(&desc->desc, chan);
+		desc->desc.tx_submit = rza1dma_tx_submit;
+		/* txd.flags will be overwritten in prep funcs */
+		desc->desc.flags = DMA_CTRL_ACK;
+		desc->status = DMA_SUCCESS;
+
+		list_add_tail(&desc->node, &rza1dmac->ld_free);
+		rza1dmac->descs_allocated++;
+	}
+	if (!rza1dmac->descs_allocated)
+		return -ENOMEM;
+
+	return rza1dmac->descs_allocated;
+}
+
+static void rza1dma_free_chan_resources(struct dma_chan *chan)
+{
+	struct rza1dma_channel *rza1dmac = to_rza1dma_chan(chan);
+	struct rza1dma_engine *rza1dma = rza1dmac->rza1dma;
+	struct format_desc *descs = rza1dmac->desc_base;
+	struct rza1dma_desc *desc, *_desc;
+	unsigned long flags;
+	unsigned int i;
+
+	spin_lock_irqsave(&rza1dma->lock, flags);
+
+	for (i = 0; i < FORMAT_DESC_NUM; i++) {
+		descs[i].header = 0;
+	}
+
+	rza1dma_disable_hw(rza1dmac);
+	list_splice_tail_init(&rza1dmac->ld_active, &rza1dmac->ld_free);
+	list_splice_tail_init(&rza1dmac->ld_queue, &rza1dmac->ld_free);
+
+	spin_unlock_irqrestore(&rza1dma->lock, flags);
+
+	list_for_each_entry_safe(desc, _desc, &rza1dmac->ld_free, node) {
+		kfree(desc);
+		rza1dmac->descs_allocated--;
+	}
+	INIT_LIST_HEAD(&rza1dmac->ld_free);
+}
+
+static struct dma_async_tx_descriptor *rza1dma_prep_slave_sg(
+		struct dma_chan *chan, struct scatterlist *sgl,
+		unsigned int sg_len, enum dma_transfer_direction direction,
+		unsigned long flags, void *context)
+{
+	struct rza1dma_channel *rza1dmac = to_rza1dma_chan(chan);
+	struct scatterlist *sg;
+	int i, dma_length = 0;
+	struct rza1dma_desc *desc;
+
+	if (list_empty(&rza1dmac->ld_free))
+		return NULL;
+
+	desc = list_first_entry(&rza1dmac->ld_free, struct rza1dma_desc, node);
+
+	for_each_sg(sgl, sg, sg_len, i) {
+		dma_length += sg_dma_len(sg);
+	}
+
+	desc->type = RZA1DMA_DESC_SLAVE_SG;
+	desc->sg = sgl;
+	desc->sgcount = sg_len;
+	desc->len = dma_length;
+	desc->direction = direction;
+
+	if (direction == DMA_DEV_TO_MEM)
+		desc->src = rza1dmac->per_address;
+	else
+		desc->dest = rza1dmac->per_address;
+
+	desc->desc.callback = NULL;
+	desc->desc.callback_param = NULL;
+
+	return &desc->desc;
+}
+
+static struct dma_async_tx_descriptor *rza1dma_prep_dma_memcpy(
+	struct dma_chan *chan, dma_addr_t dest,
+	dma_addr_t src, size_t len, unsigned long flags)
+{
+	struct rza1dma_channel *rza1dmac = to_rza1dma_chan(chan);
+	struct rza1dma_engine *rza1dma = rza1dmac->rza1dma;
+	struct rza1dma_desc *desc;
+
+	dev_dbg(rza1dma->dev, "%s channel: %d src=0x%x dst=0x%x len=%d\n",
+			__func__, rza1dmac->channel, src, dest, len);
+
+	if (list_empty(&rza1dmac->ld_free))
+		return NULL;
+
+	desc = list_first_entry(&rza1dmac->ld_free, struct rza1dma_desc, node);
+
+	desc->type = RZA1DMA_DESC_MEMCPY;
+	desc->src = src;
+	desc->dest = dest;
+	desc->len = len;
+	desc->direction = DMA_MEM_TO_MEM;
+	desc->desc.callback = NULL;
+	desc->desc.callback_param = NULL;
+
+	return &desc->desc;
+}
+
+static void rza1dma_issue_pending(struct dma_chan *chan)
+{
+	struct rza1dma_channel *rza1dmac = to_rza1dma_chan(chan);
+	struct rza1dma_engine *rza1dma = rza1dmac->rza1dma;
+	struct rza1dma_desc *desc;
+	unsigned long flags;
+
+	spin_lock_irqsave(&rza1dma->lock, flags);
+
+	/* queue is piled up on the next active even during execution DMA forwarding */
+	if (!list_empty(&rza1dmac->ld_queue)) {
+		desc = list_first_entry(&rza1dmac->ld_queue,
+					struct rza1dma_desc, node);
+
+		if (rza1dma_xfer_desc(desc) < 0) {
+			dev_warn(rza1dma->dev,
+				 "%s: channel: %d couldn't issue DMA xfer\n",
+				 __func__, rza1dmac->channel);
+		} else {
+			list_move_tail(rza1dmac->ld_queue.next,
+				       &rza1dmac->ld_active);
+		}
+	}
+	spin_unlock_irqrestore(&rza1dma->lock, flags);
+}
+
+static int __init rza1dma_probe(struct platform_device *pdev)
+{
+	struct rza1_dma_pdata *pdata = pdev->dev.platform_data;
+	int channel_num = pdata->channel_num;
+	struct rza1dma_engine *rza1dma;
+	struct resource *base_res, *ext_res, *cirq_res, *eirq_res;
+	int ret, i;
+	int irq, irq_err;
+
+	rza1dma = devm_kzalloc(&pdev->dev, sizeof(*rza1dma), GFP_KERNEL);
+	if (!rza1dma)
+		return -ENOMEM;
+
+	/* Get io base address */
+	base_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!base_res)
+		return -ENODEV;
+	rza1dma->base = devm_request_and_ioremap(&pdev->dev, base_res);
+	if (!rza1dma->base)
+		return -EADDRNOTAVAIL;
+
+	/* Get extension io base address */
+	ext_res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (!ext_res)
+		return -ENODEV;
+	rza1dma->ext_base = devm_request_and_ioremap(&pdev->dev, ext_res);
+	if (!rza1dma->ext_base)
+		return -EADDRNOTAVAIL;
+
+	/* Register interrupt handler for channels */
+	cirq_res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!cirq_res)
+		return -ENODEV;
+
+	for (irq = cirq_res->start; irq <= cirq_res->end; irq++) {
+		ret = devm_request_irq(&pdev->dev, irq,
+				       rza1dma_irq_handler, 0, "RZA1DMA", rza1dma);
+		if (ret) {
+			dev_warn(rza1dma->dev, "Can't register IRQ for DMA\n");
+			goto err;
+		}
+	}
+
+	/* Register interrupt handler for error */
+	eirq_res = platform_get_resource(pdev, IORESOURCE_IRQ, 1);
+	if (!eirq_res)
+		return -ENODEV;
+
+	irq_err = eirq_res->start;
+	ret = devm_request_irq(&pdev->dev, irq_err,
+				rza1dma_irq_handler, 0, "RZA1DMA_E", rza1dma);
+	if (ret) {
+		dev_warn(rza1dma->dev, "Can't register ERRIRQ for DMA\n");
+		goto err;
+	}
+
+	INIT_LIST_HEAD(&rza1dma->dma_device.channels);
+	dma_cap_set(DMA_SLAVE, rza1dma->dma_device.cap_mask);
+	dma_cap_set(DMA_MEMCPY, rza1dma->dma_device.cap_mask);
+	spin_lock_init(&rza1dma->lock);
+
+	rza1dma->channel = devm_kzalloc(&pdev->dev,
+				sizeof(struct rza1dma_channel) * channel_num,
+				GFP_KERNEL);
+
+	/* Initialize channel parameters */
+	for (i = 0; i < channel_num; i++) {
+		struct rza1dma_channel *rza1dmac = &rza1dma->channel[i];
+
+		rza1dmac->rza1dma = rza1dma;
+
+		INIT_LIST_HEAD(&rza1dmac->ld_queue);
+		INIT_LIST_HEAD(&rza1dmac->ld_free);
+		INIT_LIST_HEAD(&rza1dmac->ld_active);
+
+		tasklet_init(&rza1dmac->dma_tasklet, rza1dma_tasklet,
+			     (unsigned long)rza1dmac);
+		rza1dmac->chan.device = &rza1dma->dma_device;
+		dma_cookie_init(&rza1dmac->chan);
+		rza1dmac->channel = i;
+
+		/* Set io base address for each channel */
+		if (i < 8) {
+			rza1dmac->ch_base = rza1dma->base + CHANNEL_0_7_OFFSET +
+						EACH_CHANNEL_OFFSET * i;
+			rza1dmac->ch_cmn_base = rza1dma->base +
+						CHANNEL_0_7_COMMON_BASE;
+		} else {
+			rza1dmac->ch_base = rza1dma->base + CHANNEL_8_15_OFFSET	+
+						EACH_CHANNEL_OFFSET * (i - 8);
+			rza1dmac->ch_cmn_base = rza1dma->base +
+						CHANNEL_8_15_COMMON_BASE;
+		}
+		/* Allocate descriptors */
+		rza1dmac->desc_base = dma_alloc_coherent(NULL,
+					sizeof(struct format_desc) * FORMAT_DESC_NUM,
+					&rza1dmac->desc_base_dma,
+					GFP_KERNEL);
+		/* Add the channel to the DMAC list */
+		list_add_tail(&rza1dmac->chan.device_node,
+			      &rza1dma->dma_device.channels);
+
+		/* Initialize register for each channel */
+		rza1dma_ch_writel(rza1dmac, CHCTRL_DEFAULT, CHCTRL, 1);
+	}
+
+	/* Initialize register for all channels */
+	rza1dma_writel(rza1dma, DCTRL_DEFAULT, CHANNEL_0_7_COMMON_BASE	+ DCTRL);
+	rza1dma_writel(rza1dma, DCTRL_DEFAULT, CHANNEL_8_15_COMMON_BASE + DCTRL);
+
+	rza1dma->pdata = pdata;
+	rza1dma->dev = &pdev->dev;
+	rza1dma->dma_device.dev = &pdev->dev;
+
+	rza1dma->dma_device.device_alloc_chan_resources = rza1dma_alloc_chan_resources;
+	rza1dma->dma_device.device_free_chan_resources = rza1dma_free_chan_resources;
+	rza1dma->dma_device.device_tx_status = rza1dma_tx_status;
+	rza1dma->dma_device.device_prep_slave_sg = rza1dma_prep_slave_sg;
+	rza1dma->dma_device.device_prep_dma_memcpy = rza1dma_prep_dma_memcpy;
+	rza1dma->dma_device.device_control = rza1dma_control;
+	rza1dma->dma_device.device_issue_pending = rza1dma_issue_pending;
+
+	platform_set_drvdata(pdev, rza1dma);
+
+	rza1dma->dma_device.copy_align = 0; /* Set copy_align to zero for net_dma_find_channel
+					     * func to run well. But it might cause problems.
+					     */
+	rza1dma->dma_device.copy_align = 0;
+	rza1dma->dma_device.dev->dma_parms = &rza1dma->dma_parms;
+	dma_set_max_seg_size(rza1dma->dma_device.dev, 0xffffff);
+
+	ret = dma_async_device_register(&rza1dma->dma_device);
+	if (ret) {
+		dev_err(&pdev->dev, "unable to register\n");
+		goto err;
+	}
+	return 0;
+err:
+	return ret;
+}
+
+static int __exit rza1dma_remove(struct platform_device *pdev)
+{
+	struct rza1dma_engine *rza1dma = platform_get_drvdata(pdev);
+	struct rza1_dma_pdata *pdata = rza1dma->pdata;
+	int i, channel_num = pdata->channel_num;
+
+	/* free allocated resources */
+	for (i = 0; i < channel_num; i++) {
+		struct rza1dma_channel *rza1dmac = &rza1dma->channel[i];
+
+		dma_free_coherent(NULL,
+				sizeof(struct format_desc) * FORMAT_DESC_NUM,
+				rza1dmac->desc_base,
+				rza1dmac->desc_base_dma);
+	}
+
+	dma_async_device_unregister(&rza1dma->dma_device);
+	return 0;
+}
+
+static struct platform_driver rza1dma_driver = {
+	.driver		= {
+		.name	= "rza1-dma",
+	},
+	.remove		= __exit_p(rza1dma_remove),
+};
+
+static int __init rza1dma_module_init(void)
+{
+	return platform_driver_probe(&rza1dma_driver, rza1dma_probe);
+}
+subsys_initcall(rza1dma_module_init);
+
+MODULE_AUTHOR("RSO");
+MODULE_DESCRIPTION("Renesas RZA1 DMA Engine driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
index bdca511..e74f3c3 100644
--- a/drivers/i2c/busses/Kconfig
+++ b/drivers/i2c/busses/Kconfig
@@ -740,6 +740,15 @@ config I2C_RCAR
 	  This driver can also be built as a module.  If so, the module
 	  will be called i2c-rcar.
 
+config I2C_RIIC
+	tristate "Renesas RIIC controller"
+	depends on ARCH_RZA1
+	help
+	  This driver supports the RIIC module of the Renesas RZA1.
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called i2c-riic.
+
 comment "External I2C/SMBus adapter drivers"
 
 config I2C_DIOLAN_U2C
diff --git a/drivers/i2c/busses/Makefile b/drivers/i2c/busses/Makefile
index 6181f3f..ddc6c97 100644
--- a/drivers/i2c/busses/Makefile
+++ b/drivers/i2c/busses/Makefile
@@ -60,6 +60,7 @@ obj-$(CONFIG_I2C_PNX)		+= i2c-pnx.o
 obj-$(CONFIG_I2C_PUV3)		+= i2c-puv3.o
 obj-$(CONFIG_I2C_PXA)		+= i2c-pxa.o
 obj-$(CONFIG_I2C_PXA_PCI)	+= i2c-pxa-pci.o
+obj-$(CONFIG_I2C_RIIC)		+= i2c-riic.o
 obj-$(CONFIG_I2C_S3C2410)	+= i2c-s3c2410.o
 obj-$(CONFIG_I2C_S6000)		+= i2c-s6000.o
 obj-$(CONFIG_I2C_SH7760)	+= i2c-sh7760.o
diff --git a/drivers/i2c/busses/i2c-riic.c b/drivers/i2c/busses/i2c-riic.c
new file mode 100644
index 0000000..03d3f8c
--- /dev/null
+++ b/drivers/i2c/busses/i2c-riic.c
@@ -0,0 +1,1364 @@
+/*
+ * RIIC bus driver
+ *
+ * Copyright (C) 2013  Renesas Solutions Corp.
+ *
+ * Based on i2c-sh_mobile.c
+ * Copyright (C) 2008 Magnus Damm
+ *
+ * Portions of the code based on out-of-tree driver i2c-sh7343.c
+ * Copyright (c) 2006 Carlos Munoz <carlos@kenati.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/i2c.h>
+#include <linux/i2c/riic.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#ifdef CONFIG_ARCH_RZA1
+#  include <mach/rza1.h>
+#endif
+
+#define DRIVER_VERSION	"2013-04-19"
+
+#ifdef CONFIG_ARCH_RZA1
+
+#define RIIC_ICCR1	0x00
+#define RIIC_ICCR2	0x04
+#define RIIC_ICMR1	0x08
+#define RIIC_ICMR2	0x0c
+#define RIIC_ICMR3	0x10
+#define RIIC_ICFER	0x14
+#define RIIC_ICSER	0x18
+#define RIIC_ICIER	0x1c
+#define RIIC_ICSR1	0x20
+#define RIIC_ICSR2	0x24
+#define RIIC_ICBRL	0x34
+#define RIIC_ICBRH	0x38
+#define RIIC_ICDRT	0x3c
+#define RIIC_ICDRR	0x40
+
+/* ICCR1 */
+#define ICCR1_ICE	0x80
+#define ICCR1_IICRST	0x40
+#define ICCR1_CLO	0x20
+#define ICCR1_SOWP	0x10
+#define ICCR1_SCLO	0x08
+#define ICCR1_SDAO	0x04
+#define ICCR1_SCLI	0x02
+#define ICCR1_SDAI	0x01
+
+/* ICCR2 */
+#define ICCR2_BBSY	0x80
+#define ICCR2_MST	0x40
+#define ICCR2_TRS	0x20
+#define ICCR2_SP	0x08
+#define ICCR2_RS	0x04
+#define ICCR2_ST	0x02
+
+/* ICMR1 */
+#define ICMR1_MTWP	0x80
+#define ICMR1_CKS_MASK	0x70
+#define ICMR1_BCWP	0x08
+#define ICMR1_BC_MASK	0x07
+
+#define ICMR1_CKS(_x)	(((_x) << 4) & ICMR1_CKS_MASK)
+#define ICMR1_BC(_x)	((_x) & ICMR1_BC_MASK)
+
+/* ICMR2 */
+#define ICMR2_DLCS	0x80
+#define ICMR2_SDDL_MASK	0x70
+#define ICMR2_TMOH	0x04
+#define ICMR2_TMOL	0x02
+#define ICMR2_TMOS	0x01
+
+/* ICMR3 */
+#define ICMR3_SMBS	0x80
+#define ICMR3_WAIT	0x40
+#define ICMR3_RDRFS	0x20
+#define ICMR3_ACKWP	0x10
+#define ICMR3_ACKBT	0x08
+#define ICMR3_ACKBR	0x04
+#define ICMR3_NF_MASK	0x03
+
+/* ICFER */
+#define ICFER_FMPE	0x80
+#define ICFER_SCLE	0x40
+#define ICFER_NFE	0x20
+#define ICFER_NACKE	0x10
+#define ICFER_SALE	0x08
+#define ICFER_NALE	0x04
+#define ICFER_MALE	0x02
+#define ICFER_TMOE	0x01
+
+/* ICSER */
+#define ICSER_HOAE	0x80
+#define ICSER_DIDE	0x20
+#define ICSER_GCAE	0x08
+#define ICSER_SAR2E	0x04
+#define ICSER_SAR1E	0x02
+#define ICSER_SAR0E	0x01
+
+/* ICIER */
+#define ICIER_TIE	0x80
+#define ICIER_TEIE	0x40
+#define ICIER_RIE	0x20
+#define ICIER_NAKIE	0x10
+#define ICIER_SPIE	0x08
+#define ICIER_STIE	0x04
+#define ICIER_ALIE	0x02
+#define ICIER_TMOIE	0x01
+
+/* ICSR1 */
+#define ICSR1_HOA	0x80
+#define ICSR1_DID	0x20
+#define ICSR1_GCA	0x08
+#define ICSR1_AAS2	0x04
+#define ICSR1_AAS1	0x02
+#define ICSR1_AAS0	0x01
+
+/* ICSR2 */
+#define ICSR2_TDRE	0x80
+#define ICSR2_TEND	0x40
+#define ICSR2_RDRF	0x20
+#define ICSR2_NACKF	0x10
+#define ICSR2_STOP	0x08
+#define ICSR2_START	0x04
+#define ICSR2_AL	0x02
+#define ICSR2_TMOF	0x01
+
+/* SARLn */
+#define SARL_SVA_MASK	0xfe	/* SVA[7:1] */
+#define SARL_SVA	0x01
+
+/* SARUn */
+#define SARU_SVA_MASK	0x06	/* SVA[9:8] */
+#define SARU_FS		0x01
+
+/* ICBRH */
+#define ICBRH_RESERVED	0xe0	/* The write value shoud always be 1 */
+#define ICBRH_BRH_MASK	0x1f
+#define ICBRH_SP100K	16	/* PCLK 33MHz */
+#define ICBRH_SP400K	9
+#define ICBRH_SP1000K	14
+
+/* ICBRL */
+#define ICBRL_RESERVED	0xe0	/* The write value shoud always be 1 */
+#define ICBRL_BRL_MASK	0x1f
+#define ICBRL_SP100K	19	/* PCLK 33MHz */
+#define ICBRL_SP400K	21
+#define ICBRL_SP1000K	14
+
+#define RIIC_CORE_PARAM_NUM_SLAVE_BUFFERS	16
+
+#define RIIC_NUM_CHANNELS	4
+
+static const char * const riic_name[RIIC_NUM_CHANNELS] = {
+	"riic.0", "riic.1", "riic.2", "riic.3",
+};
+
+enum {
+	RIIC_TXI,
+	RIIC_TEI,
+	RIIC_RXI,
+	RIIC_SPI,
+	RIIC_STI,
+	RIIC_NAK,
+	RIIC_ALI,
+	RIIC_TMOI,
+};
+
+#else /* default RIIC */
+
+#define RIIC_ICCR1	0x00
+#define RIIC_ICCR2	0x01
+#define RIIC_ICMR1	0x02
+#define RIIC_ICMR2	0x03
+#define RIIC_ICMR3	0x04
+#define RIIC_ICFER	0x05
+#define RIIC_ICSER	0x06
+#define RIIC_ICIER	0x07
+#define RIIC_ICSR1	0x08
+#define RIIC_ICSR2	0x09
+#define RIIC_SARL0	0x0a
+#define RIIC_SARU0	0x0b
+#define RIIC_SARL1	0x0c
+#define RIIC_SARU1	0x0d
+#define RIIC_SARL2	0x0e
+#define RIIC_SARU2	0x0f
+#define RIIC_ICBRL	0x10
+#define RIIC_ICBRH	0x11
+#define RIIC_ICDRT	0x12
+#define RIIC_ICDRR	0x13
+
+/* ICCR1 */
+#define ICCR1_ICE	0x80
+#define ICCR1_IICRST	0x40
+#define ICCR1_CLO	0x20
+#define ICCR1_SOWP	0x10
+#define ICCR1_SCLO	0x08
+#define ICCR1_SDAO	0x04
+#define ICCR1_SCLI	0x02
+#define ICCR1_SDAI	0x01
+
+/* ICCR2 */
+#define ICCR2_BBSY	0x80
+#define ICCR2_MST	0x40
+#define ICCR2_TRS	0x20
+#define ICCR2_SP	0x08
+#define ICCR2_RS	0x04
+#define ICCR2_ST	0x02
+
+/* ICMR1 */
+#define ICMR1_MTWP	0x80
+#define ICMR1_CKS_MASK	0x70
+#define ICMR1_BCWP	0x08
+#define ICMR1_BC_MASK	0x07
+
+#define ICMR1_CKS(_x)	((_x << 4) & ICMR1_CKS_MASK)
+#define ICMR1_BC(_x)	((_x) & ICMR1_BC_MASK)
+
+/* ICMR2 */
+#define ICMR2_DLCS	0x80
+#define ICMR2_SDDL_MASK	0x70
+#define ICMR2_TMOH	0x04
+#define ICMR2_TMOL	0x02
+#define ICMR2_TMOS	0x01
+
+/* ICMR3 */
+#define ICMR3_SMBS	0x80
+#define ICMR3_WAIT	0x40
+#define ICMR3_RDRFS	0x20
+#define ICMR3_ACKWP	0x10
+#define ICMR3_ACKBT	0x08
+#define ICMR3_ACKBR	0x04
+#define ICMR3_NF_MASK	0x03
+
+/* ICFER */
+#define ICFER_FMPE	0x80
+#define ICFER_SCLE	0x40
+#define ICFER_NFE	0x20
+#define ICFER_NACKE	0x10
+#define ICFER_SALE	0x08
+#define ICFER_NALE	0x04
+#define ICFER_MALE	0x02
+#define ICFER_TMOE	0x01
+
+/* ICSER */
+#define ICSER_HOAE	0x80
+#define ICSER_DIDE	0x20
+#define ICSER_GCAE	0x08
+#define ICSER_SAR2E	0x04
+#define ICSER_SAR1E	0x02
+#define ICSER_SAR0E	0x01
+
+/* ICIER */
+#define ICIER_TIE	0x80
+#define ICIER_TEIE	0x40
+#define ICIER_RIE	0x20
+#define ICIER_NAKIE	0x10
+#define ICIER_SPIE	0x08
+#define ICIER_STIE	0x04
+#define ICIER_ALIE	0x02
+#define ICIER_TMOIE	0x01
+
+/* ICSR1 */
+#define ICSR1_HOA	0x80
+#define ICSR1_DID	0x20
+#define ICSR1_GCA	0x08
+#define ICSR1_AAS2	0x04
+#define ICSR1_AAS1	0x02
+#define ICSR1_AAS0	0x01
+
+/* ICSR2 */
+#define ICSR2_TDRE	0x80
+#define ICSR2_TEND	0x40
+#define ICSR2_RDRF	0x20
+#define ICSR2_NACKF	0x10
+#define ICSR2_STOP	0x08
+#define ICSR2_START	0x04
+#define ICSR2_AL	0x02
+#define ICSR2_TMOF	0x01
+
+/* SARLn */
+#define SARL_SVA_MASK	0xfe	/* SVA[7:1] */
+#define SARL_SVA	0x01
+
+/* SARUn */
+#define SARU_SVA_MASK	0x06	/* SVA[9:8] */
+#define SARU_FS		0x01
+
+/* ICBRH */
+#define ICBRH_RESERVED	0xe0	/* The write value shoud always be 1 */
+#define ICBRH_BRH_MASK	0x1f
+
+/* ICBRL */
+#define ICBRL_RESERVED	0xe0	/* The write value shoud always be 1 */
+#define ICBRL_BRL_MASK	0x1f
+
+#define RIIC_CORE_PARAM_NUM_SLAVE_BUFFERS	16
+
+#define RIIC_NUM_CHANNELS	4
+
+static const char * const riic_name[RIIC_NUM_CHANNELS] = {
+	"riic.0", "riic.1", "riic.2", "riic.3",
+};
+
+enum {
+	RIIC_TXI,
+	RIIC_TEI,
+	RIIC_RXI,
+	RIIC_SPI,
+	RIIC_STI,
+	RIIC_NAK,
+	RIIC_ALI,
+	RIIC_TMOI,
+};
+#endif /* default RIIC */
+
+#define RIIC_TIMEOUT	10000	/* 100msec (unit = 10usec) */
+
+/* Error codes */
+enum {
+	RIIC_CORE_NO_ERROR = 0,
+	RIIC_CORE_INVALID,
+	RIIC_CORE_BUSY,
+	RIIC_CORE_TIMEOUT,
+	RIIC_CORE_AL_ADDR,
+	RIIC_CORE_AL_DATA,
+	RIIC_CORE_NACK_ADDR,
+	RIIC_CORE_NACK_DATA,
+};
+
+enum riic_state {
+	RIIC_STATE_IDLE,
+	RIIC_STATE_MASTER,
+	RIIC_STATE_SLAVE,
+	RIIC_STATE_BUS_RECOVERY
+};
+
+enum riic_master_state {
+	RIIC_MASTER_PREPARE,
+	RIIC_MASTER_ISSUED_START,
+	RIIC_MASTER_SENT_SLAVE_ADDRESS_NEXT,
+	RIIC_MASTER_SENT_SLAVE_ADDRESS,
+	RIIC_MASTER_DMAC_FINISHED,
+	RIIC_MASTER_TRANSMITTING,
+	RIIC_MASTER_TRANSMIT_LAST,
+	RIIC_MASTER_RECEIVING,
+	RIIC_MASTER_RECEIVE_LAST,
+	RIIC_MASTER_ISSUED_STOP,
+	RIIC_MASTER_END,
+};
+
+enum riic_slave_state {
+	RIIC_SLAVE_ISSUED_START,
+	RIIC_SLAVE_START_XFER,
+	RIIC_SLAVE_DMAC_FINISHED,
+	RIIC_SLAVE_ISSUED_STOP,
+	RIIC_SLAVE_ISSUED_RESTART,
+	RIIC_SLAVE_TIMEOUT,
+};
+
+#define NUM_IRQ 8
+
+struct riic_data {
+	struct device *dev;
+	struct clk *clk;
+	void __iomem *reg;
+	struct i2c_adapter adap;
+	struct i2c_msg *msg;
+	int		channel;
+	const char	*name;
+	enum riic_state	state;
+	int irq[NUM_IRQ];
+	int irqn;
+	spinlock_t	lock;
+
+	/* for master mode */
+	enum riic_master_state	master_state;
+	struct riic_core_packet	*pkt;
+	int			num_pkt;
+	int			pkt_index;
+	wait_queue_head_t	wait;
+	int			sending_addr;	/* for _AL or _NACK */
+
+	/* for slave mode */
+	enum riic_slave_state	slave_state;
+	struct riic_core_packet	slv_rx_pkt[RIIC_CORE_PARAM_NUM_SLAVE_BUFFERS];
+	int			slv_rx_head;
+	int			slv_rx_tail;
+	int			slv_timeout;
+	wait_queue_head_t	slv_wait;
+	struct timer_list	slv_timer;
+
+	/* status */
+	unsigned	slave_enabled:1;
+
+	/* status for master mode */
+	unsigned	completed:1;
+	unsigned	aled:1;
+	unsigned	nacked:1;
+
+	/* for debug */
+	int		debug;
+	enum riic_state	old_state;
+	unsigned char	old_icsr2;
+};
+
+static unsigned char riic_read(struct riic_data *rd, unsigned long addr)
+{
+	return ioread8(rd->reg + addr);
+}
+
+static void riic_write(struct riic_data *rd, unsigned char data,
+		       unsigned long addr)
+{
+	iowrite8(data, rd->reg + addr);
+}
+
+static void riic_set_bit(struct riic_data *rd, unsigned char val,
+			 unsigned long offset)
+{
+	unsigned char tmp;
+
+	tmp = riic_read(rd, offset) | val;
+	riic_write(rd, tmp, offset);
+}
+
+static void riic_clear_bit(struct riic_data *rd, unsigned char val,
+			   unsigned long offset)
+{
+	unsigned char tmp;
+
+	tmp = riic_read(rd, offset) & ~val;
+	riic_write(rd, tmp, offset);
+}
+
+static int riic_set_clock(struct riic_data *rd, int clock)
+{
+	switch (clock) {
+	case 100:
+		riic_clear_bit(rd, ICFER_FMPE, RIIC_ICFER);
+		riic_clear_bit(rd, ICMR1_CKS_MASK, RIIC_ICMR1);
+		riic_set_bit(rd, ICMR1_CKS(3), RIIC_ICMR1);
+		riic_write(rd, ICBRH_RESERVED | ICBRH_SP100K, RIIC_ICBRH);
+		riic_write(rd, ICBRL_RESERVED | ICBRL_SP100K, RIIC_ICBRL);
+		break;
+	case 400:
+		riic_clear_bit(rd, ICFER_FMPE, RIIC_ICFER);
+		riic_clear_bit(rd, ICMR1_CKS_MASK, RIIC_ICMR1);
+		riic_set_bit(rd, ICMR1_CKS(1), RIIC_ICMR1);
+		riic_write(rd, ICBRH_RESERVED | ICBRH_SP400K, RIIC_ICBRH);
+		riic_write(rd, ICBRL_RESERVED | ICBRL_SP400K, RIIC_ICBRL);
+		break;
+	case 1000:
+		riic_set_bit(rd, ICFER_FMPE, RIIC_ICFER);
+		riic_clear_bit(rd, ICMR1_CKS_MASK, RIIC_ICMR1);
+		riic_set_bit(rd, ICMR1_CKS(0), RIIC_ICMR1);
+		riic_write(rd, ICBRH_RESERVED | ICBRH_SP1000K, RIIC_ICBRH);
+		riic_write(rd, ICBRL_RESERVED | ICBRL_SP1000K, RIIC_ICBRL);
+		break;
+
+	default:
+		dev_err(rd->dev, "unsupported clock (%dkHz)\n", clock);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int riic_init_setting(struct riic_data *rd, int clock)
+{
+	int ret;
+
+	riic_clear_bit(rd, ICCR1_ICE, RIIC_ICCR1);
+	riic_set_bit(rd, ICCR1_IICRST, RIIC_ICCR1);
+	riic_clear_bit(rd, ICCR1_IICRST, RIIC_ICCR1);
+
+#ifndef CONFIG_ARCH_RZA1
+	riic_write(rd, 0, RIIC_SARL0);
+	riic_write(rd, 0, RIIC_SARU0);
+#endif
+	riic_write(rd, ICSER_SAR0E, RIIC_ICSER);
+
+	riic_write(rd, ICMR1_BC(7), RIIC_ICMR1);
+	ret = riic_set_clock(rd, clock);
+	if (ret < 0)
+		return ret;
+
+	riic_set_bit(rd, ICCR1_ICE, RIIC_ICCR1);	/* Enable RIIC */
+	riic_set_bit(rd, ICMR3_RDRFS | ICMR3_WAIT | ICMR3_ACKWP, RIIC_ICMR3);
+
+	return 0;
+}
+
+static int riic_check_busy(struct riic_data *rd)
+{
+	if (riic_read(rd, RIIC_ICCR2) & ICCR2_BBSY) {
+		dev_err(rd->dev, "i2c bus is busy.\n");
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+static int riic_master_issue_stop(struct riic_data *rd)
+{
+	riic_clear_bit(rd, ICSR2_STOP | ICSR2_NACKF, RIIC_ICSR2);
+	if (riic_read(rd, RIIC_ICCR2) & ICCR2_MST) {
+		riic_set_bit(rd, ICIER_SPIE, RIIC_ICIER);
+		riic_set_bit(rd, ICCR2_SP, RIIC_ICCR2);
+		return 0;
+	}
+
+	return -EFAULT;
+}
+
+static int riic_send_slave_address(struct riic_data *rd, int read)
+{
+	unsigned char sa_rw[2];
+
+	if (rd->pkt->rw == RIIC_CORE_RW_MASTER_TRANSMIT) {
+		riic_set_bit(rd, ICIER_TEIE, RIIC_ICIER);
+		sa_rw[0] = (rd->pkt->slave_address << 1);
+	} else {
+		sa_rw[0] = ((rd->pkt->slave_address << 1) | 1);
+	}
+	riic_write(rd, sa_rw[0], RIIC_ICDRT);
+
+	return 0;
+}
+
+static void riic_master_try_to_free_sda(struct riic_data *rd)
+{
+	unsigned long flags;
+	int i, j;
+
+	if (!(riic_read(rd, RIIC_ICCR2) & ICCR2_MST))
+		return;
+	/* If SDA is already high, RIIC will not output extra SCL */
+	if (riic_read(rd, RIIC_ICCR1) & ICCR1_SDAI)
+		return;
+	/* If SCL is low held by other device, RIIC cannot output extra SCL */
+	if (!(riic_read(rd, RIIC_ICCR1) & ICCR1_SCLI))
+		return;
+
+	spin_lock_irqsave(&rd->lock, flags);
+	riic_clear_bit(rd, ICFER_MALE, RIIC_ICFER);
+	for (i = 0; i < 32; i++) {
+		if (riic_read(rd, RIIC_ICCR1) & ICCR1_SDAI)
+			break;
+
+		riic_set_bit(rd, ICCR1_CLO, RIIC_ICCR1);
+		j = 3000;
+		while (riic_read(rd, RIIC_ICCR1) & ICCR1_CLO) {
+			udelay(1);
+			if (j-- < 0) {
+				printk(KERN_ERR "%s: CLO timeout\n", __func__);
+				break;
+			}
+		}
+	}
+	riic_set_bit(rd, ICFER_MALE, RIIC_ICFER);
+	spin_unlock_irqrestore(&rd->lock, flags);
+}
+
+static void riic_master_clean_icier(struct riic_data *rd)
+{
+	/* disable for master mode */
+	riic_clear_bit(rd, ICIER_NAKIE | ICIER_ALIE | ICIER_TEIE | ICIER_SPIE,
+		       RIIC_ICIER);
+
+	/* enable for slave mode */
+	riic_set_bit(rd, ICIER_STIE, RIIC_ICIER);
+}
+
+static void riic_master_clean_up(struct riic_data *rd, int timeout)
+{
+	unsigned long flags;
+	int ret;
+	int retrycnt = 0;
+
+retry:
+	spin_lock_irqsave(&rd->lock, flags);
+	if (rd->state != RIIC_STATE_MASTER) {
+		spin_unlock_irqrestore(&rd->lock, flags);
+		return;
+	}
+	if (!(riic_read(rd, RIIC_ICCR2) & ICCR2_MST)) {
+		spin_unlock_irqrestore(&rd->lock, flags);
+		goto out;
+	}
+
+	rd->master_state = RIIC_MASTER_END;
+	/* dummy read if needed */
+	if (riic_read(rd, RIIC_ICSR2) & ICSR2_RDRF)
+		riic_read(rd, RIIC_ICDRR);
+	riic_master_try_to_free_sda(rd);
+	ret = riic_master_issue_stop(rd);
+	rd->completed = 0;
+	spin_unlock_irqrestore(&rd->lock, flags);
+
+	if (!ret)
+		ret = wait_event_interruptible_timeout(rd->wait, rd->completed,
+					msecs_to_jiffies(timeout));
+
+	/* if a signal happens, the driver sleeps a little to wait STOP */
+	if (ret == -ERESTARTSYS)
+		msleep(10);
+
+	if (riic_read(rd, RIIC_ICCR2) & ICCR2_MST) {
+		/* riic_dump(rd, "re-issue stop"); */
+		if (retrycnt++ < rd->adap.retries);
+			goto retry;
+		printk("Can't cleanup a I2C bus, give up! (iccr2:%x)"
+			" bus may be busy.\n", riic_read(rd, RIIC_ICCR2));
+	}
+
+out:
+	spin_lock_irqsave(&rd->lock, flags);
+	rd->state = RIIC_STATE_IDLE;
+	riic_master_clean_icier(rd);
+	rd->pkt = NULL;
+	spin_unlock_irqrestore(&rd->lock, flags);
+}
+
+static int riic_master(struct riic_data *rd)
+{
+	int ret = 0;
+	int timeout = 1000;
+	unsigned long flags;
+
+	spin_lock_irqsave(&rd->lock, flags);
+	rd->state = RIIC_STATE_MASTER;
+	rd->master_state = RIIC_MASTER_PREPARE;
+	rd->pkt_index = 0;
+	rd->completed = rd->nacked = rd->aled = 0;
+
+	riic_set_bit(rd, ICIER_STIE | ICIER_NAKIE | ICIER_ALIE, RIIC_ICIER);
+	riic_set_bit(rd, ICIER_RIE, RIIC_ICIER);
+	riic_clear_bit(rd, ICIER_TEIE, RIIC_ICIER);
+
+	/* Send START */
+	riic_set_bit(rd, ICCR2_ST, RIIC_ICCR2);
+	spin_unlock_irqrestore(&rd->lock, flags);
+
+	ret = wait_event_interruptible_timeout(rd->wait, rd->completed ||
+			rd->nacked || rd->aled, msecs_to_jiffies(timeout));
+	if ((!rd->completed && ret == 0) || ret < 0) {
+		riic_master_clean_up(rd, timeout);
+		ret = RIIC_CORE_TIMEOUT;
+	} else if (rd->nacked) {
+		/* already issued stop in riic_irq_master_nackf() */
+		if (rd->sending_addr)
+			ret = RIIC_CORE_NACK_ADDR;
+		else
+			ret = RIIC_CORE_NACK_DATA;
+	} else if (rd->aled) {
+		if (rd->sending_addr)
+			ret = RIIC_CORE_AL_ADDR;
+		else
+			ret = RIIC_CORE_AL_DATA;
+	} else {
+		ret = RIIC_CORE_NO_ERROR;
+	}
+
+	return ret;
+}
+
+static int riic_xfer(struct i2c_adapter *adapter, struct i2c_msg *msgs,
+		     int num)
+{
+	struct riic_data *rd = i2c_get_adapdata(adapter);
+	struct riic_core_packet *pkt;
+	int i, ret = 0;
+
+	if (riic_check_busy(rd))
+		return -EBUSY;
+
+	/* msgs to pkt */
+	pkt = kzalloc(sizeof(struct riic_core_packet) * num, GFP_KERNEL);
+	if (!pkt)
+		return -ENOMEM;
+	for (i = 0; i < num; i++) {
+		pkt[i].slave_address = msgs[i].addr;
+		if (msgs[i].flags & I2C_M_RD)
+			pkt[i].rw = RIIC_CORE_RW_MASTER_RECEIVE;
+		else
+			pkt[i].rw = RIIC_CORE_RW_MASTER_TRANSMIT;
+		pkt[i].len = msgs[i].len;
+		pkt[i].data = msgs[i].buf;
+	}
+	rd->pkt = pkt;
+	rd->num_pkt = num;
+
+	ret = riic_master(rd);
+	switch (ret) {
+	case RIIC_CORE_NO_ERROR:
+		ret = num;
+		break;
+	case RIIC_CORE_BUSY:
+		ret = -EBUSY;
+		break;
+	case RIIC_CORE_TIMEOUT:
+		ret = -ETIMEDOUT;
+		break;
+	case RIIC_CORE_AL_ADDR:
+		ret = -EFAULT;
+		break;
+	case RIIC_CORE_AL_DATA:
+		ret = -EIO;
+		break;
+	case RIIC_CORE_NACK_ADDR:
+		ret = -ENXIO;
+		break;
+	case RIIC_CORE_NACK_DATA:
+		ret = -EAGAIN;
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	kfree(pkt);
+
+	return ret;
+}
+
+static u32 riic_func(struct i2c_adapter *adapter)
+{
+	return I2C_FUNC_I2C | I2C_FUNC_10BIT_ADDR | I2C_FUNC_SMBUS_EMUL;
+}
+
+static struct i2c_algorithm riic_algorithm = {
+	.functionality	= riic_func,
+	.master_xfer	= riic_xfer,
+};
+
+static int riic_remove(struct platform_device *pdev)
+{
+	struct riic_data *rd = platform_get_drvdata(pdev);
+	int i;
+
+	if (!rd)
+		return 0;
+
+	i2c_del_adapter(&rd->adap);
+	for (i = 0; i < rd->irqn; i++)
+		free_irq(rd->irq[i], rd);
+	iounmap(rd->reg);
+	clk_disable(rd->clk);
+	clk_put(rd->clk);
+	kfree(rd);
+
+	return 0;
+}
+
+static int riic_master_is_sending_address(struct riic_data *rd)
+{
+	int ret = 0;
+
+	switch (rd->master_state) {
+	case RIIC_MASTER_PREPARE:
+	case RIIC_MASTER_ISSUED_START:
+		ret = 1;
+		break;
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+static void riic_slave_start_rx_timer(struct riic_data *rd)
+{
+	mod_timer(&rd->slv_timer, jiffies + msecs_to_jiffies(rd->slv_timeout));
+}
+
+static void riic_set_receive_ack(struct riic_data *rd, int ack)
+{
+	if (ack)
+		riic_clear_bit(rd, ICMR3_ACKBT, RIIC_ICMR3);
+	else
+		riic_set_bit(rd, ICMR3_ACKBT, RIIC_ICMR3);
+}
+
+static void riic_slave_prepare(struct riic_data *rd)
+{
+	riic_set_bit(rd, ICIER_SPIE, RIIC_ICIER);
+
+	if (!rd->slave_enabled)
+		return;
+
+	rd->state = RIIC_STATE_SLAVE;
+	rd->slave_state = RIIC_SLAVE_ISSUED_START;
+	riic_clear_bit(rd, ICIER_STIE, RIIC_ICIER);
+	riic_set_receive_ack(rd, 1);
+	riic_slave_start_rx_timer(rd);
+}
+
+static void riic_irq_master_al(struct riic_data *rd, unsigned char icsr2)
+{
+	rd->state = RIIC_STATE_IDLE;
+	rd->sending_addr = riic_master_is_sending_address(rd);
+	riic_master_clean_icier(rd);
+	riic_slave_prepare(rd);	/* enter RIIC_STATE_SLAVE */
+	rd->pkt = NULL;
+	rd->aled = 1;
+	wake_up_interruptible(&rd->wait);
+}
+
+static void riic_irq_master_nackf(struct riic_data *rd)
+{
+	if (rd->master_state != RIIC_MASTER_END) {
+		rd->sending_addr = riic_master_is_sending_address(rd);
+		rd->master_state = RIIC_MASTER_END;
+		riic_clear_bit(rd, ICIER_TEIE, RIIC_ICIER);
+		riic_master_issue_stop(rd);
+	}
+
+	rd->nacked = 1;
+}
+
+/* Master Mode */
+static int riic_master_is_last_packet(struct riic_data *rd)
+{
+	if (rd->num_pkt - (rd->pkt_index + 1) == 0)
+		return 1;
+	else
+		return 0;
+}
+
+static int riic_pkt_buf_data_len(struct riic_data *rd)
+{
+	return rd->pkt->len - rd->pkt->buf_idx;
+}
+
+static void riic_write_pkt_buf(struct riic_data *rd)
+{
+	struct riic_core_packet *pkt = rd->pkt;
+	unsigned char *buf = (unsigned char *)rd->pkt->data;
+
+	riic_write(rd, buf[pkt->buf_idx++], RIIC_ICDRT);
+}
+
+static void riic_master_update_packet(struct riic_data *rd)
+{
+	/* update current pkt */
+	rd->pkt->done = 1;
+
+	/* increment pkt pointer if needed */
+	if (!riic_master_is_last_packet(rd)) {
+		rd->pkt++;
+		rd->pkt_index++;
+		rd->pkt->buf_idx = 0;
+	} else {
+		rd->pkt = NULL;
+	}
+}
+
+static int riic_enable_interrupt_transmit_end(struct riic_data *rd)
+{
+	if (!riic_pkt_buf_data_len(rd)) {
+		riic_clear_bit(rd, ICIER_TEIE, RIIC_ICIER);
+		return -1;
+	}
+	riic_set_bit(rd, ICIER_TEIE, RIIC_ICIER);
+	return 0;
+}
+
+static void riic_master_kick_transmit(struct riic_data *rd)
+{
+	if (riic_enable_interrupt_transmit_end(rd))
+		return;
+
+	if (riic_pkt_buf_data_len(rd) >= 2) {
+		if (rd->master_state != RIIC_MASTER_TRANSMITTING) {
+			rd->master_state = RIIC_MASTER_TRANSMITTING;
+			rd->pkt->buf_idx = 0;
+		}
+	} else if (riic_pkt_buf_data_len(rd) == 1) {
+		rd->master_state = RIIC_MASTER_TRANSMIT_LAST;
+	} else {
+		printk(KERN_ERR "%s: got a zero buffer packet!\n", __func__);
+	}
+	riic_write_pkt_buf(rd);
+}
+
+static void riic_read_receive_data(struct riic_data *rd, int clear_wait)
+{
+	struct riic_core_packet *pkt = rd->pkt;
+	unsigned char *buf = pkt->data;
+
+	buf[pkt->buf_idx++] = riic_read(rd, RIIC_ICDRR);
+	if (clear_wait)
+		riic_clear_bit(rd, ICMR3_WAIT, RIIC_ICMR3);
+}
+
+static void riic_send_start_cond(struct riic_data *rd, int restart)
+{
+	riic_set_bit(rd, ICIER_STIE, RIIC_ICIER);
+	if (restart)
+		riic_set_bit(rd, ICCR2_RS, RIIC_ICCR2);
+	else
+		riic_set_bit(rd, ICCR2_ST, RIIC_ICCR2);
+}
+
+static int riic_wait_for_icsr2(struct riic_data *rd, unsigned short bit)
+{
+	unsigned char icsr2;
+	int timeout = RIIC_TIMEOUT;
+
+	while (timeout-- > 0) {
+		icsr2 = riic_read(rd, RIIC_ICSR2);
+		if (icsr2 & ICSR2_NACKF)
+			return -EIO;
+		if (icsr2 & bit)
+			return 0;
+		udelay(10);
+	}
+
+	printk("%s: Timeout!(bit = %x icsr2 = %x, iccr2 = %x)\n", __func__,
+		bit, riic_read(rd, RIIC_ICSR2), riic_read(rd, RIIC_ICCR2));
+
+	return -ETIMEDOUT;
+}
+
+static void riic_packet_receive(struct riic_data *rd)
+{
+	if (riic_pkt_buf_data_len(rd) >= 2) {
+		rd->master_state = RIIC_MASTER_RECEIVING;
+		riic_read_receive_data(rd, 0);
+		riic_set_receive_ack(rd, 1);
+
+	} else if (riic_pkt_buf_data_len(rd) == 1) {
+		riic_set_receive_ack(rd, 0);
+		if (riic_master_is_last_packet(rd)) {
+			rd->master_state = RIIC_MASTER_RECEIVE_LAST;
+			riic_wait_for_icsr2(rd, ICSR2_RDRF);
+
+			/* issue STOP */
+			riic_master_issue_stop(rd);
+			riic_read_receive_data(rd, 1);
+
+		} else {
+			riic_read_receive_data(rd, 1);
+			riic_master_update_packet(rd);
+
+			/* issue RESTART */
+			riic_send_start_cond(rd, 1);
+		}
+	} else {
+		printk(KERN_ERR "%s: got a zero buffer packet!\n", __func__);
+	}
+}
+
+static void riic_master_kick_receive(struct riic_data *rd)
+{
+	rd->pkt->buf_idx = 0;
+	riic_clear_bit(rd, ICIER_TIE, RIIC_ICIER);
+	riic_clear_bit(rd, ICSR2_TDRE, RIIC_ICSR2);
+
+	/* dummy read */
+	riic_read(rd, RIIC_ICDRR);
+
+	riic_packet_receive(rd);
+}
+
+static void riic_irq_master_tend(struct riic_data *rd)
+{
+	switch (rd->master_state) {
+	case RIIC_MASTER_ISSUED_START:
+		rd->master_state = RIIC_MASTER_SENT_SLAVE_ADDRESS;
+		riic_master_kick_transmit(rd);
+		break;
+	case RIIC_MASTER_SENT_SLAVE_ADDRESS_NEXT:
+		rd->master_state = RIIC_MASTER_SENT_SLAVE_ADDRESS;
+		riic_master_kick_transmit(rd);
+		break;
+	case RIIC_MASTER_TRANSMITTING:
+		break;
+	case RIIC_MASTER_TRANSMIT_LAST:
+		if (riic_master_is_last_packet(rd)) {
+			/* issue STOP */
+			riic_master_issue_stop(rd);
+		} else {
+			riic_master_update_packet(rd);
+			/* issue RESTART */
+			riic_set_bit(rd, ICIER_STIE, RIIC_ICIER);
+			riic_set_bit(rd, ICCR2_RS, RIIC_ICCR2);
+		}
+		break;
+
+	default:
+		printk(KERN_ERR "%s: ch%d, unexpect master_state (%d)\n",
+			__func__, rd->channel, rd->master_state);
+		break;
+	}
+}
+
+static void riic_irq_master_rdrf(struct riic_data *rd)
+{
+	switch (rd->master_state) {
+	case RIIC_MASTER_ISSUED_START:
+		riic_master_kick_receive(rd);
+		break;
+	case RIIC_MASTER_RECEIVING:
+	case RIIC_MASTER_RECEIVE_LAST:
+		riic_packet_receive(rd);
+		break;
+	case RIIC_MASTER_END:
+		break;
+	default:
+		break;
+	}
+}
+
+static void riic_irq_master_start(struct riic_data *rd, unsigned char icsr2)
+{
+	if (!(riic_read(rd, RIIC_ICCR2) & ICCR2_MST)) {
+		riic_slave_prepare(rd);
+		return;
+	}
+
+	switch (rd->master_state) {
+	case RIIC_MASTER_TRANSMIT_LAST:
+	case RIIC_MASTER_RECEIVE_LAST:
+	case RIIC_MASTER_PREPARE:
+		rd->master_state = RIIC_MASTER_ISSUED_START;
+		if (icsr2 & ICSR2_TDRE)
+			riic_send_slave_address(rd, 0);
+		break;
+	default:
+		printk(KERN_ERR "%s: ch%d, unexpect master_state (%d)\n",
+			__func__, rd->channel, rd->master_state);
+		break;
+	}
+}
+
+static void riic_irq_master_stop(struct riic_data *rd)
+{
+	switch (rd->master_state) {
+	case RIIC_MASTER_TRANSMIT_LAST:
+	case RIIC_MASTER_RECEIVE_LAST:
+	case RIIC_MASTER_END:
+		rd->master_state = RIIC_MASTER_ISSUED_STOP;
+		riic_master_clean_icier(rd);
+
+		rd->state = RIIC_STATE_IDLE;
+		if (!rd->nacked) {
+			riic_master_update_packet(rd);
+			rd->completed = 1;
+		}
+		wake_up_interruptible(&rd->wait);
+		break;
+	case RIIC_MASTER_TRANSMITTING:
+	case RIIC_MASTER_ISSUED_START:
+		/* avoid to output the following message */
+		break;
+	default:
+		/* riic_dump(rd, __func__); */
+		printk(KERN_ERR "%s: ch%d, unexpect master_state (%d)\n",
+			__func__, rd->channel, rd->master_state);
+		break;
+	}
+}
+
+static void riic_irq_master(struct riic_data *rd, unsigned char icsr2)
+{
+	if (icsr2 & ICSR2_AL) {
+		riic_clear_bit(rd, ICSR2_AL, RIIC_ICSR2);
+		riic_irq_master_al(rd, icsr2);
+		return;
+	}
+	if (icsr2 & ICSR2_NACKF) {
+		riic_clear_bit(rd, ICSR2_NACKF, RIIC_ICSR2);
+		riic_irq_master_nackf(rd);
+		return;
+	}
+	if (icsr2 & ICSR2_TEND && riic_read(rd, RIIC_ICIER) & ICIER_TEIE) {
+		riic_clear_bit(rd, ICIER_TEIE, RIIC_ICIER);
+		riic_irq_master_tend(rd);
+	}
+	if (icsr2 & ICSR2_RDRF) {
+		riic_irq_master_rdrf(rd);
+		riic_clear_bit(rd, ICSR2_RDRF, RIIC_ICSR2);
+		return;
+	}
+	if (icsr2 & ICSR2_START) {
+		riic_clear_bit(rd, ICIER_STIE, RIIC_ICIER);
+		riic_clear_bit(rd, ICSR2_START, RIIC_ICSR2);
+		riic_irq_master_start(rd, icsr2);
+	}
+	if (icsr2 & ICSR2_STOP) {
+		riic_clear_bit(rd, ICIER_SPIE, RIIC_ICIER);
+		riic_clear_bit(rd, ICSR2_STOP, RIIC_ICSR2);
+		riic_irq_master_stop(rd);
+	}
+	if (icsr2 & ICSR2_TDRE) {
+		riic_clear_bit(rd, ICSR2_TDRE, RIIC_ICSR2);
+		if (rd->pkt->rw != RIIC_CORE_RW_MASTER_TRANSMIT)
+			return;
+		riic_master_kick_transmit(rd);
+	}
+}
+
+/* Idle */
+static void riic_irq_idle_start(struct riic_data *rd, unsigned char icsr2)
+{
+	unsigned char iccr2 = riic_read(rd, RIIC_ICCR2);
+
+	if (iccr2 & ICCR2_MST) {
+		printk(KERN_ERR "%s: No longer in slave mode %d,%02x,%02x\n",
+			__func__, rd->channel, icsr2, iccr2);
+		return;
+	}
+	if (!(iccr2 & ICCR2_BBSY)) {
+		printk(KERN_ERR "%s: no busy %d, %02x\n", __func__,
+			rd->channel, iccr2);
+		return;
+	}
+
+	riic_slave_prepare(rd);
+}
+
+static void riic_irq_idle(struct riic_data *rd, unsigned char icsr2)
+{
+	if (icsr2 & ICSR2_AL)
+		riic_clear_bit(rd, ICSR2_AL, RIIC_ICSR2);
+	if (icsr2 & ICSR2_NACKF)
+		riic_clear_bit(rd, ICSR2_NACKF, RIIC_ICSR2);
+	if (icsr2 & ICSR2_TEND &&
+	    riic_read(rd, RIIC_ICIER) & ICIER_TEIE)
+		riic_clear_bit(rd, ICIER_TEIE, RIIC_ICIER);
+
+	switch ((icsr2 & (ICSR2_START | ICSR2_STOP))) {
+	case (ICSR2_START | ICSR2_STOP):
+		/*
+		 * If the following sequence, we should clear the STOP flag:
+		 *  START -> NACK -> STOP ---> START -> ACK -> (IRQ happens)
+		 *  Then, the RIIC's ICSR2 will be set (START | STOP).
+		 */
+		riic_clear_bit(rd, ICSR2_STOP, RIIC_ICSR2);
+		/* through */
+	case ICSR2_START:
+		riic_clear_bit(rd, ICSR2_START, RIIC_ICSR2);
+		riic_irq_idle_start(rd, icsr2);
+		break;
+	case ICSR2_STOP:
+		riic_clear_bit(rd, ICSR2_STOP, RIIC_ICSR2);
+		riic_clear_bit(rd, ICIER_SPIE, RIIC_ICIER);
+		break;
+	default:
+		break;
+	}
+}
+
+/* Slave Mode */
+static void riic_irq_slave(struct riic_data *rd, unsigned char icsr2)
+{
+	printk("This version driver doesn't support slave mode!\n");
+	return;
+}
+
+static irqreturn_t riic_irq(int irq, void *data)
+{
+	struct riic_data *rd = data;
+	unsigned char icsr2 = riic_read(rd, RIIC_ICSR2);
+
+	rd->old_state = rd->state;
+	rd->old_icsr2 = icsr2;
+
+	switch (rd->state) {
+	case RIIC_STATE_MASTER:
+		riic_irq_master(rd, icsr2);
+		break;
+	case RIIC_STATE_SLAVE:
+		riic_irq_slave(rd, icsr2);
+		break;
+	case RIIC_STATE_IDLE:
+		riic_irq_idle(rd, icsr2);
+		break;
+
+	default:
+		break;
+	}
+	return IRQ_HANDLED;
+}
+
+static int riic_probe(struct platform_device *pdev)
+{
+	struct resource *res = NULL;
+	struct riic_data *rd = NULL;
+	struct riic_platform_data *riic_data = NULL;
+	struct i2c_adapter *adap;
+	void __iomem *reg = NULL;
+	int i, irq, j = 0;
+	int ret = 0;
+	char clk_name[16];
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		ret = -ENOENT;
+		dev_err(&pdev->dev, "platform_get_resource failed.\n");
+		goto clean_up;
+	}
+
+	if (!pdev->dev.platform_data) {
+		ret = -ENOENT;
+		dev_err(&pdev->dev, "no platform data\n");
+		goto clean_up;
+	}
+	riic_data = pdev->dev.platform_data;
+
+	reg = ioremap(res->start, resource_size(res));
+	if (reg == NULL) {
+		ret = -ENXIO;
+		dev_err(&pdev->dev, "ioremap failed.\n");
+		goto clean_up;
+	}
+
+	rd = kzalloc(sizeof(struct riic_data), GFP_KERNEL);
+	if (rd == NULL) {
+		ret = -ENOMEM;
+		dev_err(&pdev->dev, "kzalloc failed.\n");
+		goto clean_up;
+	}
+
+	rd->dev = &pdev->dev;
+	rd->reg = reg;
+	platform_set_drvdata(pdev, rd);
+
+	adap = &rd->adap;
+	i2c_set_adapdata(adap, rd);
+
+	adap->owner = THIS_MODULE;
+	adap->algo = &riic_algorithm;
+	adap->dev.parent = &pdev->dev;
+	adap->retries = 5;
+	rd->channel = adap->nr = pdev->id;
+
+	strlcpy(adap->name, dev_name(&pdev->dev), sizeof(adap->name));
+	if (pdev->id < RIIC_NUM_CHANNELS) {
+		rd->name = riic_name[pdev->id];
+	} else {
+		ret = -ENXIO;
+		dev_err(&pdev->dev, "invalid platform device id.\n");
+		goto clean_up;
+	}
+
+	snprintf(clk_name, sizeof(clk_name), "riic%d", pdev->id);
+	rd->clk = clk_get(&pdev->dev, clk_name);
+	if (IS_ERR(rd->clk)) {
+		dev_err(&pdev->dev, "clk_get failed.\n");
+		ret = PTR_ERR(rd->clk);
+		goto clean_up;
+	}
+	clk_enable(rd->clk);
+
+	ret = riic_init_setting(rd, riic_data->clock);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "riic_init_setting failed.\n");
+		goto clean_up;
+	}
+
+	i = j = 0;
+	while ((res = platform_get_resource(pdev, IORESOURCE_IRQ, i++))) {
+		for (irq = res->start; irq <= res->end; irq++) {
+			if (j >= NUM_IRQ) {
+				dev_err(&pdev->dev, "irq resource is over\n");
+				ret = -ENODEV;
+				goto clean_up;
+			}
+			if (res->flags & IORESOURCE_IRQ_HIGHEDGE)
+				irq_set_irq_type(irq, IRQ_TYPE_EDGE_RISING);
+			ret = request_irq(irq, riic_irq, IRQF_DISABLED,
+					  rd->name, rd);
+			if (ret < 0) {
+				dev_err(&pdev->dev, "request_irq error\n");
+				goto clean_up;
+			}
+			rd->irq[j++] = irq;
+		}
+	}
+	rd->irqn = j;
+
+	init_waitqueue_head(&rd->wait);
+
+	ret = i2c_add_numbered_adapter(adap);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "i2c_add_numbered_adapter failed.\n");
+		goto clean_up;
+	}
+
+#ifdef CONFIG_ARCH_RZA1
+	/* I2C pfc pin assign after resetting. */
+	rskrza1_board_i2c_pfc_assign(pdev->id);
+#endif
+
+	dev_info(&pdev->dev, "version %s: %d[kbps]\n", DRIVER_VERSION,riic_data->clock);
+	return ret;
+
+clean_up:
+	for (i = 0; i < j; i++)
+		free_irq(rd->irq[i], rd);
+	if (rd) {
+		if (!IS_ERR(rd->clk)) {
+			clk_disable(rd->clk);
+			clk_put(rd->clk);
+		}
+		kfree(rd);
+	}
+	if (reg)
+		iounmap(reg);
+	platform_set_drvdata(pdev, NULL);
+
+	return ret;
+}
+
+static struct platform_driver riic_driver = {
+	.probe =	riic_probe,
+	.remove =	riic_remove,
+	.driver		= {
+		.name	= "i2c-riic",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init riic_init(void)
+{
+	return platform_driver_register(&riic_driver);
+}
+module_init(riic_init);
+
+static void __exit riic_cleanup(void)
+{
+	platform_driver_unregister(&riic_driver);
+}
+module_exit(riic_cleanup);
+
+MODULE_DESCRIPTION("Renesas RIIC Driver");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Yoshihiro Shimoda");
+MODULE_ALIAS("platform:i2c-riic");
diff --git a/drivers/iio/adc/Kconfig b/drivers/iio/adc/Kconfig
index fe822a1..fc3bb67 100644
--- a/drivers/iio/adc/Kconfig
+++ b/drivers/iio/adc/Kconfig
@@ -139,4 +139,12 @@ config VIPERBOARD_ADC
 	  Say yes here to access the ADC part of the Nano River
 	  Technologies Viperboard.
 
+config SH_ADC
+	tristate "RZA1 ADC support"
+	depends on ARCH_RZA1
+	select IIO_BUFFER
+	select IIO_TRIGGERED_BUFFER
+	help
+	  Support RZA1 ADC
+
 endmenu
diff --git a/drivers/iio/adc/Makefile b/drivers/iio/adc/Makefile
index 2d5f100..ebbb629 100644
--- a/drivers/iio/adc/Makefile
+++ b/drivers/iio/adc/Makefile
@@ -15,3 +15,4 @@ obj-$(CONFIG_MAX1363) += max1363.o
 obj-$(CONFIG_TI_ADC081C) += ti-adc081c.o
 obj-$(CONFIG_TI_AM335X_ADC) += ti_am335x_adc.o
 obj-$(CONFIG_VIPERBOARD_ADC) += viperboard_adc.o
+obj-$(CONFIG_SH_ADC) += sh_adc.o
diff --git a/drivers/iio/adc/sh_adc.c b/drivers/iio/adc/sh_adc.c
new file mode 100644
index 0000000..cd04ee1
--- /dev/null
+++ b/drivers/iio/adc/sh_adc.c
@@ -0,0 +1,763 @@
+/*
+ * SH ADC driver
+ *
+ * Copyright (C) 2013  Renesas Solutions Corp.
+ *
+ * Based on at91_adc.c:
+ * Copyright 2011 Free Electrons
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/buffer.h>
+#include <linux/iio/driver.h>
+#include <linux/iio/machine.h>
+#include <linux/iio/trigger.h>
+#include <linux/iio/trigger_consumer.h>
+#include <linux/iio/triggered_buffer.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/platform_data/sh_adc.h>
+#include <linux/platform_device.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/wait.h>
+
+
+#define DRIVER_VERSION	"2013-06-12"
+
+#define SH_ADC_ADDRA	0x00
+#define SH_ADC_ADDRB	0x02
+#define SH_ADC_ADDRC	0x04
+#define SH_ADC_ADDRD	0x06
+#define SH_ADC_ADDRE	0x08
+#define SH_ADC_ADDRF	0x0a
+#define SH_ADC_ADDRG	0x0c
+#define SH_ADC_ADDRH	0x0e
+#define SH_ADC_ADCSR	0x60
+
+#define SH_ADC_ADDR_MASK	0xffc0
+#define SH_ADC_ADDR_SHIFT	6
+
+#define SH_ADC_ADCSR_ADF	0x8000
+#define SH_ADC_ADCSR_ADIE	0x4000
+#define SH_ADC_ADCSR_ADST	0x2000
+#define SH_ADC_ADCSR_TRGS_MASK	0x1e00
+#define SH_ADC_ADCSR_TRGS_NON	0x0000	/* external trigger input is disable */
+#define SH_ADC_ADCSR_TRGS_TRGAN	0x0200	/* MTU2, TRGAN */
+#define SH_ADC_ADCSR_TRGS_TRG0N	0x0400	/* MTU2, TRG0N */
+#define SH_ADC_ADCSR_TRGS_TRG4AN	0x0600	/* MTU2, TRG4AN */
+#define SH_ADC_ADCSR_TRGS_TRG4BN	0x0800	/* MTU2, TRG4BN */
+#define SH_ADC_ADCSR_TRGS_EXT	0x1200	/* external pin trigger */
+#define SH_ADC_ADCSR_CKS_MASK	0x01c0
+#define SH_ADC_ADCSR_CKS_256	0x0000
+#define SH_ADC_ADCSR_CKS_298	0x0040
+#define SH_ADC_ADCSR_CKS_340	0x0080
+#define SH_ADC_ADCSR_CKS_382	0x00c0
+#define SH_ADC_ADCSR_CKS_1054	0x0100
+#define SH_ADC_ADCSR_CKS_1096	0x0140
+#define SH_ADC_ADCSR_CKS_1390	0x0180
+#define SH_ADC_ADCSR_CKS_1432	0x01c0
+#define SH_ADC_ADCSR_MDS_MASK	0x0038
+#define SH_ADC_ADCSR_MDS_SINGLE	0x0000
+#define SH_ADC_ADCSR_MDS_M_1_4	0x0020	/* multi mode, channel 1 to 4 */
+#define SH_ADC_ADCSR_MDS_M_1_8	0x0028	/* multi mode, channel 1 to 8 */
+#define SH_ADC_ADCSR_MDS_S_1_4	0x0030	/* scan mode, channel 1 to 4 */
+#define SH_ADC_ADCSR_MDS_S_1_8	0x0038	/* scan mode, channel 1 to 8 */
+#define SH_ADC_ADCSR_CH_MASK	0x0003
+#define SH_ADC_ADCSR_CH_AN0	0x0000
+#define SH_ADC_ADCSR_CH_AN1	0x0001
+#define SH_ADC_ADCSR_CH_AN2	0x0002
+#define SH_ADC_ADCSR_CH_AN3	0x0003
+#define SH_ADC_ADCSR_CH_AN4	0x0004
+#define SH_ADC_ADCSR_CH_AN5	0x0005
+#define SH_ADC_ADCSR_CH_AN6	0x0006
+#define SH_ADC_ADCSR_CH_AN7	0x0007
+
+#define SH_ADC_NUM_CHANNEL	8
+#define sh_adc_get_reg_addr(ch)	(SH_ADC_ADDRA + ch * 2)
+
+struct sh_adc {
+	/* ADC */
+	void __iomem	*reg;
+	struct mutex	lock;
+	bool		done;
+	int		irq;
+	struct clk	*clk;
+	u16		*buffer;
+	wait_queue_head_t wq_data_avail;
+
+	/* MTU2 setting as a ADC trigger */
+	void __iomem	*mtu2_share_reg;
+	void __iomem	*mtu2_reg;
+	struct clk	*mtu2_clk;
+	u8		mtu2_ch;
+	int		val;
+	unsigned long	rate;
+	unsigned long	periodic;
+};
+
+/* MTU2 */
+#define TSTR -1 /* shared register */
+#define TCR  0 /* channel register */
+#define TMDR 1 /* channel register */
+#define TIOR 2 /* channel register */
+#define TIER 3 /* channel register */
+#define TSR  4 /* channel register */
+#define TCNT 5 /* channel register */
+#define TGR  6 /* channel register */
+
+#define SH_MTU2_TSR_TGFA 0x01
+
+#define TIMER_BIT 1 /* MTU2 ch.1 */
+#define CLK_DIV 64 /* count rate P0/64 (depend on TCR setting.) */
+static DEFINE_RAW_SPINLOCK(sh_mtu2_lock);
+
+static unsigned long mtu2_reg_offs[] = {
+	[TCR] = 0,
+	[TMDR] = 1,
+	[TIOR] = 2,
+	[TIER] = 4,
+	[TSR] = 5,
+	[TCNT] = 6,
+	[TGR] = 8,
+};
+
+static inline unsigned long sh_mtu2_read(struct sh_adc *adc, int reg_nr)
+{
+	unsigned long offs;
+
+	if (reg_nr == TSTR)
+		return ioread8(adc->mtu2_share_reg);
+
+	offs = mtu2_reg_offs[reg_nr];
+
+	if ((reg_nr == TCNT) || (reg_nr == TGR))
+		return ioread16(adc->mtu2_reg + offs);
+	else
+		return ioread8(adc->mtu2_reg + offs);
+}
+
+static inline void sh_mtu2_write(struct sh_adc *adc, int reg_nr,
+				unsigned long value)
+{
+	unsigned long offs;
+
+	if (reg_nr == TSTR) {
+		iowrite8(value, adc->mtu2_share_reg);
+		return;
+	}
+
+	offs = mtu2_reg_offs[reg_nr];
+
+	if ((reg_nr == TCNT) || (reg_nr == TGR))
+		iowrite16(value, adc->mtu2_reg + offs);
+	else
+		iowrite8(value, adc->mtu2_reg + offs);
+}
+
+static void sh_mtu2_start_stop_ch(struct sh_adc *adc, bool start)
+{
+	unsigned long flags, value;
+
+	/* start stop register shared by multiple timer channels */
+	raw_spin_lock_irqsave(&sh_mtu2_lock, flags);
+	value = sh_mtu2_read(adc, TSTR);
+
+	if (start)
+		value |= 1 << adc->mtu2_ch;
+	else
+		value &= ~(1 << adc->mtu2_ch);
+
+	sh_mtu2_write(adc, TSTR, value);
+	raw_spin_unlock_irqrestore(&sh_mtu2_lock, flags);
+}
+
+static int sh_mtu2_set_trigger(struct sh_adc *adc, bool timer_start)
+{
+	if (adc->val <= 0)
+		return -EINVAL;
+	/* make sure channel is disabled */
+	sh_mtu2_start_stop_ch(adc, 0);
+
+	adc->rate = clk_get_rate(adc->mtu2_clk) / CLK_DIV;
+	adc->periodic = ((adc->rate * adc->val) / 1000);
+	if (adc->periodic > 0xffff)
+		return -EINVAL;
+
+	/* "Periodic Counter Operation" */
+	sh_mtu2_write(adc, TGR, adc->periodic);
+	sh_mtu2_write(adc, TCNT, 0);
+
+	/* restart timer if timer_start is true */
+	sh_mtu2_start_stop_ch(adc, timer_start);
+
+	return 0;
+}
+
+static int sh_mtu2_enable(struct sh_adc *adc)
+{
+	/* make sure channel is disabled */
+	sh_mtu2_start_stop_ch(adc, false);
+
+	/* "Periodic Counter Operation" */
+	sh_mtu2_write(adc, TCR, 0x23); /* TGRA clear, divide clock by 64 */
+	sh_mtu2_write(adc, TIOR, 0);
+	sh_mtu2_write(adc, TMDR, 0); /* normal operation(bit3-0: 0) */
+	sh_mtu2_write(adc, TIER, 0x81); /* enable ADC trigger & TGFA bit INT */
+
+	/* a default sampling rate is 10Hz */
+	adc->val = 100;
+	return sh_mtu2_set_trigger(adc, false);
+
+}
+
+/* ADC */
+struct sh_adc_avail_chs {
+	int	channel_mask;
+	u8	an;
+};
+static struct sh_adc_avail_chs sh_adc_chs[][SH_ADC_NUM_CHANNEL] = {
+	{
+		{ 0x01, 0},
+		{ 0x03, 1},
+		{ 0x07, 2},
+		{ 0x0f, 3},
+		{ 0x10, 4},
+		{ 0x30, 5},
+		{ 0x70, 6},
+		{ 0xf0, 7},
+	},
+	{
+		{ 0x01, 0},
+		{ 0x03, 1},
+		{ 0x07, 2},
+		{ 0x0f, 3},
+		{ 0x1f, 4},
+		{ 0x3f, 5},
+		{ 0x7f, 6},
+		{ 0xff, 7},
+	},
+};
+
+static void sh_adc_write(struct sh_adc *adc, unsigned short data,
+			 unsigned long offset)
+{
+	iowrite16(data, adc->reg + offset);
+}
+
+static unsigned short sh_adc_read(struct sh_adc *adc, unsigned long offset)
+{
+	return ioread16(adc->reg + offset);
+}
+
+static void sh_adc_set_bit(struct sh_adc *adc, unsigned short val,
+			   unsigned long offset)
+{
+	unsigned short tmp;
+
+	tmp = sh_adc_read(adc, offset);
+	tmp |= val;
+	sh_adc_write(adc, tmp, offset);
+}
+
+static void sh_adc_clear_bit(struct sh_adc *adc, unsigned short val,
+			     unsigned long offset)
+{
+	unsigned short tmp;
+
+	tmp = sh_adc_read(adc, offset);
+	tmp &= ~val;
+	sh_adc_write(adc, tmp, offset);
+}
+
+static int sh_adc_start_adc(struct sh_adc *adc, int channel)
+{
+	sh_adc_clear_bit(adc, SH_ADC_ADCSR_ADST, SH_ADC_ADCSR);
+	sh_adc_clear_bit(adc, SH_ADC_ADCSR_TRGS_MASK, SH_ADC_ADCSR);
+
+	if (channel >= 0) {
+		sh_adc_clear_bit(adc, SH_ADC_ADCSR_MDS_MASK, SH_ADC_ADCSR);
+		sh_adc_clear_bit(adc, SH_ADC_ADCSR_CH_MASK, SH_ADC_ADCSR);
+		sh_adc_set_bit(adc, (SH_ADC_ADCSR_ADST | channel),
+				SH_ADC_ADCSR);
+	} else {
+		sh_adc_set_bit(adc, SH_ADC_ADCSR_TRGS_TRGAN, SH_ADC_ADCSR);
+		sh_mtu2_start_stop_ch(adc, true);
+	}
+	return 0;
+}
+
+static int sh_adc_stop_adc(struct sh_adc *adc)
+{
+	sh_mtu2_start_stop_ch(adc, false);
+	return 0;
+}
+
+static int sh_adc_get_raw_value(struct iio_dev *idev, int *val, int channel)
+{
+	struct sh_adc *adc = iio_priv(idev);
+	int ret = 1;
+
+	mutex_lock(&adc->lock);
+
+	if (!iio_buffer_enabled(idev)) {
+		sh_adc_start_adc(adc, channel);
+		ret = wait_event_interruptible_timeout(adc->wq_data_avail,
+				adc->done, msecs_to_jiffies(1000));
+		adc->done = false;
+	}
+	if (ret > 0)
+		*val = sh_adc_read(adc, sh_adc_get_reg_addr(channel));
+	mutex_unlock(&adc->lock);
+	return ret;
+}
+
+static int sh_adc_read_raw(struct iio_dev *idev,
+		struct iio_chan_spec const *chan,
+		int *val, int *val2, long mask)
+{
+	int ret;
+	struct sh_adc *adc = iio_priv(idev);
+
+	switch (mask) {
+	case IIO_CHAN_INFO_SAMP_FREQ:
+		*val = adc->val;
+		ret = IIO_VAL_INT;
+		break;
+	case IIO_CHAN_INFO_RAW:
+		ret = sh_adc_get_raw_value(idev, val, chan->channel);
+		*val >>= chan->scan_type.shift;
+		*val &= ((1 << chan->scan_type.realbits) - 1);
+		if (ret > 0)
+			ret = IIO_VAL_INT;
+		break;
+	case IIO_CHAN_INFO_SCALE:
+		*val = 1;
+		ret = IIO_VAL_INT;
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static int sh_adc_write_raw(struct iio_dev *idev,
+		struct iio_chan_spec const *chan, int val, int val2, long mask)
+{
+	int ret = 0;
+	struct sh_adc *adc = iio_priv(idev);
+
+	switch (mask) {
+	case IIO_CHAN_INFO_SAMP_FREQ:
+		adc->val = val;
+		ret = sh_mtu2_set_trigger(adc, iio_buffer_enabled(idev));
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static int sh_adc_get_ch(struct iio_dev *idev, int i)
+{
+	int j;
+	for (j = 0; j < idev->num_channels; j++)
+		if (sh_adc_chs[i][j].channel_mask == *idev->active_scan_mask)
+			return sh_adc_chs[i][j].an;
+	return -1;
+}
+
+static int sh_adc_get_mds_ch(struct iio_dev *idev)
+{
+	int i, mds_ch, ch, cnt = 0;
+
+	ch = 0;
+	for (i = 0; i < idev->masklength; i++)
+		if (test_bit(i, idev->active_scan_mask)) {
+			ch = i;
+			cnt++;
+		}
+
+	mds_ch = -1;
+	if (cnt == 1)
+		mds_ch = (ch | SH_ADC_ADCSR_MDS_SINGLE);
+	else if (cnt >= 2 && cnt <= idev->num_channels) {
+		mds_ch = sh_adc_get_ch(idev, (cnt > 4));
+		if (mds_ch < 0)
+			return -1;
+		mds_ch |= (cnt > 4 ? SH_ADC_ADCSR_MDS_M_1_8 :
+				   SH_ADC_ADCSR_MDS_M_1_4);
+	}
+	return mds_ch;
+}
+
+static int sh_adc_configure_trigger(struct iio_trigger *trig, bool state)
+{
+	struct iio_dev *idev = (struct iio_dev *)trig->private_data;
+	struct sh_adc *adc = iio_priv(idev);
+	int mds_ch;
+
+	if (state) {
+		/* set trigger */
+		adc->buffer = kzalloc(idev->scan_bytes, GFP_KERNEL);
+		if (!adc->buffer)
+			return -ENOMEM;
+
+		mds_ch = sh_adc_get_mds_ch(idev);
+		if (mds_ch < 0)
+			return -1;
+		sh_adc_set_bit(adc, mds_ch, SH_ADC_ADCSR);
+
+		sh_adc_start_adc(adc, -1);
+	} else {
+		/* clear trigger */
+		sh_adc_stop_adc(adc);
+		kfree(adc->buffer);
+	}
+	return 0;
+}
+
+static const struct iio_trigger_ops sh_adc_trigger_ops = {
+	.owner = THIS_MODULE,
+	.set_trigger_state = &sh_adc_configure_trigger,
+};
+
+static int sh_adc_trigger_init(struct iio_dev *idev)
+{
+	int ret;
+	struct iio_trigger *trig;
+
+	trig = iio_trigger_alloc("%s-dev%i", idev->name, idev->id);
+	if (!trig)
+		return -ENOMEM;
+	trig->dev.parent = idev->dev.parent;
+	trig->private_data = idev;
+	trig->ops = &sh_adc_trigger_ops;
+
+	ret = iio_trigger_register(trig);
+	if (ret)
+		iio_trigger_free(trig);
+	else
+		idev->trig = trig;
+
+	return ret;
+}
+
+static irqreturn_t sh_adc_trigger_handler(int irq, void *p)
+{
+	struct iio_poll_func *pf = p;
+	struct iio_dev *idev = pf->indio_dev;
+	struct sh_adc *adc = iio_priv(idev);
+	struct iio_chan_spec const *chans;
+	int val, ret, dnum, i;
+
+	chans = idev->channels;
+	i = 0;
+	for (dnum = 0; dnum < idev->masklength; dnum++) {
+		/* skip no-mask channel. */
+		if (!test_bit(dnum, idev->active_scan_mask))
+			continue;
+
+		/* read ch data */
+		ret = sh_adc_get_raw_value(idev, &val, dnum);
+		val >>= chans[dnum].scan_type.shift;
+		val &= ((1 << chans[dnum].scan_type.realbits) - 1);
+		if (ret > 0)
+			adc->buffer[i] = (u16)val;
+		i++;
+	}
+
+	if (idev->scan_timestamp) {
+		s64 *timestamp = (s64 *)((u8 *)adc->buffer +
+				ALIGN(i, sizeof(s64)));
+		*timestamp = pf->timestamp;
+	}
+	iio_push_to_buffers(idev, (u8 *)adc->buffer);
+	iio_trigger_notify_done(idev->trig);
+
+	enable_irq(adc->irq);
+
+	return IRQ_HANDLED;
+}
+
+
+static const struct iio_info sh_adc_info = {
+	.write_raw = sh_adc_write_raw,
+	.read_raw = sh_adc_read_raw,
+	.driver_module = THIS_MODULE,
+};
+
+static inline void sh_adc_iio_map_unregister(struct platform_device *pdev,
+					     struct sh_adc *adc, int map_stat)
+{
+	switch (map_stat) {
+	case 3:
+		devm_iounmap(&pdev->dev, adc->mtu2_reg);
+	case 2:
+		devm_iounmap(&pdev->dev, adc->mtu2_share_reg);
+	case 1:
+		devm_iounmap(&pdev->dev, adc->reg);
+	}
+}
+
+static irqreturn_t sh_adc_irq(int irq, void *private)
+{
+	struct iio_dev *idev = private;
+	struct sh_adc *adc = iio_priv(idev);
+	u8 value;
+
+	value = sh_mtu2_read(adc, TSR);
+	if (value & SH_MTU2_TSR_TGFA) {
+		value &= ~SH_MTU2_TSR_TGFA;
+		sh_mtu2_write(adc, TSR, value);
+		return IRQ_HANDLED;
+	}
+
+	sh_adc_clear_bit(adc, SH_ADC_ADCSR_ADF, SH_ADC_ADCSR);
+
+	if (!iio_buffer_enabled(idev)) {
+		adc->done = true;
+		wake_up_interruptible(&adc->wq_data_avail);
+	} else {
+		adc->irq = irq;
+		disable_irq_nosync(irq);
+		iio_trigger_poll(idev->trig, iio_get_time_ns());
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int sh_adc_get_clk(struct platform_device *pdev, struct clk **clk,
+			  char *name)
+{
+	int ret;
+
+	*clk = devm_clk_get(&pdev->dev, name);
+	if (IS_ERR(*clk)) {
+		dev_err(&pdev->dev, "Failed to get the clock.\n");
+		return -1;
+	}
+	ret = clk_prepare_enable(*clk);
+	if (ret) {
+		dev_err(&pdev->dev,
+			"Could not prepare or enable the clock.\n");
+		return -1;
+	}
+	/* enable clock */
+	ret = clk_enable(*clk);
+	if (ret) {
+		dev_err(&pdev->dev, "cannot enable clock\n");
+		return -1;
+	}
+	return 0;
+}
+
+static int sh_adc_iio_free_irqs(struct platform_device *pdev, int nres)
+{
+	struct iio_dev *idev = platform_get_drvdata(pdev);
+	struct resource *res;
+	int irq;
+
+	for (nres--; nres >= 0; nres--) {
+		res = platform_get_resource(pdev, IORESOURCE_IRQ, nres);
+		if (!res)
+			continue;
+		for (irq = res->start; irq <= res->end; irq++)
+			free_irq(irq, idev);
+	}
+	return 0;
+}
+
+static int sh_adc_probe(struct platform_device *pdev)
+{
+	struct iio_dev *idev;
+	struct sh_adc *adc;
+	struct resource *res;
+	struct iio_chan_spec *chan_array, *timestamp;
+	struct sh_adc_data *pdata = pdev->dev.platform_data;
+	int i, nmap, nres, irq = 0;
+	int ret = 0;
+
+	idev = iio_device_alloc(sizeof(*adc));
+	if (!idev)
+		return -ENOMEM;
+
+	adc = iio_priv(idev);
+	platform_set_drvdata(pdev, idev);
+
+	/* ADC base address */
+	nmap = 0;
+	res = platform_get_resource(pdev, IORESOURCE_MEM, nmap);
+	adc->reg = devm_request_and_ioremap(&pdev->dev, res);
+	if (!adc->reg)
+		goto error_map;
+	nmap++;
+	/* MTU2 base address */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, nmap);
+	adc->mtu2_share_reg = devm_request_and_ioremap(&pdev->dev, res);
+	if (!adc->mtu2_share_reg)
+		goto error_map;
+	nmap++;
+	res = platform_get_resource(pdev, IORESOURCE_MEM, nmap);
+	adc->mtu2_reg = devm_request_and_ioremap(&pdev->dev, res);
+	if (!adc->mtu2_reg)
+		goto error_map;
+	nmap++;
+
+	init_waitqueue_head(&adc->wq_data_avail);
+	mutex_init(&adc->lock);
+
+	idev->dev.parent = &pdev->dev;
+	idev->name = dev_name(&pdev->dev);
+	idev->modes = INDIO_DIRECT_MODE;
+	idev->info = &sh_adc_info;
+
+	/* channel setup */
+	idev->num_channels = pdata->num_channels;
+	chan_array = devm_kzalloc(&idev->dev,
+				  ((idev->num_channels + 1) *
+					sizeof(struct iio_chan_spec)),
+				  GFP_KERNEL);
+	if (!chan_array) {
+		ret = -ENOMEM;
+		goto error_map;
+	}
+	for (i = 0; i < pdata->num_channels; i++) {
+		struct iio_chan_spec *chan = chan_array + i;
+		chan->type = IIO_VOLTAGE;
+		chan->indexed = 1;
+		chan->channel = i;
+		chan->scan_index = i;
+		chan->scan_type.sign = 'u';
+		chan->scan_type.realbits = 12;
+		chan->scan_type.storagebits = 16;
+		chan->scan_type.shift = 4;
+		chan->info_mask = IIO_CHAN_INFO_SCALE_SHARED_BIT |
+				  IIO_CHAN_INFO_SAMP_FREQ_SHARED_BIT |
+				  IIO_CHAN_INFO_RAW_SEPARATE_BIT;
+	}
+	timestamp = chan_array + i;
+	timestamp->type = IIO_TIMESTAMP;
+	timestamp->channel = -1;
+	timestamp->scan_index = i;
+	timestamp->scan_type.sign = 's';
+	timestamp->scan_type.realbits = 64;
+	timestamp->scan_type.storagebits = 64;
+	idev->num_channels++;
+
+	idev->channels = chan_array;
+
+	/* request interrupt */
+	for (nres = 0; nres < pdev->num_resources; nres++) {
+		res = platform_get_resource(pdev, IORESOURCE_IRQ, nres);
+		if (!res)
+			continue;
+		for (irq = res->start; irq <= res->end; irq++) {
+			ret = request_irq(irq, sh_adc_irq, IRQF_DISABLED,
+					  idev->name, idev);
+			if (ret < 0) {
+				for (irq--; irq >= res->start; irq--)
+					free_irq(irq, idev);
+				goto error_free_irq;
+			}
+		}
+	}
+	sh_adc_set_bit(adc, SH_ADC_ADCSR_ADIE, SH_ADC_ADCSR);
+
+	/* get clock */
+	ret = sh_adc_get_clk(pdev, &adc->clk, "adc0");
+	if (ret < 0)
+		goto error_free_irq;
+	ret = sh_adc_get_clk(pdev, &adc->mtu2_clk, "mtu2_fck");
+	if (ret < 0)
+		goto error_mtu2_clk;
+
+	/* set buffer and regist the trigger */
+	iio_triggered_buffer_setup(idev, &iio_pollfunc_store_time,
+				 &sh_adc_trigger_handler, NULL);
+	sh_adc_trigger_init(idev);
+
+	/* register iio device */
+	ret = iio_device_register(idev);
+	if (ret) {
+		dev_err(&idev->dev, "Error: iio dev can't register(%d)\n", ret);
+		goto error_iio_dev_reg;
+	}
+
+	/* set convert rate */
+	sh_adc_set_bit(adc, SH_ADC_ADCSR_CKS_1054, SH_ADC_ADCSR);
+
+	dev_info(&pdev->dev, "version %s\n", DRIVER_VERSION);
+
+	/* initialize mtu2 as a ADC trigger */
+	adc->mtu2_ch = pdata->mtu2_ch;
+	sh_mtu2_enable(adc);
+
+	return 0;
+
+error_iio_dev_reg:
+	clk_disable(adc->mtu2_clk);
+	devm_clk_put(&pdev->dev, adc->mtu2_clk);
+error_mtu2_clk:
+	clk_disable(adc->clk);
+	devm_clk_put(&pdev->dev, adc->clk);
+error_free_irq:
+	sh_adc_iio_free_irqs(pdev, nres);
+error_map:
+	sh_adc_iio_map_unregister(pdev, adc, nmap);
+	iio_device_free(idev);
+	return ret;
+}
+
+static int sh_adc_remove(struct platform_device *pdev)
+{
+	struct iio_dev *idev = platform_get_drvdata(pdev);
+	struct sh_adc *adc = iio_priv(idev);
+
+	iio_device_unregister(idev);
+
+	clk_disable(adc->mtu2_clk);
+	devm_clk_put(&pdev->dev, adc->mtu2_clk);
+	clk_disable(adc->clk);
+	devm_clk_put(&pdev->dev, adc->clk);
+
+	sh_adc_iio_free_irqs(pdev, pdev->num_resources);
+	sh_adc_iio_map_unregister(pdev, adc, 3);
+	iio_device_free(idev);
+
+	return 0;
+}
+
+static struct platform_driver sh_adc_driver = {
+	.probe = sh_adc_probe,
+	.remove = sh_adc_remove,
+	.driver = {
+		.name = "sh_adc",
+		.owner = THIS_MODULE,
+	},
+};
+module_platform_driver(sh_adc_driver);
+
+MODULE_DESCRIPTION("SH ADC Driver");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:sh-adc");
diff --git a/drivers/mfd/Kconfig b/drivers/mfd/Kconfig
index ff553ba..5ec2d5b 100644
--- a/drivers/mfd/Kconfig
+++ b/drivers/mfd/Kconfig
@@ -1114,6 +1114,13 @@ config MFD_AS3711
 	help
 	  Support for the AS3711 PMIC from AMS
 
+config MFD_RAA730300
+	bool "RAA730300 Monolithic programable analog IC"
+	depends on SPI_MASTER && GPIOLIB
+	help
+	  Smart Analog(RAA730300) is a front-end cirtuit for small signal
+	  sensors.
+
 endmenu
 endif
 
diff --git a/drivers/mfd/Makefile b/drivers/mfd/Makefile
index 8b977f8..66443aa 100644
--- a/drivers/mfd/Makefile
+++ b/drivers/mfd/Makefile
@@ -148,3 +148,4 @@ obj-$(CONFIG_MFD_LM3533)	+= lm3533-core.o lm3533-ctrlbank.o
 obj-$(CONFIG_VEXPRESS_CONFIG)	+= vexpress-config.o vexpress-sysreg.o
 obj-$(CONFIG_MFD_RETU)		+= retu-mfd.o
 obj-$(CONFIG_MFD_AS3711)	+= as3711.o
+obj-$(CONFIG_MFD_RAA730300)	+= raa730300.o
diff --git a/drivers/mfd/raa730300.c b/drivers/mfd/raa730300.c
new file mode 100644
index 0000000..66901fa
--- /dev/null
+++ b/drivers/mfd/raa730300.c
@@ -0,0 +1,291 @@
+/*
+ * RZA1 RAA730300 Driver
+ *
+ * Copyright (C) 2013 Renesas Solutions Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+#include <linux/cdev.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+#include <linux/uaccess.h>
+
+#include <uapi/mfd/raa730300.h>
+
+#define DRIVER_NAME "raa730300"
+#define DEV_NAME "sma"
+
+static DEFINE_MUTEX(raa730300_mutex);
+
+struct raa730300_data {
+	struct spi_device	*spi;
+	struct cdev		cdev;
+	dev_t			dev;
+	int			offset;
+	struct class		*sm_class;
+	struct device		*sm_device;
+};
+
+
+static int raa730300_reg_write(struct spi_device *spi, char reg, char dat)
+{
+	char cmd[2];
+
+	if (reg == 0xa || reg < 0 || reg > 0x17)
+		return -1;
+
+	cmd[1] = dat;
+	cmd[0] = ((1 << 7) | reg);
+
+	return spi_write_then_read(spi, cmd, 2, NULL, 0);
+}
+
+static int raa730300_reg_read(struct spi_device *spi, char reg, char *dat)
+{
+	if (reg == 0xa || reg < 0 || reg > 0x17)
+		return -1;
+	return spi_write_then_read(spi, &reg, 1, dat, 1);
+}
+
+/* fops */
+int raa730300_open(struct inode *inode, struct file *file)
+{
+	struct raa730300_data *chip =
+		container_of(inode->i_cdev, struct raa730300_data, cdev);
+
+	file->private_data = chip;
+	return 0;
+}
+
+static long raa730300_unlocked_ioctl(struct file *file, unsigned int cmd,
+				     unsigned long arg)
+{
+	int i, ret, size, err;
+	struct sa_regs *sa;
+	struct raa730300_data *chip = file->private_data;
+
+	ret = -EINVAL;
+	err = copy_from_user((void *)&size, (void __user *)arg, sizeof(int));
+	if (err)
+		return -EFAULT;
+	size = sizeof(struct sa_regs);
+
+	sa = kmalloc(size, GFP_KERNEL);
+	if (!sa)
+		return -ENOMEM;
+
+	err = copy_from_user(sa, (void __user *)arg, size);
+	if (err) {
+		err = -EFAULT;
+		goto err;
+	}
+
+	mutex_lock(&raa730300_mutex);
+	switch (cmd) {
+	case RAA730300_IOCTL_REG_READ:
+		for (i = 0; i < sa->num; i++) {
+			ret = raa730300_reg_read(chip->spi,
+						  sa->regs[i].addr,
+						  &sa->regs[i].value);
+			if (ret < 0)
+				break;
+		}
+		err = copy_to_user((void __user *)arg, sa, sa->num
+				* sizeof(struct sa_reg)
+				+ sizeof(struct sa_regs));
+		if (err)
+			return -EFAULT;
+		break;
+
+	case RAA730300_IOCTL_REG_WRITE:
+		for (i = 0; i < sa->num; i++) {
+			ret = raa730300_reg_write(chip->spi,
+						  sa->regs[i].addr,
+						  sa->regs[i].value);
+			if (ret < 0)
+				break;
+		}
+		break;
+	default:
+		break;
+	}
+	mutex_unlock(&raa730300_mutex);
+
+err:
+	kfree(sa);
+	return ret;
+};
+
+static ssize_t raa730300_read(struct file *file, char __user *ubuf,
+			      size_t cnt, loff_t *ppos)
+{
+	int ret, bufsize;
+	char *pbuf, buf[RAA730300_NUM_OF_REGS * 2];
+	loff_t len, idx, nread;
+	struct raa730300_data *chip = file->private_data;
+	bufsize = RAA730300_NUM_OF_REGS * 2;
+
+	if (cnt < bufsize)
+		return -EIO;
+
+	idx = *ppos / 2;
+	if (idx < 0xa)
+		chip->offset = 0;
+
+	pbuf = buf;
+	len = idx + cnt / 2;
+
+	mutex_lock(&raa730300_mutex);
+	while (idx < len && idx < RAA730300_NUM_OF_REGS) {
+		/* The address 0xa register doesn't exist. */
+		if (idx >= 0xa && !chip->offset)
+			chip->offset = 1;
+
+		*pbuf = idx + chip->offset;
+		ret = raa730300_reg_read(chip->spi, idx + chip->offset,
+					pbuf + 1);
+		if (ret < 0)
+			break;
+		udelay(5);
+		idx++;
+		pbuf += 2;
+	}
+	idx *= 2;
+	nread = idx - *ppos;
+	ret = copy_to_user(ubuf, buf, nread);
+	if (ret)
+		return -EFAULT;
+	*ppos = idx;
+	mutex_unlock(&raa730300_mutex);
+
+	return nread;
+}
+
+static ssize_t raa730300_write(struct file *file, const char __user *ubuf,
+			       size_t cnt, loff_t *ppos)
+{
+	int ret, bufsize;
+	char *pbuf, buf[RAA730300_NUM_OF_REGS * 2];
+	loff_t len, idx, nwrite;
+	struct raa730300_data *chip = file->private_data;
+
+	idx = *ppos;
+	if (cnt % 2) /* must write [addr] + [reg data] */
+		return -EINVAL;
+
+	pbuf = buf;
+	bufsize = RAA730300_NUM_OF_REGS * 2;
+	if (cnt > bufsize)
+		cnt = bufsize;
+	ret = copy_from_user(buf, ubuf, cnt);
+	if (ret)
+		return -EFAULT;
+	len = idx + cnt;
+
+	mutex_lock(&raa730300_mutex);
+	while (idx < len && idx < bufsize) {
+		ret = raa730300_reg_write(chip->spi, *pbuf, *(pbuf + 1));
+		if (ret < 0)
+			break;
+		idx += 2;
+		pbuf += 2;
+	}
+	nwrite = idx - *ppos;
+	*ppos = idx;
+	mutex_unlock(&raa730300_mutex);
+
+	return nwrite;
+}
+
+static const struct file_operations raa730300_fops = {
+	.owner = THIS_MODULE,
+	.open = raa730300_open,
+	.unlocked_ioctl = raa730300_unlocked_ioctl,
+	.read = raa730300_read,
+	.write = raa730300_write,
+};
+
+static int raa730300_probe(struct spi_device *spi)
+{
+	struct sman_platform_data *pd;
+	struct raa730300_data *chip;
+	dev_t dev;
+	int ret = -EINVAL;
+
+	pd = spi->dev.platform_data;
+	if (!pd) {
+		dev_err(&spi->dev, "no platform data\n");
+		return ret;
+	}
+
+	chip = devm_kzalloc(&spi->dev, sizeof(*chip), GFP_KERNEL);
+	if (!chip)
+		return -ENOMEM;
+	chip->spi = spi;
+	chip->offset = 0;
+
+	spi_set_drvdata(spi, chip);
+
+	ret = alloc_chrdev_region(&dev, 0, 1, DRIVER_NAME);
+	if (ret < 0) {
+		dev_err(&spi->dev, "can't alloc chrdev_region.\n");
+		goto error1;
+	}
+	chip->dev = dev;
+	cdev_init(&chip->cdev, &raa730300_fops);
+	ret = cdev_add(&chip->cdev, MKDEV(MAJOR(dev), 0), 1);
+	if (ret < 0) {
+		dev_err(&spi->dev, "failed to cdev_add.\n");
+		goto error2;
+	}
+
+	chip->sm_class = class_create(THIS_MODULE, DEV_NAME);
+	chip->sm_device = device_create(chip->sm_class, NULL, dev, NULL,
+					DEV_NAME);
+	if (IS_ERR(chip->sm_device))
+		goto error3;
+
+	return 0;
+
+error3:
+	class_destroy(chip->sm_class);
+error2:
+	unregister_chrdev_region(chip->dev, 1);
+error1:
+	devm_kfree(&spi->dev, chip);
+	return ret;
+}
+
+static int raa730300_remove(struct spi_device *spi)
+{
+	struct raa730300_data *chip;
+	chip = spi_get_drvdata(spi);
+
+	device_destroy(chip->sm_class, chip->dev);
+	class_destroy(chip->sm_class);
+	cdev_del(&chip->cdev);
+	unregister_chrdev_region(chip->dev, 1);
+	devm_kfree(&spi->dev, chip);
+	return 0;
+}
+
+static struct spi_driver raa730300_driver = {
+	.driver = {
+		.name	= "raa730300",
+		.owner	= THIS_MODULE,
+	},
+	.probe		= raa730300_probe,
+	.remove		= raa730300_remove,
+};
+
+module_spi_driver(raa730300_driver);
diff --git a/drivers/mmc/host/Kconfig b/drivers/mmc/host/Kconfig
index 009dabd..88e6a67 100644
--- a/drivers/mmc/host/Kconfig
+++ b/drivers/mmc/host/Kconfig
@@ -449,6 +449,19 @@ config MMC_SDHI
 	  This provides support for the SDHI SD/SDIO controller found in
 	  SuperH and ARM SH-Mobile SoCs
 
+config MMC_GENMAI_SD_CARD_DETECT
+	bool "Apply detect process of SD card in GENMAI board."
+	depends on MACH_RSKRZA1 && MMC_SDHI
+	select RZA1_DMAE
+	default y
+	help
+	  This provides support for detect process of SD card in GENMAI board.
+	  If repair the board, you can select to N.
+	  In the repair board, even no repair board, there is no problem to 
+	  selection of Y.
+
+	  If unsure, say Y.
+	  
 config MMC_CB710
 	tristate "ENE CB710 MMC/SD Interface support"
 	depends on PCI
diff --git a/drivers/mmc/host/sh_mmcif.c b/drivers/mmc/host/sh_mmcif.c
index 9a4c151..f018361 100644
--- a/drivers/mmc/host/sh_mmcif.c
+++ b/drivers/mmc/host/sh_mmcif.c
@@ -1,7 +1,7 @@
 /*
  * MMCIF eMMC driver.
  *
- * Copyright (C) 2010 Renesas Solutions Corp.
+ * Copyright (C) 2010-2013 Renesas Solutions Corp.
  * Yusuke Goda <yusuke.goda.sx@renesas.com>
  *
  * This program is free software; you can redistribute it and/or modify
@@ -62,6 +62,15 @@
 #include <linux/pm_runtime.h>
 #include <linux/spinlock.h>
 #include <linux/module.h>
+#ifdef CONFIG_RZA1_DMAE
+#include <linux/platform_data/dma-rza1.h>
+#endif
+
+#ifdef CONFIG_RZA1_DMAE
+#define sh_mmcif_mmc_filter	rza1dma_chan_filter
+#else
+#define sh_mmcif_mmc_filter	shdma_chan_filter
+#endif
 
 #define DRIVER_NAME	"sh_mmcif"
 #define DRIVER_VERSION	"2010-04-28"
@@ -391,7 +400,7 @@ static void sh_mmcif_request_dma(struct sh_mmcif_host *host,
 	dma_cap_zero(mask);
 	dma_cap_set(DMA_SLAVE, mask);
 
-	host->chan_tx = dma_request_channel(mask, shdma_chan_filter,
+	host->chan_tx = dma_request_channel(mask, sh_mmcif_mmc_filter,
 					    (void *)pdata->slave_id_tx);
 	dev_dbg(&host->pd->dev, "%s: TX: got channel %p\n", __func__,
 		host->chan_tx);
@@ -407,7 +416,7 @@ static void sh_mmcif_request_dma(struct sh_mmcif_host *host,
 	if (ret < 0)
 		goto ecfgtx;
 
-	host->chan_rx = dma_request_channel(mask, shdma_chan_filter,
+	host->chan_rx = dma_request_channel(mask, sh_mmcif_mmc_filter,
 					    (void *)pdata->slave_id_rx);
 	dev_dbg(&host->pd->dev, "%s: RX: got channel %p\n", __func__,
 		host->chan_rx);
diff --git a/drivers/mmc/host/tmio_mmc.h b/drivers/mmc/host/tmio_mmc.h
index d857f5c..6a0167e 100644
--- a/drivers/mmc/host/tmio_mmc.h
+++ b/drivers/mmc/host/tmio_mmc.h
@@ -1,6 +1,7 @@
 /*
  * linux/drivers/mmc/host/tmio_mmc.h
  *
+ * Copyright (C) 2013 Renesas Solutions Corp.
  * Copyright (C) 2007 Ian Molton
  * Copyright (C) 2004 Ian Molton
  *
@@ -34,8 +35,15 @@
 #define TMIO_MASK_ALL           0x837f031d
 #define TMIO_MASK_READOP  (TMIO_STAT_RXRDY | TMIO_STAT_DATAEND)
 #define TMIO_MASK_WRITEOP (TMIO_STAT_TXRQ | TMIO_STAT_DATAEND)
+#ifdef CONFIG_MMC_GENMAI_SD_CARD_DETECT
 #define TMIO_MASK_CMD     (TMIO_STAT_CMDRESPEND | TMIO_STAT_CMDTIMEOUT | \
+		TMIO_STAT_STOPBIT_ERR | \
 		TMIO_STAT_CARD_REMOVE | TMIO_STAT_CARD_INSERT)
+#else
+#define TMIO_MASK_CMD     (TMIO_STAT_CMDRESPEND | TMIO_STAT_CMDTIMEOUT | \
+		TMIO_STAT_CARD_REMOVE | TMIO_STAT_CARD_INSERT)
+#endif
+
 #define TMIO_MASK_IRQ     (TMIO_MASK_READOP | TMIO_MASK_WRITEOP | TMIO_MASK_CMD)
 
 struct tmio_mmc_data;
diff --git a/drivers/mmc/host/tmio_mmc_pio.c b/drivers/mmc/host/tmio_mmc_pio.c
index 50bf495..5d4fd7e 100644
--- a/drivers/mmc/host/tmio_mmc_pio.c
+++ b/drivers/mmc/host/tmio_mmc_pio.c
@@ -1,6 +1,7 @@
 /*
  * linux/drivers/mmc/host/tmio_mmc_pio.c
  *
+ * Copyright (C) 2013 Renesas Solutions Corp.
  * Copyright (C) 2011 Guennadi Liakhovetski
  * Copyright (C) 2007 Ian Molton
  * Copyright (C) 2004 Ian Molton
@@ -524,10 +525,17 @@ static void tmio_mmc_cmd_irq(struct tmio_mmc_host *host,
 		cmd->resp[0] = cmd->resp[3];
 	}
 
+#ifdef CONFIG_MMC_GENMAI_SD_CARD_DETECT
+	if (stat & (TMIO_STAT_CMDTIMEOUT | TMIO_STAT_STOPBIT_ERR))
+		cmd->error = -ETIMEDOUT;
+	else if (stat & TMIO_STAT_CRCFAIL && cmd->flags & MMC_RSP_CRC)
+		cmd->error = -EILSEQ;
+#else
 	if (stat & TMIO_STAT_CMDTIMEOUT)
 		cmd->error = -ETIMEDOUT;
 	else if (stat & TMIO_STAT_CRCFAIL && cmd->flags & MMC_RSP_CRC)
 		cmd->error = -EILSEQ;
+#endif
 
 	/* If there is data to handle we enable data IRQs here, and
 	 * we will ultimatley finish the request in the data_end handler.
@@ -598,13 +606,24 @@ static bool __tmio_mmc_sdcard_irq(struct tmio_mmc_host *host,
 				 int ireg, int status)
 {
 	/* Command completion */
+#ifdef CONFIG_MMC_GENMAI_SD_CARD_DETECT
+	if (ireg & (TMIO_STAT_CMDRESPEND | TMIO_STAT_CMDTIMEOUT | 
+				TMIO_STAT_STOPBIT_ERR)) {
+		tmio_mmc_ack_mmc_irqs(host,
+				 TMIO_STAT_CMDRESPEND | TMIO_STAT_CMDTIMEOUT |
+			     TMIO_STAT_STOPBIT_ERR);
+		tmio_mmc_cmd_irq(host, status);
+		return true;
+	}
+#else
 	if (ireg & (TMIO_STAT_CMDRESPEND | TMIO_STAT_CMDTIMEOUT)) {
 		tmio_mmc_ack_mmc_irqs(host,
-			     TMIO_STAT_CMDRESPEND |
+				 TMIO_STAT_CMDRESPEND |
 			     TMIO_STAT_CMDTIMEOUT);
 		tmio_mmc_cmd_irq(host, status);
 		return true;
 	}
+#endif
 
 	/* Data transfer */
 	if (ireg & (TMIO_STAT_RXRDY | TMIO_STAT_TXRQ)) {
diff --git a/drivers/net/ethernet/renesas/Kconfig b/drivers/net/ethernet/renesas/Kconfig
index 24c2305..103ecad 100644
--- a/drivers/net/ethernet/renesas/Kconfig
+++ b/drivers/net/ethernet/renesas/Kconfig
@@ -8,7 +8,7 @@ config SH_ETH
 		(CPU_SUBTYPE_SH7710 || CPU_SUBTYPE_SH7712 || \
 		 CPU_SUBTYPE_SH7763 || CPU_SUBTYPE_SH7619 || \
 		 CPU_SUBTYPE_SH7724 || CPU_SUBTYPE_SH7734 || \
-		 CPU_SUBTYPE_SH7757 || ARCH_R8A7740 || ARCH_R8A7779)
+		 CPU_SUBTYPE_SH7757 || ARCH_R8A7740 || ARCH_R8A7779 || ARCH_RZA1)
 	select CRC32
 	select NET_CORE
 	select MII
diff --git a/drivers/net/ethernet/renesas/sh_eth.c b/drivers/net/ethernet/renesas/sh_eth.c
index 3d70586..1d6987b 100644
--- a/drivers/net/ethernet/renesas/sh_eth.c
+++ b/drivers/net/ethernet/renesas/sh_eth.c
@@ -2,7 +2,7 @@
  *  SuperH Ethernet device driver
  *
  *  Copyright (C) 2006-2012 Nobuhiro Iwamatsu
- *  Copyright (C) 2008-2012 Renesas Solutions Corp.
+ *  Copyright (C) 2008-2013 Renesas Solutions Corp.
  *
  *  This program is free software; you can redistribute it and/or modify it
  *  under the terms and conditions of the GNU General Public License,
@@ -78,8 +78,39 @@ static void sh_eth_select_mii(struct net_device *ndev)
 #endif
 
 /* There is CPU dependent code */
-#if defined(CONFIG_CPU_SUBTYPE_SH7724) || defined(CONFIG_ARCH_R8A7779)
-#define SH_ETH_RESET_DEFAULT	1
+#if defined(CONFIG_CPU_SUBTYPE_SH7724) || defined(CONFIG_ARCH_R8A7779) || \
+	defined(CONFIG_ARCH_RZA1)
+#if !defined(CONFIG_ARCH_RZA1)
+#  define SH_ETH_RESET_DEFAULT	1
+#else
+static int sh_eth_check_reset(struct net_device *ndev);
+
+static int sh_eth_reset(struct net_device *ndev)
+{
+	int ret = 0;
+
+	sh_eth_write(ndev, EDSR_ENALL, EDSR);
+	sh_eth_write(ndev, sh_eth_read(ndev, EDMR) | EDMR_SRST_GETHER, EDMR);
+
+	ret = sh_eth_check_reset(ndev);
+	if (ret)
+		goto out;
+
+	/* Table Init */
+	sh_eth_write(ndev, 0x0, TDLAR);
+	sh_eth_write(ndev, 0x0, TDFAR);
+	sh_eth_write(ndev, 0x0, TDFXR);
+	sh_eth_write(ndev, 0x0, TDFFR);
+	sh_eth_write(ndev, 0x0, RDLAR);
+	sh_eth_write(ndev, 0x0, RDFAR);
+	sh_eth_write(ndev, 0x0, RDFXR);
+	sh_eth_write(ndev, 0x0, RDFFR);
+
+out:
+	return ret;
+}
+
+#endif
 static void sh_eth_set_duplex(struct net_device *ndev)
 {
 	struct sh_eth_private *mdp = netdev_priv(ndev);
@@ -111,6 +142,30 @@ static void sh_eth_set_rate(struct net_device *ndev)
 	}
 }
 
+#if defined(CONFIG_ARCH_RZA1)
+/* RZA1H */
+static struct sh_eth_cpu_data sh_eth_my_cpu_data = {
+	.set_duplex	= sh_eth_set_duplex,
+	.set_rate	= sh_eth_set_rate,
+
+	.ecsr_value	= ECSR_PSRTO | ECSR_ICD,
+	.ecsipr_value	= ECSIPR_PSRTOIP | ECSIPR_ICDIP,
+	.eesipr_value	= DMAC_M_RFRMER | DMAC_M_ECI | 0x017f009f,
+	.rmcr_value = 0x00000001,
+
+	.tx_check	= EESR_FTC ,
+	.eesr_err_check	= EESR_TWB | EESR_TABT | EESR_RABT | EESR_RDE |
+			  EESR_RFRMER | EESR_TFE | EESR_TDE | EESR_ECI,
+	.tx_error_check	= EESR_TWB | EESR_TABT | EESR_TDE | EESR_TFE,
+
+	.apr		= 1,
+	.mpr		= 1,
+	.tpauser	= 1,
+	.hw_swap	= 1,
+	.rpadir		= 1,
+	.rpadir_value	= 0x00020000, /* NET_IP_ALIGN assumed to be 2 */
+};
+#else
 /* SH7724 */
 static struct sh_eth_cpu_data sh_eth_my_cpu_data = {
 	.set_duplex	= sh_eth_set_duplex,
@@ -132,6 +187,8 @@ static struct sh_eth_cpu_data sh_eth_my_cpu_data = {
 	.rpadir		= 1,
 	.rpadir_value	= 0x00020000, /* NET_IP_ALIGN assumed to be 2 */
 };
+#endif /* CONFIG_ARCH_RZA1 */
+
 #elif defined(CONFIG_CPU_SUBTYPE_SH7757)
 #define SH_ETH_HAS_BOTH_MODULES	1
 #define SH_ETH_HAS_TSU	1
@@ -1102,7 +1159,7 @@ static int sh_eth_rx(struct net_device *ndev, u32 intr_status)
 		desc_status = edmac_to_cpu(mdp, rxdesc->status);
 		pkt_len = rxdesc->frame_length;
 
-#if defined(CONFIG_ARCH_R8A7740)
+#if defined(CONFIG_ARCH_R8A7740) || defined(CONFIG_ARCH_RZA1)
 		desc_status >>= 16;
 #endif
 
diff --git a/drivers/net/ethernet/renesas/sh_eth.h b/drivers/net/ethernet/renesas/sh_eth.h
index bae84fd..d8b089e 100644
--- a/drivers/net/ethernet/renesas/sh_eth.h
+++ b/drivers/net/ethernet/renesas/sh_eth.h
@@ -2,7 +2,7 @@
  *  SuperH Ethernet device driver
  *
  *  Copyright (C) 2006-2012 Nobuhiro Iwamatsu
- *  Copyright (C) 2008-2012 Renesas Solutions Corp.
+ *  Copyright (C) 2008-2013 Renesas Solutions Corp.
  *
  *  This program is free software; you can redistribute it and/or modify it
  *  under the terms and conditions of the GNU General Public License,
@@ -386,7 +386,7 @@ static const u16 sh_eth_offset_fast_sh3_sh2[SH_ETH_MAX_REGISTER_OFFSET] = {
  * Register's bits
  */
 #if defined(CONFIG_CPU_SUBTYPE_SH7734) || defined(CONFIG_CPU_SUBTYPE_SH7763) ||\
-    defined(CONFIG_ARCH_R8A7740)
+    defined(CONFIG_ARCH_R8A7740) || defined(CONFIG_ARCH_RZA1)
 /* EDSR */
 enum EDSR_BIT {
 	EDSR_ENT = 0x01, EDSR_ENR = 0x02,
diff --git a/drivers/rtc/Kconfig b/drivers/rtc/Kconfig
index 923a9da..9637afa 100644
--- a/drivers/rtc/Kconfig
+++ b/drivers/rtc/Kconfig
@@ -857,7 +857,7 @@ config RTC_DRV_SA1100
 
 config RTC_DRV_SH
 	tristate "SuperH On-Chip RTC"
-	depends on SUPERH && HAVE_CLK
+	depends on (SUPERH || ARCH_SHMOBILE) && HAVE_CLK
 	help
 	  Say Y here to enable support for the on-chip RTC found in
 	  most SuperH processors.
diff --git a/drivers/rtc/rtc-sh.c b/drivers/rtc/rtc-sh.c
index e55a763..ee5d26b 100644
--- a/drivers/rtc/rtc-sh.c
+++ b/drivers/rtc/rtc-sh.c
@@ -1,6 +1,7 @@
 /*
  * SuperH On-Chip RTC Support
  *
+ * Copyright (C) 2013 Renesas Solutions Corp.
  * Copyright (C) 2006 - 2009  Paul Mundt
  * Copyright (C) 2006  Jamie Lenehan
  * Copyright (C) 2008  Angelo Castello
@@ -27,7 +28,11 @@
 #include <linux/log2.h>
 #include <linux/clk.h>
 #include <linux/slab.h>
+#ifdef CONFIG_ARCH_SHMOBILE
+#include <mach/rtc.h>
+#else
 #include <asm/rtc.h>
+#endif
 
 #define DRV_NAME	"sh-rtc"
 #define DRV_VERSION	"0.2.3"
@@ -592,6 +597,7 @@ static int __init sh_rtc_probe(struct platform_device *pdev)
 	struct rtc_time r;
 	char clk_name[6];
 	int clk_id, ret;
+	unsigned int tmp;
 
 	rtc = kzalloc(sizeof(struct sh_rtc), GFP_KERNEL);
 	if (unlikely(!rtc))
@@ -611,10 +617,18 @@ static int __init sh_rtc_probe(struct platform_device *pdev)
 	rtc->carry_irq = platform_get_irq(pdev, 1);
 	rtc->alarm_irq = platform_get_irq(pdev, 2);
 
+#ifdef CONFIG_ARCH_SHMOBILE
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+#else
 	res = platform_get_resource(pdev, IORESOURCE_IO, 0);
+#endif
 	if (unlikely(res == NULL)) {
 		ret = -ENOENT;
+#ifdef CONFIG_ARCH_SHMOBILE
+		dev_err(&pdev->dev, "No MEM resource\n");
+#else
 		dev_err(&pdev->dev, "No IO resource\n");
+#endif
 		goto err_badres;
 	}
 
@@ -651,6 +665,10 @@ static int __init sh_rtc_probe(struct platform_device *pdev)
 	}
 
 	clk_enable(rtc->clk);
+	/* Start RTC */
+	tmp = readb(rtc->regbase + RCR2);
+	tmp |= RCR2_RTCEN ;				
+	writeb(tmp, rtc->regbase + RCR2);
 
 	rtc->capabilities = RTC_DEF_CAPABILITIES;
 	if (pdev->dev.platform_data) {
@@ -731,11 +749,22 @@ static int __init sh_rtc_probe(struct platform_device *pdev)
 		rtc_time_to_tm(0, &r);
 		rtc_set_time(rtc->rtc_dev, &r);
 	}
+	
+	tmp = readb(rtc->regbase + RCR2);
+	if( ( tmp & RCR2_START) == 0) {
+		tmp |= RCR2_START;
+		writeb(tmp, rtc->regbase + RCR2);
+	}
 
 	device_init_wakeup(&pdev->dev, 1);
+
 	return 0;
 
 err_unmap:
+	/* STOP RTC */
+	tmp = readb(rtc->regbase + RCR2);
+	tmp &= ~RCR2_RTCEN;				
+	writeb(tmp, rtc->regbase + RCR2);
 	clk_disable(rtc->clk);
 	clk_put(rtc->clk);
 	iounmap(rtc->regbase);
@@ -749,6 +778,7 @@ err_badres:
 
 static int __exit sh_rtc_remove(struct platform_device *pdev)
 {
+	unsigned int tmp;
 	struct sh_rtc *rtc = platform_get_drvdata(pdev);
 
 	rtc_device_unregister(rtc->rtc_dev);
@@ -764,9 +794,13 @@ static int __exit sh_rtc_remove(struct platform_device *pdev)
 		free_irq(rtc->alarm_irq, rtc);
 	}
 
+	/* STOP RTC */
+	tmp = readb(rtc->regbase + RCR2);
+	tmp &= ~RCR2_RTCEN;				
+	writeb(tmp, rtc->regbase + RCR2);
+
 	iounmap(rtc->regbase);
 	release_mem_region(rtc->res->start, rtc->regsize);
-
 	clk_disable(rtc->clk);
 	clk_put(rtc->clk);
 
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index 2e188e1..d7112e1 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -311,10 +311,16 @@ config SPI_PXA2XX_PCI
 
 config SPI_RSPI
 	tristate "Renesas RSPI controller"
-	depends on SUPERH
+	depends on (SUPERH || ARCH_RZA1)
 	help
 	  SPI driver for Renesas RSPI blocks.
 
+config SPI_SH_SPIBSC
+	tristate "Renesas SPIBSC controller for RZA1"
+	depends on ARCH_RZA1
+	help
+	  SPIBSC driver for Renesas SPIBSC blocks.
+
 config SPI_S3C24XX
 	tristate "Samsung S3C24XX series SPI"
 	depends on ARCH_S3C24XX && EXPERIMENTAL
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index 64e970b..150c6fd 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -50,6 +50,7 @@ obj-$(CONFIG_SPI_PPC4xx)		+= spi-ppc4xx.o
 obj-$(CONFIG_SPI_PXA2XX)		+= spi-pxa2xx.o
 obj-$(CONFIG_SPI_PXA2XX_PCI)		+= spi-pxa2xx-pci.o
 obj-$(CONFIG_SPI_RSPI)			+= spi-rspi.o
+obj-$(CONFIG_SPI_SH_SPIBSC)		+= spi-sh-spibsc.o
 obj-$(CONFIG_SPI_S3C24XX)		+= spi-s3c24xx-hw.o
 spi-s3c24xx-hw-y			:= spi-s3c24xx.o
 spi-s3c24xx-hw-$(CONFIG_SPI_S3C24XX_FIQ) += spi-s3c24xx-fiq.o
diff --git a/drivers/spi/spi-rspi.c b/drivers/spi/spi-rspi.c
index 902f2fb..23aea6d 100644
--- a/drivers/spi/spi-rspi.c
+++ b/drivers/spi/spi-rspi.c
@@ -1,10 +1,9 @@
 /*
  * SH RSPI driver
  *
- * Copyright (C) 2012  Renesas Solutions Corp.
+ * Copyright (C) 2011-2013  Renesas Solutions Corp.
  *
  * Based on spi-sh.c:
- * Copyright (C) 2011 Renesas Solutions Corp.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -58,6 +57,8 @@
 #define RSPI_SPCMD5		0x1a
 #define RSPI_SPCMD6		0x1c
 #define RSPI_SPCMD7		0x1e
+#define RSPI_SPBFCR		0x20
+#define RSPI_SPBFDR		0x22
 
 /* SPCR */
 #define SPCR_SPRIE		0x80
@@ -82,6 +83,7 @@
 
 /* SPSR */
 #define SPSR_SPRF		0x80
+#define SPSR_SPTE		0x40
 #define SPSR_SPTEF		0x20
 #define SPSR_PERF		0x08
 #define SPSR_MODF		0x04
@@ -96,7 +98,12 @@
 #define SPSSR_SPCP_MASK		0x07
 
 /* SPDCR */
-#define SPDCR_SPLW		0x20
+#define SPDCR_TXDMY		0x80
+#define SPDCR_SPLLWORD		(SPDCR_SPLW1 | SPDCR_SPLW0)
+#define SPDCR_SPLWORD		SPDCR_SPLW1
+#define SPDCR_SPLBYTE		SPDCR_SPLW0
+#define SPDCR_SPLW1		0x40
+#define SPDCR_SPLW0		0x20
 #define SPDCR_SPRDTD		0x10
 #define SPDCR_SLSEL1		0x08
 #define SPDCR_SLSEL0		0x04
@@ -135,6 +142,20 @@
 #define SPCMD_CPOL		0x0002
 #define SPCMD_CPHA		0x0001
 
+/* SPBFCR */
+#define SPBFCR_TXRST		0x0080
+#define SPBFCR_RXRST		0x0040
+
+/* SPBFDR */
+#define SPBFDR_RMASK		0x003f
+#define SPBFDR_TMASK		0x0f00
+
+#define DUMMY_DATA		0x00
+#define NUM_IRQ			3
+#define DRIVER_NAME		"sh_rspi"
+#define DRIVER_NAME_SIZE	16
+static char drv_name[16][NUM_IRQ][DRIVER_NAME_SIZE];
+
 struct rspi_data {
 	void __iomem *addr;
 	u32 max_speed_hz;
@@ -145,11 +166,22 @@ struct rspi_data {
 	spinlock_t lock;
 	struct clk *clk;
 	unsigned char spsr;
+	unsigned char sppcr;
+	unsigned char spdcr;
+	u16 spcmd;
+	u8 clk_delay;
+	u8 cs_negate_delay;
+	u8 next_access_delay;
+	u8 data_width;
+	u8 data_width_regval;
+	bool txmode;
+	bool spcr;
+	int irq[NUM_IRQ];
+	int irqn;
 
 	/* for dmaengine */
 	struct dma_chan *chan_tx;
 	struct dma_chan *chan_rx;
-	int irq;
 
 	unsigned dma_width_16bit:1;
 	unsigned dma_callbacked:1;
@@ -175,6 +207,24 @@ static u16 rspi_read16(struct rspi_data *rspi, u16 offset)
 	return ioread16(rspi->addr + offset);
 }
 
+static void rspi_write_data(struct rspi_data *rspi, u16 data)
+{
+	if (rspi->data_width == 8)
+		rspi_write8(rspi, (u8)data, RSPI_SPDR);
+	else if (rspi->data_width == 16)
+		rspi_write16(rspi, data, RSPI_SPDR);
+}
+
+static u16 rspi_read_data(struct rspi_data *rspi)
+{
+	if (rspi->data_width == 8)
+		return rspi_read8(rspi, RSPI_SPDR);
+	else if (rspi->data_width == 16)
+		return rspi_read16(rspi, RSPI_SPDR);
+	else
+		return 0;
+}
+
 static unsigned char rspi_calc_spbr(struct rspi_data *rspi)
 {
 	int tmp;
@@ -185,6 +235,16 @@ static unsigned char rspi_calc_spbr(struct rspi_data *rspi)
 
 	return spbr;
 }
+static void rspi_clear_rxbuf( struct rspi_data *rspi )
+{
+	rspi_write8(rspi, rspi_read8(rspi, RSPI_SPBFCR) |   SPBFCR_RXRST,  RSPI_SPBFCR);
+	rspi_write8(rspi, rspi_read8(rspi, RSPI_SPBFCR) & (~SPBFCR_RXRST), RSPI_SPBFCR);
+}
+static void rspi_clear_txbuf( struct rspi_data *rspi )
+{
+	rspi_write8(rspi, rspi_read8(rspi, RSPI_SPBFCR) |   SPBFCR_TXRST,  RSPI_SPBFCR);
+	rspi_write8(rspi, rspi_read8(rspi, RSPI_SPBFCR) & (~SPBFCR_TXRST), RSPI_SPBFCR);
+}
 
 static void rspi_enable_irq(struct rspi_data *rspi, u8 enable)
 {
@@ -220,27 +280,67 @@ static void rspi_negate_ssl(struct rspi_data *rspi)
 	rspi_write8(rspi, rspi_read8(rspi, RSPI_SPCR) & ~SPCR_SPE, RSPI_SPCR);
 }
 
+static void rspi_set_txmode(struct rspi_data *rspi)
+{
+	if (rspi->txmode)
+		rspi_write8(rspi, rspi_read8(rspi, RSPI_SPCR) | SPCR_TXMD,
+				RSPI_SPCR);
+}
+
+static void rspi_clear_txmode(struct rspi_data *rspi)
+{
+	if (rspi->txmode)
+		rspi_write8(rspi, rspi_read8(rspi, RSPI_SPCR) & ~SPCR_TXMD,
+				RSPI_SPCR);
+}
+
+static int rspi_setup_data_register_width(struct rspi_data *rspi,
+				      struct platform_device *pdev)
+{
+	struct rspi_plat_data *rspi_pd = pdev->dev.platform_data;
+
+	if (rspi_pd && rspi_pd->data_width) {
+		rspi->data_width = rspi_pd->data_width;
+		/* This version driver supports only 8bits width */
+		if (rspi_pd->data_width == 8) {
+			rspi->data_width_regval = SPDCR_SPLBYTE;
+			return 0;
+		} else {
+			return -1;
+		}
+		rspi->data_width_regval = 0;
+	} else {
+		/* Use 16bits width data access if a data_width value isn't */
+		/* defined in a platform data. */
+		rspi->data_width = 16;
+		rspi->data_width_regval = 0;
+	}
+
+	return 0;
+}
+
 static int rspi_set_config_register(struct rspi_data *rspi, int access_size)
 {
 	/* Sets output mode(CMOS) and MOSI signal(from previous transfer) */
-	rspi_write8(rspi, 0x00, RSPI_SPPCR);
+	rspi_write8(rspi, rspi->sppcr, RSPI_SPPCR);
 
 	/* Sets transfer bit rate */
 	rspi_write8(rspi, rspi_calc_spbr(rspi), RSPI_SPBR);
 
 	/* Sets number of frames to be used: 1 frame */
-	rspi_write8(rspi, 0x00, RSPI_SPDCR);
+	rspi_write8(rspi, rspi->spdcr, RSPI_SPDCR);
 
-	/* Sets RSPCK, SSL, next-access delay value */
-	rspi_write8(rspi, 0x00, RSPI_SPCKD);
-	rspi_write8(rspi, 0x00, RSPI_SSLND);
-	rspi_write8(rspi, 0x00, RSPI_SPND);
+	/* Sets delays for RSPCK, SSL negate and next-access */
+	rspi_write8(rspi, rspi->clk_delay, RSPI_SPCKD);
+	rspi_write8(rspi, rspi->cs_negate_delay, RSPI_SSLND);
+	rspi_write8(rspi, rspi->next_access_delay, RSPI_SPND);
 
 	/* Sets parity, interrupt mask */
-	rspi_write8(rspi, 0x00, RSPI_SPCR2);
+	if (rspi->spcr)
+		rspi_write8(rspi, 0x00, RSPI_SPCR2);
 
 	/* Sets SPCMD */
-	rspi_write16(rspi, SPCMD_SPB_8_TO_16(access_size) | SPCMD_SSLKP,
+	rspi_write16(rspi, SPCMD_SPB_8_TO_16(access_size) | rspi->spcmd,
 		     RSPI_SPCMD0);
 
 	/* Sets RSPI mode */
@@ -255,18 +355,28 @@ static int rspi_send_pio(struct rspi_data *rspi, struct spi_message *mesg,
 	int remain = t->len;
 	u8 *data;
 
+	if( rspi->sppcr & SPPCR_SPLP ) {
+		/* loop back mode */
+		rspi_clear_txbuf(rspi);
+		rspi_clear_rxbuf(rspi);
+	}
+
 	data = (u8 *)t->tx_buf;
 	while (remain > 0) {
-		rspi_write8(rspi, rspi_read8(rspi, RSPI_SPCR) | SPCR_TXMD,
-			    RSPI_SPCR);
+		rspi_set_txmode(rspi);
 
 		if (rspi_wait_for_interrupt(rspi, SPSR_SPTEF, SPCR_SPTIE) < 0) {
 			dev_err(&rspi->master->dev,
 				"%s: tx empty timeout\n", __func__);
 			return -ETIMEDOUT;
 		}
-
-		rspi_write16(rspi, *data, RSPI_SPDR);
+		if (!rspi->txmode && remain != t->len) {
+			if( !(rspi->sppcr & SPPCR_SPLP) ) {
+				rspi_wait_for_interrupt(rspi, SPSR_SPRF, SPCR_SPRIE);
+				rspi_read_data(rspi); /* dummy read */
+			}
+		}
+		rspi_write_data(rspi, *data);
 		data++;
 		remain--;
 	}
@@ -274,6 +384,16 @@ static int rspi_send_pio(struct rspi_data *rspi, struct spi_message *mesg,
 	/* Waiting for the last transmition */
 	rspi_wait_for_interrupt(rspi, SPSR_SPTEF, SPCR_SPTIE);
 
+	if (rspi_wait_for_interrupt(rspi, SPSR_SPRF, SPCR_SPRIE) < 0) {
+		dev_err(&rspi->master->dev,
+			"%s: receive timeout\n", __func__);
+		return -ETIMEDOUT;
+	}
+	if (!rspi->txmode) {
+		if( !(rspi->sppcr & SPPCR_SPLP) )
+			rspi_read_data(rspi); /* dummy read */
+	}
+
 	return 0;
 }
 
@@ -329,7 +449,7 @@ static int rspi_send_dma(struct rspi_data *rspi, struct spi_transfer *t)
 	void *buf = NULL;
 	struct dma_async_tx_descriptor *desc;
 	unsigned len;
-	int ret = 0;
+	int i, ret = 0;
 
 	if (rspi->dma_width_16bit) {
 		/*
@@ -364,9 +484,10 @@ static int rspi_send_dma(struct rspi_data *rspi, struct spi_transfer *t)
 	 * DMAC needs SPTIE, but if SPTIE is set, this IRQ routine will be
 	 * called. So, this driver disables the IRQ while DMA transfer.
 	 */
-	disable_irq(rspi->irq);
+	for (i = 0; i < rspi->irqn; i++)
+		disable_irq(rspi->irq[i]);
 
-	rspi_write8(rspi, rspi_read8(rspi, RSPI_SPCR) | SPCR_TXMD, RSPI_SPCR);
+	rspi_set_txmode(rspi);
 	rspi_enable_irq(rspi, SPCR_SPTIE);
 	rspi->dma_callbacked = 0;
 
@@ -383,7 +504,8 @@ static int rspi_send_dma(struct rspi_data *rspi, struct spi_transfer *t)
 		ret = -ETIMEDOUT;
 	rspi_disable_irq(rspi, SPCR_SPTIE);
 
-	enable_irq(rspi->irq);
+	for (i = 0; i < rspi->irqn; i++)
+		enable_irq(rspi->irq[i]);
 
 end:
 	rspi_dma_unmap_sg(&sg, rspi->chan_tx, DMA_TO_DEVICE);
@@ -399,11 +521,12 @@ static void rspi_receive_init(struct rspi_data *rspi)
 	unsigned char spsr;
 
 	spsr = rspi_read8(rspi, RSPI_SPSR);
-	if (spsr & SPSR_SPRF)
-		rspi_read16(rspi, RSPI_SPDR);	/* dummy read */
+	if( (spsr & SPSR_SPRF) && !(rspi->sppcr & SPPCR_SPLP) )
+		rspi_read_data(rspi); /* dummy read */
+
 	if (spsr & SPSR_OVRF)
 		rspi_write8(rspi, rspi_read8(rspi, RSPI_SPSR) & ~SPSR_OVRF,
-			    RSPI_SPCR);
+			    RSPI_SPSR);
 }
 
 static int rspi_receive_pio(struct rspi_data *rspi, struct spi_message *mesg,
@@ -416,8 +539,7 @@ static int rspi_receive_pio(struct rspi_data *rspi, struct spi_message *mesg,
 
 	data = (u8 *)t->rx_buf;
 	while (remain > 0) {
-		rspi_write8(rspi, rspi_read8(rspi, RSPI_SPCR) & ~SPCR_TXMD,
-			    RSPI_SPCR);
+		rspi_clear_txmode(rspi);
 
 		if (rspi_wait_for_interrupt(rspi, SPSR_SPTEF, SPCR_SPTIE) < 0) {
 			dev_err(&rspi->master->dev,
@@ -425,19 +547,22 @@ static int rspi_receive_pio(struct rspi_data *rspi, struct spi_message *mesg,
 			return -ETIMEDOUT;
 		}
 		/* dummy write for generate clock */
-		rspi_write16(rspi, 0x00, RSPI_SPDR);
+		rspi_write_data(rspi, DUMMY_DATA);
 
 		if (rspi_wait_for_interrupt(rspi, SPSR_SPRF, SPCR_SPRIE) < 0) {
 			dev_err(&rspi->master->dev,
 				"%s: receive timeout\n", __func__);
 			return -ETIMEDOUT;
 		}
-		/* SPDR allows 16 or 32-bit access only */
-		*data = (u8)rspi_read16(rspi, RSPI_SPDR);
-
+		*data = (u8)rspi_read_data(rspi);
 		data++;
 		remain--;
 	}
+	if( rspi->sppcr & SPPCR_SPLP ) {
+		/* loop back mode */
+		rspi_clear_txbuf(rspi);
+		rspi_clear_rxbuf(rspi);
+	}
 
 	return 0;
 }
@@ -448,7 +573,7 @@ static int rspi_receive_dma(struct rspi_data *rspi, struct spi_transfer *t)
 	void *dummy = NULL, *rx_buf = NULL;
 	struct dma_async_tx_descriptor *desc, *desc_dummy;
 	unsigned len;
-	int ret = 0;
+	int i, ret = 0;
 
 	if (rspi->dma_width_16bit) {
 		/*
@@ -462,7 +587,7 @@ static int rspi_receive_dma(struct rspi_data *rspi, struct spi_transfer *t)
 		rx_buf = kmalloc(len, GFP_KERNEL);
 		if (!rx_buf)
 			return -ENOMEM;
-	 } else {
+	} else {
 		len = t->len;
 		rx_buf = t->rx_buf;
 	}
@@ -505,9 +630,10 @@ static int rspi_receive_dma(struct rspi_data *rspi, struct spi_transfer *t)
 	 * DMAC needs SPTIE, but if SPTIE is set, this IRQ routine will be
 	 * called. So, this driver disables the IRQ while DMA transfer.
 	 */
-	disable_irq(rspi->irq);
+	for (i = 0; i < rspi->irqn; i++)
+		disable_irq(rspi->irq[i]);
 
-	rspi_write8(rspi, rspi_read8(rspi, RSPI_SPCR) & ~SPCR_TXMD, RSPI_SPCR);
+	rspi_clear_txmode(rspi);
 	rspi_enable_irq(rspi, SPCR_SPTIE | SPCR_SPRIE);
 	rspi->dma_callbacked = 0;
 
@@ -528,7 +654,8 @@ static int rspi_receive_dma(struct rspi_data *rspi, struct spi_transfer *t)
 		ret = -ETIMEDOUT;
 	rspi_disable_irq(rspi, SPCR_SPTIE | SPCR_SPRIE);
 
-	enable_irq(rspi->irq);
+	for (i = 0; i < rspi->irqn; i++)
+		enable_irq(rspi->irq[i]);
 
 end:
 	rspi_dma_unmap_sg(&sg, rspi->chan_rx, DMA_FROM_DEVICE);
@@ -598,6 +725,7 @@ static void rspi_work(struct work_struct *work)
 
 		spin_lock_irqsave(&rspi->lock, flags);
 	}
+	spin_unlock_irqrestore(&rspi->lock, flags);
 
 	return;
 
@@ -614,6 +742,33 @@ static int rspi_setup(struct spi_device *spi)
 		spi->bits_per_word = 8;
 	rspi->max_speed_hz = spi->max_speed_hz;
 
+	rspi->spcmd = SPCMD_SSLKP;
+
+	if (spi->mode & SPI_CPOL)
+		rspi->spcmd |= SPCMD_CPOL;
+
+	if (spi->mode & SPI_CPHA)
+		rspi->spcmd |= SPCMD_CPHA;
+
+	rspi->sppcr = 0;
+	if (spi->mode & SPI_LOOP)
+		rspi->sppcr |= SPPCR_SPLP;
+
+	rspi->spdcr = rspi->data_width_regval;
+
+	if (spi->clk_delay) {
+		rspi->clk_delay = spi->clk_delay;
+		rspi->spcmd |= SPCMD_SCKDEN;
+	}
+	if (spi->cs_negate_delay) {
+		rspi->cs_negate_delay = spi->cs_negate_delay;
+		rspi->spcmd |= SPCMD_SLNDEN;
+	}
+	if (spi->next_access_delay) {
+		rspi->next_access_delay = spi->next_access_delay;
+		rspi->spcmd |= SPCMD_SPNDEN;
+	}
+
 	rspi_set_config_register(rspi, 8);
 
 	return 0;
@@ -720,10 +875,12 @@ static void rspi_release_dma(struct rspi_data *rspi)
 static int rspi_remove(struct platform_device *pdev)
 {
 	struct rspi_data *rspi = dev_get_drvdata(&pdev->dev);
+	int i;
 
 	spi_unregister_master(rspi->master);
 	rspi_release_dma(rspi);
-	free_irq(platform_get_irq(pdev, 0), rspi);
+	for (i = 0; i < rspi->irqn; i++)
+		free_irq(rspi->irq[i], rspi);
 	clk_put(rspi->clk);
 	iounmap(rspi->addr);
 	spi_master_put(rspi->master);
@@ -736,7 +893,8 @@ static int rspi_probe(struct platform_device *pdev)
 	struct resource *res;
 	struct spi_master *master;
 	struct rspi_data *rspi;
-	int ret, irq;
+	int ret, irq, i, j;
+	struct rspi_plat_data *rspi_pd;
 	char clk_name[16];
 
 	/* get base addr */
@@ -746,12 +904,6 @@ static int rspi_probe(struct platform_device *pdev)
 		return -EINVAL;
 	}
 
-	irq = platform_get_irq(pdev, 0);
-	if (irq < 0) {
-		dev_err(&pdev->dev, "platform_get_irq error\n");
-		return -ENODEV;
-	}
-
 	master = spi_alloc_master(&pdev->dev, sizeof(struct rspi_data));
 	if (master == NULL) {
 		dev_err(&pdev->dev, "spi_alloc_master error.\n");
@@ -788,14 +940,35 @@ static int rspi_probe(struct platform_device *pdev)
 	master->setup = rspi_setup;
 	master->transfer = rspi_transfer;
 	master->cleanup = rspi_cleanup;
+	master->mode_bits = (SPI_CPHA | SPI_CPOL | SPI_LOOP);
+
+	i = j = 0;
+	while ((res = platform_get_resource(pdev, IORESOURCE_IRQ, i++))) {
+		for (irq = res->start; irq <= res->end; irq++) {
+			if (j >= NUM_IRQ) {
+				dev_err(&pdev->dev, "irq resource is over\n");
+				ret = -ENODEV;
+				goto error3;
+			}
+			snprintf(drv_name[pdev->id][j], DRIVER_NAME_SIZE,
+				 "%s.%d-%d", DRIVER_NAME, pdev->id, j);
+			ret = request_irq(irq, rspi_irq, IRQF_DISABLED,
+					  drv_name[pdev->id][j], rspi);
+			if (ret < 0) {
+				dev_err(&pdev->dev, "request_irq error\n");
+				goto error3;
+			}
+			rspi->irq[j++] = irq;
+		}
+	}
+	rspi->irqn = j;
 
-	ret = request_irq(irq, rspi_irq, 0, dev_name(&pdev->dev), rspi);
+	ret = rspi_setup_data_register_width(rspi, pdev);
 	if (ret < 0) {
-		dev_err(&pdev->dev, "request_irq error\n");
-		goto error3;
+		dev_err(&pdev->dev, "rspi setup invalid data width.\n");
+		goto error4;
 	}
 
-	rspi->irq = irq;
 	ret = rspi_request_dma(rspi, pdev);
 	if (ret < 0) {
 		dev_err(&pdev->dev, "rspi_request_dma failed.\n");
@@ -808,14 +981,19 @@ static int rspi_probe(struct platform_device *pdev)
 		goto error4;
 	}
 
+	rspi_pd = pdev->dev.platform_data;
+	rspi->spcr = rspi_pd->spcr;
+	rspi->txmode = rspi_pd->txmode;
+
 	dev_info(&pdev->dev, "probed\n");
 
 	return 0;
 
 error4:
 	rspi_release_dma(rspi);
-	free_irq(irq, rspi);
 error3:
+	for (i = 0; i < j; i++)
+		free_irq(rspi->irq[i], rspi);
 	clk_put(rspi->clk);
 error2:
 	iounmap(rspi->addr);
diff --git a/drivers/spi/spi-sh-spibsc.c b/drivers/spi/spi-sh-spibsc.c
new file mode 100644
index 0000000..5f18241
--- /dev/null
+++ b/drivers/spi/spi-sh-spibsc.c
@@ -0,0 +1,818 @@
+/*
+ * SuperH SPIBSC bus driver
+ *
+ * Copyright (C) 2011-2013 Renesas Solutions Corp.
+ *
+ * Based on spi-sh-hspi.c:
+ *
+ * Copyright (C) 2011  Kuninori Morimoto
+ *
+ * Based on spi-sh.c:
+ * Based on pxa2xx_spi.c:
+ * Copyright (C) 2005 Stephen Street / StreetFire Sound Labs
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+#include <linux/clk.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/io.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/sh_spibsc.h>
+
+/* SPIBSC registers */
+#define	CMNCR	0x00
+#define	SSLDR	0x04
+#define SPBCR	0x08
+#define DRCR	0x0c
+#define	SMCR	0x20
+#define	SMCMR	0x24
+#define	SMADR	0x28
+#define	SMOPR	0x2c
+#define	SMENR	0x30
+#define SMRDR0	0x38
+#define SMRDR1	0x3c
+#define	SMWDR0	0x40
+#define SMWDR1	0x44
+#define	CMNSR	0x48
+#define SMDMCR	0x60
+#define SMDRENR	0x64
+
+/* CMNCR */
+#define	CMNCR_MD	(1u << 31)
+#define	CMNCR_SFDE	(1u << 24)
+
+#define	CMNCR_MOIIO3(x)		(((u32)(x) & 0x3) << 22)
+#define	CMNCR_MOIIO2(x)		(((u32)(x) & 0x3) << 20)
+#define	CMNCR_MOIIO1(x)		(((u32)(x) & 0x3) << 18)
+#define	CMNCR_MOIIO0(x)		(((u32)(x) & 0x3) << 16)
+#define	CMNCR_IO3FV(x)		(((u32)(x) & 0x3) << 14)
+#define	CMNCR_IO2FV(x)		(((u32)(x) & 0x3) << 12)
+#define	CMNCR_IO0FV(x)		(((u32)(x) & 0x3) << 8)
+
+#define	CMNCR_CPHAT	(1u << 6)
+#define	CMNCR_CPHAR	(1u << 5)
+#define	CMNCR_SSLP	(1u << 4)
+#define	CMNCR_CPOL	(1u << 3)
+#define	CMNCR_BSZ(n)	(((u32)(n) & 0x3) << 0)
+
+#define	OUT_0		(0u)
+#define	OUT_1		(1u)
+#define	OUT_REV		(2u)
+#define	OUT_HIZ		(3u)
+
+#define	BSZ_SINGLE	(0)
+#define	BSZ_DUAL	(1)
+
+#define CMNCR_INIT	(CMNCR_MD | \
+			CMNCR_SFDE | \
+			CMNCR_MOIIO3(OUT_HIZ) | \
+			CMNCR_MOIIO2(OUT_HIZ) | \
+			CMNCR_MOIIO1(OUT_HIZ) | \
+			CMNCR_MOIIO0(OUT_HIZ) | \
+			CMNCR_IO3FV(OUT_HIZ) | \
+			CMNCR_IO2FV(OUT_HIZ) | \
+			CMNCR_IO0FV(OUT_HIZ) | \
+			CMNCR_CPHAR | \
+			CMNCR_BSZ(BSZ_SINGLE))
+
+/* SSLDR */
+#define	SSLDR_SPNDL(x)	(((u32)(x) & 0x7) << 16)
+#define	SSLDR_SLNDL(x)	(((u32)(x) & 0x7) << 8)
+#define	SSLDR_SCKDL(x)	(((u32)(x) & 0x7) << 0)
+
+#define	SPBCLK_1_0	(0)
+#define	SPBCLK_1_5	(0)
+#define	SPBCLK_2_0	(1)
+#define	SPBCLK_2_5	(1)
+#define	SPBCLK_3_0	(2)
+#define	SPBCLK_3_5	(2)
+#define	SPBCLK_4_0	(3)
+#define	SPBCLK_4_5	(3)
+#define	SPBCLK_5_0	(4)
+#define	SPBCLK_5_5	(4)
+#define	SPBCLK_6_0	(5)
+#define	SPBCLK_6_5	(5)
+#define	SPBCLK_7_0	(6)
+#define	SPBCLK_7_5	(6)
+#define	SPBCLK_8_0	(7)
+#define	SPBCLK_8_5	(7)
+
+#define	SSLDR_INIT	(SSLDR_SPNDL(SPBCLK_1_0) | \
+			SSLDR_SLNDL(SPBCLK_1_0) | \
+			SSLDR_SCKDL(SPBCLK_1_0))
+
+/* SPBCR */
+#define	SPBCR_SPBR(x)		(((u32)(x) & 0xff) << 8)
+#define	SPBCR_BRDV(x)		(((u32)(x) & 0x3) << 0)
+
+#define SPBCR_INIT	(SPBCR_SPBR(1) | SPBCR_BRDV(0))
+
+/* DRCR (read mode) */
+#define	DRCR_SSLN		(1u << 24)
+#define	DRCR_RBURST(x)		(((u32)(x) & 0xf) << 16)
+#define	DRCR_RCF		(1u << 9)
+#define	DRCR_RBE		(1u << 8)
+#define	DRCR_SSLE		(1u << 0)
+
+/* DRCMR (read mode) */
+#define	DRCMR_CMD(c)		(((u32)(c) & 0xff) << 16)
+#define	DRCMR_OCMD(c)		(((u32)(c) & 0xff) << 0)
+
+/* DREAR (read mode) */
+#define	DREAR_EAV(v)		(((u32)(v) & 0xff) << 16)
+#define	DREAR_EAC(v)		(((u32)(v) & 0x7) << 0)
+
+/* DROPR (read mode) */
+#define	DROPR_OPD3(o)		(((u32)(o) & 0xff) << 24)
+#define	DROPR_OPD2(o)		(((u32)(o) & 0xff) << 16)
+#define	DROPR_OPD1(o)		(((u32)(o) & 0xff) << 8)
+#define	DROPR_OPD0(o)		(((u32)(o) & 0xff) << 0)
+
+/* DRENR (read mode) */
+#define	DRENR_CDB(b)		(((u32)(b) & 0x3) << 30)
+#define	DRENR_OCDB(b)		(((u32)(b) & 0x3) << 28)
+#define	DRENR_ADB(b)		(((u32)(b) & 0x3) << 24)
+#define	DRENR_OPDB(b)		(((u32)(b) & 0x3) << 20)
+#define	DRENR_DRDB(b)		(((u32)(b) & 0x3) << 16)
+#define	DRENR_DME		(1u << 15)
+#define	DRENR_CDE		(1u << 14)
+#define	DRENR_OCDE		(1u << 12)
+#define	DRENR_ADE(a)		(((u32)(a) & 0xf) << 8)
+#define	DRENR_OPDE(o)		(((u32)(o) & 0xf) << 4)
+
+/* SMCR (spi mode) */
+#define	SMCR_SSLKP		(1u << 8)
+#define	SMCR_SPIRE		(1u << 2)
+#define	SMCR_SPIWE		(1u << 1)
+#define	SMCR_SPIE		(1u << 0)
+
+/* SMCMR (spi mode) */
+#define	SMCMR_CMD(c)		(((u32)(c) & 0xff) << 16)
+#define	SMCMR_OCMD(o)		(((u32)(o) & 0xff) << 0)
+
+/* SMADR (spi mode) */
+
+/* SMOPR (spi mode) */
+#define	SMOPR_OPD3(o)		(((u32)(o) & 0xff) << 24)
+#define	SMOPR_OPD2(o)		(((u32)(o) & 0xff) << 16)
+#define	SMOPR_OPD1(o)		(((u32)(o) & 0xff) << 8)
+#define	SMOPR_OPD0(o)		(((u32)(o) & 0xff) << 0)
+
+/* SMENR (spi mode) */
+#define	SMENR_CDB(b)		(((u32)(b) & 0x3) << 30)
+#define	SMENR_OCDB(b)		(((u32)(b) & 0x3) << 28)
+#define	SMENR_ADB(b)		(((u32)(b) & 0x3) << 24)
+#define	SMENR_OPDB(b)		(((u32)(b) & 0x3) << 20)
+#define	SMENR_SPIDB(b)		(((u32)(b) & 0x3) << 16)
+#define	SMENR_DME		(1u << 15)
+#define	SMENR_CDE		(1u << 14)
+#define	SMENR_OCDE		(1u << 12)
+#define	SMENR_ADE(b)		(((u32)(b) & 0xf) << 8)
+#define	SMENR_OPDE(b)		(((u32)(b) & 0xf) << 4)
+#define	SMENR_SPIDE(b)		(((u32)(b) & 0xf) << 0)
+
+#define	ADE_23_16	(0x4)
+#define	ADE_23_8	(0x6)
+#define	ADE_23_0	(0x7)
+#define	ADE_31_0	(0xf)
+
+#define	BITW_1BIT	(0)
+#define	BITW_2BIT	(1)
+#define	BITW_4BIT	(2)
+
+#define	SPIDE_8BITS	(0x8)
+#define	SPIDE_16BITS	(0xc)
+#define	SPIDE_32BITS	(0xf)
+
+#define	OPDE_3		(0x8)
+#define	OPDE_3_2	(0xc)
+#define	OPDE_3_2_1	(0xe)
+#define	OPDE_3_2_1_0	(0xf)
+
+/* SMRDR0 (spi mode) */
+/* SMRDR1 (spi mode) */
+/* SMWDR0 (spi mode) */
+/* SMWDR1 (spi mode) */
+
+/* CMNSR (spi mode) */
+#define	CMNSR_SSLF	(1u << 1)
+#define	CMNSR_TEND	(1u << 0)
+
+/* DRDMCR (read mode) */
+#define	DRDMCR_DMDB(b)		(((u32)(b) & 0x3) << 16)
+#define	DRDMCR_DMCYC(b)		(((u32)(b) & 0x7) << 0)
+
+/* DRDRENR (read mode) */
+#define	DRDRENR_ADDRE	(1u << 8)
+#define	DRDRENR_OPDRE	(1u << 4)
+#define	DRDRENR_DRDRE	(1u << 0)
+
+/* SMDMCR (spi mode) */
+#define	SMDMCR_DMDB(b)		(((u32)(b) & 0x3) << 16)
+#define	SMDMCR_DMCYC(b)		(((u32)(b) & 0x7) << 0)
+
+/* SMDRENR (spi mode) */
+#define	SMDRENR_ADDRE	(1u << 8)
+#define	SMDRENR_OPDRE	(1u << 4)
+#define	SMDRENR_SPIDRE	(1u << 0)
+
+/*
+ *  FlashROM Chip Commands
+ */
+#define	CMD_READ_ID	(0x9f)	/* (REMS) Read Electronic Manufacturer Signature */
+#define	CMD_PP		(0x02)	/* Page Program (3-byte address) */
+#define	CMD_QPP		(0x32)	/* Quad Page Program (3-byte address) */
+#define	CMD_READ	(0x03)	/* Read (3-byte address) */
+#define	CMD_FAST_READ	(0x0b)	/* Fast Read (3-byte address) */
+#define	CMD_DOR		(0x3b)	/* Read Dual Out (3-byte address) */
+#define	CMD_QOR		(0x6b)	/* Read Quad Out (3-byte address) */
+#define	CMD_WREN	(0x06)	/* Write enable */
+#define CMD_RDSR	(0x05)	/* Read status */
+#define CMD_SE		(0xd8)	/* Sector erase */
+
+/* SPIBSC registers */
+#define	CMNCR	0x00
+#define	SSLDR	0x04
+#define SPBCR	0x08
+#define DRCR	0x0c
+#define	SMCR	0x20
+#define	SMCMR	0x24
+#define	SMADR	0x28
+#define	SMOPR	0x2c
+#define	SMENR	0x30
+#define SMRDR0	0x38
+#define SMRDR1	0x3c
+#define	SMWDR0	0x40
+#define SMWDR1	0x44
+#define	CMNSR	0x48
+#define SMDMCR	0x60
+#define SMDRENR	0x64
+
+struct spibsc_priv {
+	void __iomem *addr;
+	struct spi_master *master;
+	struct device *dev;
+	struct clk *clk;
+	struct sh_spibsc_info *info;
+	u8 bspw;	/* bits per word */
+	u32 max_speed;	/* max speed hz */
+	u32 bitw;	/* data_bitw */
+	u32 dcyle;	/* dmy_cycle */
+};
+
+#define BITW_1BIT	(0)
+#define BITW_2BIT	(1)
+#define BITW_4BIT	(2)
+
+#undef DEBUG
+#ifdef DEBUG
+#define	DEBUG_COMMAND()						\
+	do {							\
+		int i;						\
+		dev_err(sbsc->dev, "command:");			\
+		for (i = 0; i < len; i++)			\
+			dev_err(sbsc->dev, " %02X", command[i]);\
+		dev_err(sbsc->dev, "\n");			\
+	} while (0)
+#define	DEBUG_SEND()						\
+	do {							\
+		int i;						\
+		dev_err(sbsc->dev, "send data:");		\
+		for (i = 0; i < len; i++)			\
+			dev_err(sbsc->dev, " %02X", data[i]);	\
+			dev_err(sbsc->dev, "\n");		\
+	} while (0)
+#define DEBUG_RECEIVE()						\
+	do {							\
+		int i;						\
+		dev_err(sbsc->dev, "receive data:");		\
+		for (i = 0; i < len; i++)			\
+			dev_err(sbsc->dev, " %02X", data[i]);	\
+			dev_err(sbsc->dev, "\n");		\
+	} while (0)
+#else
+#define	DEBUG_COMMAND()	do {} while (0)
+#define	DEBUG_SEND()	do {} while (0)
+#define DEBUG_RECEIVE()	do {} while (0)
+#endif
+
+static void spibsc_set_busio(struct spibsc_priv *sbsc, u8 cmd)
+{
+	u32 bitw, dcyle;
+
+	switch (cmd) {
+	case CMD_FAST_READ:	/* 0x0b Fast Read (3-byte address) */
+		dcyle = 8;
+		bitw = SMENR_SPIDB(BITW_1BIT);
+		break;
+
+	case CMD_QOR:		/* 0x6b Read Quad Out (3-byte address) */
+		dcyle = 8;
+		bitw = SMENR_SPIDB(BITW_4BIT);
+		break;
+
+	case CMD_QPP:		/* 0x32 Quad Page Program (3-byte address) */
+		dcyle = 0;
+		bitw = SMENR_SPIDB(BITW_4BIT);
+		break;
+
+	default:
+		dcyle = 0;
+		bitw = SMENR_SPIDB(BITW_1BIT);
+		break;
+	}
+
+	sbsc->bitw	= bitw;
+	sbsc->dcyle	= dcyle;
+}
+
+static void spibsc_write(struct spibsc_priv *sbsc, int reg, u32 val)
+{
+	iowrite32(val, sbsc->addr + reg);
+}
+
+static u32 spibsc_read(struct spibsc_priv *sbsc, int reg)
+{
+	return ioread32(sbsc->addr + reg);
+}
+
+static int spibsc_wait_trans_completion(struct spibsc_priv *sbsc)
+{
+	int t = 256 * 100000;
+
+	while (t--) {
+		if (spibsc_read(sbsc, CMNSR) & CMNSR_TEND)
+			return 0;
+
+		ndelay(1);
+	}
+
+	dev_err(sbsc->dev, "timeout\n");
+	return -ETIMEDOUT;
+}
+
+static int spibsc_do_send_data(struct spibsc_priv *sbsc, const u8 *data, int len);
+static int spibsc_do_send_cmd(struct spibsc_priv *sbsc, const u8 *command, int clen)
+{
+	int ret;
+	u32 cmd, addr = 0, smopr = 0, smenr, smcr, smdmcr = 0;
+
+	cmd = SMCMR_CMD(command[0]);
+	smenr = SMENR_CDE | SMENR_CDB(BITW_1BIT);
+
+	if (clen == 4) {	/* set 3byte address */
+		addr =	(command[1] << 16) |
+			(command[2] << 8) |
+			 command[3];
+
+		smenr |= SMENR_ADE(ADE_23_0) | SMENR_ADB(BITW_1BIT);
+
+		/* set dummy param. */
+		if (sbsc->dcyle > 0) {
+			smenr |= SMENR_DME;
+			smdmcr = SMDMCR_DMDB(BITW_1BIT) |
+					SMDMCR_DMCYC(sbsc->dcyle - 1);
+		}
+
+	} else if (clen >= 5) {	/* set 4byte address */
+		addr =	(command[1] << 24) |
+			(command[2] << 16) |
+			(command[3] << 8)  |
+			 command[4];
+
+		smenr |= SMENR_ADE(ADE_31_0) | SMENR_ADB(BITW_1BIT);
+
+		/* set dummy param. */
+		if (sbsc->dcyle > 0) {
+			smenr |= SMENR_DME;
+			smdmcr = SMDMCR_DMDB(BITW_1BIT) |
+					SMDMCR_DMCYC(sbsc->dcyle - 1);
+		}
+	}
+
+	/* set params */
+	spibsc_write(sbsc, SMCMR, cmd);
+	spibsc_write(sbsc, SMADR, addr);
+	spibsc_write(sbsc, SMOPR, smopr);
+	spibsc_write(sbsc, SMENR, smenr);
+	spibsc_write(sbsc, SMDMCR, smdmcr);
+
+	/* start spi transfer*/
+	smcr = SMCR_SPIE;
+	if (command[0] != CMD_WREN && command[0] != CMD_SE)
+		smcr |= SMCR_SSLKP;
+	spibsc_write(sbsc, SMCR, smcr);
+
+	/* wait for spi transfer completed */
+	ret = spibsc_wait_trans_completion(sbsc);
+	if (ret)
+		return ret;	/* return error */
+
+	if (clen == 2 || clen == 3) {
+		int len;
+
+		len = clen - 1;
+		spibsc_do_send_data(sbsc, &command[1], len);
+	}
+	return 0;
+}
+
+static int spibsc_do_send_data(struct spibsc_priv *sbsc, const u8 *data, int len)
+{
+	u32 smcr, smenr, smwdr0;
+	int ret, unit, sslkp = 1;
+
+	while (len > 0) {
+		if (len >= 4) {
+			unit = 4;
+			smenr = SMENR_SPIDE(SPIDE_32BITS) |
+					SMENR_SPIDB(sbsc->bitw);
+		} else {
+			unit = len;
+			if (unit >= 2)
+				smenr = SMENR_SPIDE(SPIDE_16BITS) |
+						SMENR_SPIDB(sbsc->bitw);
+			else
+				smenr = SMENR_SPIDE(SPIDE_8BITS) |
+						SMENR_SPIDB(sbsc->bitw);
+		}
+
+		/* set 4bytes data, bit stream */
+		smwdr0 = *data++;
+		if (unit >= 2)
+			smwdr0 |= (u32)(*data++ << 8);
+		if (unit >= 3)
+			smwdr0 |= (u32)(*data++ << 16);
+		if (unit >= 4)
+			smwdr0 |= (u32)(*data++ << 24);
+
+		/* mask unwrite area */
+		if (unit == 3)
+			smwdr0 |= 0xFF000000;
+		else if (unit == 2)
+			smwdr0 |= 0xFFFF0000;
+		else if (unit == 1)
+			smwdr0 |= 0xFFFFFF00;
+
+		/* write send data. */
+		spibsc_write(sbsc, SMWDR0, smwdr0);
+
+		len -= unit;
+		if (len <= 0)
+			sslkp = 0;
+
+		/* set params */
+		spibsc_write(sbsc, SMCMR, 0);
+		spibsc_write(sbsc, SMADR, 0);
+		spibsc_write(sbsc, SMOPR, 0);
+		spibsc_write(sbsc, SMENR, smenr);
+
+		/* start spi transfer */
+		smcr = SMCR_SPIE|SMCR_SPIWE;
+		if (sslkp)
+			smcr |= SMCR_SSLKP;
+		spibsc_write(sbsc, SMCR, smcr);
+
+		/* wait for spi transfer completed */
+		ret = spibsc_wait_trans_completion(sbsc);
+		if (ret)
+			return  ret;	/* return error */
+	}
+	return 0;
+}
+
+static int spibsc_do_receive_data(struct spibsc_priv *sbsc, u8 *data, int len)
+{
+	u32 smcr, smenr, smrdr0;
+	int ret, unit, sslkp = 1;
+
+	while (len > 0) {
+		if (len >= 4) {
+			unit = 4;
+			smenr = SMENR_SPIDE(SPIDE_32BITS) |
+						SMENR_SPIDB(sbsc->bitw);
+		} else {
+			unit = len;
+			if (unit >= 2)
+				smenr = SMENR_SPIDE(SPIDE_16BITS) |
+						SMENR_SPIDB(sbsc->bitw);
+			else
+				smenr = SMENR_SPIDE(SPIDE_8BITS) |
+						SMENR_SPIDB(sbsc->bitw);
+		}
+
+		len -= unit;
+		if (len <= 0)
+			sslkp = 0;
+
+		/* set params */
+		spibsc_write(sbsc, SMCMR, 0);
+		spibsc_write(sbsc, SMADR, 0);
+		spibsc_write(sbsc, SMOPR, 0);
+		spibsc_write(sbsc, SMENR, smenr);
+
+		/* start spi transfer */
+		smcr = SMCR_SPIE|SMCR_SPIRE;
+		if (sbsc->bitw == BITW_1BIT)
+			smcr |= SMCR_SPIWE;
+		if (sslkp)
+			smcr |= SMCR_SSLKP;
+		spibsc_write(sbsc, SMCR, smcr);
+
+		/* wait for spi transfer completed */
+		ret = spibsc_wait_trans_completion(sbsc);
+		if (ret)
+			return ret;	/* return error */
+
+		/* read SMRDR */
+		smrdr0 = spibsc_read(sbsc, SMRDR0);
+
+		*data++ = (u8)(smrdr0 & 0xff);
+		if (unit >= 2)
+			*data++ = (u8)((smrdr0 >> 8) & 0xff);
+		if (unit >= 3)
+			*data++ = (u8)((smrdr0 >> 16) & 0xff);
+		if (unit >= 4)
+			*data++ = (u8)((smrdr0 >> 24) & 0xff);
+	}
+	return 0;
+}
+
+static int spibsc_send_cmd(struct spibsc_priv *sbsc, struct spi_transfer *t)
+{
+	const u8 *command;
+	int len, ret;
+
+	/* wait for spi transfer completed */
+	ret = spibsc_wait_trans_completion(sbsc);
+	if (ret)
+		return	ret;	/* return error */
+
+	command = t->tx_buf;
+	len = t->len;
+
+	DEBUG_COMMAND();
+
+	spibsc_set_busio(sbsc, command[0]);
+	return spibsc_do_send_cmd(sbsc, command, len);
+}
+
+static int spibsc_send_data(struct spibsc_priv *sbsc, struct spi_transfer *t)
+{
+	const u8 *data;
+	int len, ret;
+
+	/* wait for spi transfer completed */
+	ret = spibsc_wait_trans_completion(sbsc);
+	if (ret)
+		return	ret;	/* return error */
+
+	data = t->tx_buf;
+	len = t->len;
+
+	DEBUG_SEND();
+
+	return spibsc_do_send_data(sbsc, data, len);
+}
+
+static int spibsc_receive_data(struct spibsc_priv *sbsc, struct spi_transfer *t)
+{
+	u8 *data;
+	int len, ret;
+
+	/* wait for spi transfer completed */
+	ret = spibsc_wait_trans_completion(sbsc);
+	if (ret)
+		return	ret;	/* return error */
+
+	data = t->rx_buf;
+	len = t->len;
+
+	ret = spibsc_do_receive_data(sbsc, data, len);
+
+	DEBUG_RECEIVE();
+
+	return ret;
+}
+
+static void spibsc_hw_cs_disable(struct spibsc_priv *sbsc)
+{
+	u8 cmd = CMD_RDSR, data;
+
+	/* send Read status command to negate SSL line */
+	spibsc_do_send_cmd(sbsc, &cmd, 1);
+	spibsc_do_receive_data(sbsc, &data, 1);
+}
+
+/*
+ *		spi master function
+ */
+static int spibsc_prepare_transfer(struct spi_master *master)
+{
+	struct spibsc_priv *sbsc = spi_master_get_devdata(master);
+
+	pm_runtime_get_sync(sbsc->dev);
+	return 0;
+}
+
+static int spibsc_unprepare_transfer(struct spi_master *master)
+{
+	struct spibsc_priv *spibsc = spi_master_get_devdata(master);
+
+	pm_runtime_put_sync(spibsc->dev);
+	return 0;
+}
+
+static int spibsc_transfer_one_message(struct spi_master *master,
+				     struct spi_message *msg)
+{
+	struct spibsc_priv *sbsc = spi_master_get_devdata(master);
+	struct spi_transfer *t;
+	int ret;
+	unsigned int cs_change;
+
+	dev_dbg(sbsc->dev, "%s\n", __func__);
+
+	/* start transfer each of struct spi_transfer */
+	cs_change = 1;
+	ret = 0;
+	list_for_each_entry(t, &msg->transfers, transfer_list) {
+		/* send command or send data or recevie data */
+		if (cs_change) {
+			ret = spibsc_send_cmd(sbsc, t);	/* send command */
+			if (ret)
+				break;
+
+		} else {
+			if (t->tx_buf) {	/* send data */
+				ret = spibsc_send_data(sbsc, t);
+				if (ret)
+					break;
+			} else if (t->rx_buf) { /* receive data */
+				ret = spibsc_receive_data(sbsc, t);
+				if (ret)
+					break;
+			}
+		}
+		cs_change = t->cs_change;
+		msg->actual_length += t->len;
+	}
+
+	if (!cs_change)
+		spibsc_hw_cs_disable(sbsc);
+
+	msg->status = ret;
+	spi_finalize_current_message(master);
+
+	return ret;
+}
+
+static int spibsc_setup(struct spi_device *spi)
+{
+	struct spibsc_priv *sbsc = spi_master_get_devdata(spi->master);
+	struct device *dev = sbsc->dev;
+
+	if (8 != spi->bits_per_word) {
+		dev_err(dev, "bits_per_word should be 8\n");
+		return -EIO;
+	}
+
+	/* initilaize spibsc */
+	spibsc_write(sbsc, CMNCR, CMNCR_INIT);
+	spibsc_write(sbsc, DRCR, DRCR_RCF);
+	spibsc_write(sbsc, SSLDR, SSLDR_INIT);
+	spibsc_write(sbsc, SPBCR, SPBCR_INIT);
+
+	dev_dbg(dev, "%s setup\n", spi->modalias);
+
+	return 0;
+}
+
+static void spibsc_cleanup(struct spi_device *spi)
+{
+	struct spibsc_priv *sbsc = spi_master_get_devdata(spi->master);
+	struct device *dev = sbsc->dev;
+
+	dev_dbg(dev, "%s cleanup\n", spi->modalias);
+}
+
+static int spibsc_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct spi_master *master;
+	struct spibsc_priv *sbsc;
+	struct clk *clk;
+	int ret;
+	char clk_name[16];
+
+	/* get base addr */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "invalid resource\n");
+		return -EINVAL;
+	}
+
+	master = spi_alloc_master(&pdev->dev, sizeof(*sbsc));
+	if (!master) {
+		dev_err(&pdev->dev, "spi_alloc_master error.\n");
+		return -ENOMEM;
+	}
+
+	snprintf(clk_name, sizeof(clk_name), "spibsc%d", pdev->id);
+	clk = clk_get(&pdev->dev, clk_name);
+	if (IS_ERR(clk)) {
+		dev_err(&pdev->dev, "cannot get spibsc clock\n");
+		ret = -EINVAL;
+		goto error0;
+	}
+	clk_enable(clk);
+
+	sbsc = spi_master_get_devdata(master);
+	dev_set_drvdata(&pdev->dev, sbsc);
+	sbsc->info = pdev->dev.platform_data;
+
+	/* init sbsc */
+	sbsc->master	= master;
+	sbsc->dev	= &pdev->dev;
+	sbsc->clk	= clk;
+	sbsc->addr	= devm_ioremap(sbsc->dev,
+				       res->start, resource_size(res));
+	if (!sbsc->addr) {
+		dev_err(&pdev->dev, "ioremap error.\n");
+		ret = -ENOMEM;
+		goto error1;
+	}
+
+	master->num_chipselect	= 1;
+	master->bus_num		= sbsc->info->bus_num;
+	master->setup		= spibsc_setup;
+	master->cleanup		= spibsc_cleanup;
+	master->mode_bits	= SPI_CPOL | SPI_CPHA;
+	master->prepare_transfer_hardware	= spibsc_prepare_transfer;
+	master->transfer_one_message		= spibsc_transfer_one_message;
+	master->unprepare_transfer_hardware	= spibsc_unprepare_transfer;
+	ret = spi_register_master(master);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "spi_register_master error.\n");
+		goto error1;
+	}
+
+	pm_runtime_enable(&pdev->dev);
+
+	dev_info(&pdev->dev, "probed\n");
+
+	return 0;
+
+ error1:
+	clk_put(clk);
+ error0:
+	spi_master_put(master);
+
+	return ret;
+}
+
+static int spibsc_remove(struct platform_device *pdev)
+{
+	struct spibsc_priv *sbsc = dev_get_drvdata(&pdev->dev);
+
+	pm_runtime_disable(&pdev->dev);
+
+	clk_put(sbsc->clk);
+	spi_unregister_master(sbsc->master);
+
+	return 0;
+}
+
+static struct platform_driver spibsc_driver = {
+	.probe = spibsc_probe,
+	.remove = spibsc_remove,
+	.driver = {
+		.name = "spibsc",
+		.owner = THIS_MODULE,
+	},
+};
+module_platform_driver(spibsc_driver);
+
+MODULE_DESCRIPTION("SuperH SPIBSC bus driver");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("RSO");
+MODULE_ALIAS("platform:sh_spi");
diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 19ee901..faa20f5 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1,6 +1,7 @@
 /*
  * SPI init/core code
  *
+ * Copyright (C) 2013 Renesas Solutions Corp.
  * Copyright (C) 2005 David Brownell
  * Copyright (C) 2008 Secret Lab Technologies Ltd.
  *
@@ -454,6 +455,9 @@ struct spi_device *spi_new_device(struct spi_master *master,
 	proxy->dev.platform_data = (void *) chip->platform_data;
 	proxy->controller_data = chip->controller_data;
 	proxy->controller_state = NULL;
+	proxy->clk_delay = chip->clk_delay;
+	proxy->cs_negate_delay = chip->cs_negate_delay;
+	proxy->next_access_delay = chip->next_access_delay;
 
 	status = spi_add_device(proxy);
 	if (status < 0) {
diff --git a/drivers/usb/host/r8a66597-hcd.c b/drivers/usb/host/r8a66597-hcd.c
index a6fd8f5..7e034d7 100644
--- a/drivers/usb/host/r8a66597-hcd.c
+++ b/drivers/usb/host/r8a66597-hcd.c
@@ -1,7 +1,7 @@
 /*
  * R8A66597 HCD (Host Controller Driver)
  *
- * Copyright (C) 2006-2007 Renesas Solutions Corp.
+ * Copyright (C) 2006-2013 Renesas Solutions Corp.
  * Portions Copyright (C) 2004 Psion Teklogix (for NetBook PRO)
  * Portions Copyright (C) 2004-2005 David Brownell
  * Portions Copyright (C) 1999 Roman Weissgaerber
@@ -89,6 +89,7 @@ static void set_devadd_reg(struct r8a66597 *r8a66597, u8 r8a66597_address,
 	r8a66597_write(r8a66597, val, devadd_reg);
 }
 
+#ifndef CONFIG_ARCH_RZA1
 static int r8a66597_clock_enable(struct r8a66597 *r8a66597)
 {
 	u16 tmp;
@@ -146,6 +147,46 @@ static void r8a66597_clock_disable(struct r8a66597 *r8a66597)
 		r8a66597_bclr(r8a66597, USBE, SYSCFG0);
 	}
 }
+#else
+static int r8a66597_clock_enable(struct r8a66597 *r8a66597)
+{
+	u16 tmp;
+	int i = 0;
+
+	if (r8a66597->pdata->on_chip)
+		clk_enable(r8a66597->clk);
+
+	do {
+		r8a66597_write(r8a66597, USBE, SYSCFG0);
+		tmp = r8a66597_read(r8a66597, SYSCFG0);
+		if (i++ > 1000) {
+			printk(KERN_ERR "r8a66597: reg access fail.\n");
+			return -ENXIO;
+		}
+	} while ((tmp & USBE) != USBE);
+	r8a66597_bclr(r8a66597, USBE, SYSCFG0);
+
+	if (XTAL48 == get_xtal_from_pdata(r8a66597->pdata))
+		r8a66597_bclr(r8a66597, XTAL, SYSCFG0);
+	else
+		r8a66597_bset(r8a66597, XTAL, SYSCFG0);
+	msleep(20);
+	r8a66597_bset(r8a66597, UPLLE, SYSCFG0);
+	msleep(20);
+	r8a66597_bset(r8a66597, SUSPM, SUSPMODE0);
+	return 0;
+}
+static void r8a66597_clock_disable(struct r8a66597 *r8a66597)
+{
+	r8a66597_bclr(r8a66597, SUSPM, SUSPMODE0);
+	r8a66597_bclr(r8a66597, UPLLE, SYSCFG0);
+	msleep(20);
+	r8a66597_bclr(r8a66597, USBE, SYSCFG0);
+	msleep(20);
+	if (r8a66597->pdata->on_chip)
+		clk_disable(r8a66597->clk);
+}
+#endif /* CONFIG_ARCH_RZA1 */
 
 static void r8a66597_enable_port(struct r8a66597 *r8a66597, int port)
 {
@@ -155,7 +196,9 @@ static void r8a66597_enable_port(struct r8a66597 *r8a66597, int port)
 	r8a66597_bset(r8a66597, val, get_syscfg_reg(port));
 	r8a66597_bset(r8a66597, HSE, get_syscfg_reg(port));
 
+#ifndef CONFIG_ARCH_RZA1
 	r8a66597_write(r8a66597, BURST | CPU_ADR_RD_WR, get_dmacfg_reg(port));
+#endif
 	r8a66597_bclr(r8a66597, DTCHE, get_intenb_reg(port));
 	r8a66597_bset(r8a66597, ATTCHE, get_intenb_reg(port));
 }
@@ -182,7 +225,9 @@ static void r8a66597_disable_port(struct r8a66597 *r8a66597, int port)
 static int enable_controller(struct r8a66597 *r8a66597)
 {
 	int ret, port;
+#ifndef CONFIG_ARCH_RZA1
 	u16 vif = r8a66597->pdata->vif ? LDRV : 0;
+#endif
 	u16 irq_sense = r8a66597->irq_sense_low ? INTL : 0;
 	u16 endian = r8a66597->pdata->endian ? BIGEND : 0;
 
@@ -190,7 +235,9 @@ static int enable_controller(struct r8a66597 *r8a66597)
 	if (ret < 0)
 		return ret;
 
+#ifndef CONFIG_ARCH_RZA1
 	r8a66597_bset(r8a66597, vif & LDRV, PINCFG);
+#endif
 	r8a66597_bset(r8a66597, USBE, SYSCFG0);
 
 	r8a66597_bset(r8a66597, BEMPE | NRDYE | BRDYE, INTENB0);
diff --git a/drivers/usb/host/r8a66597.h b/drivers/usb/host/r8a66597.h
index 672cea3..90fa8d8 100644
--- a/drivers/usb/host/r8a66597.h
+++ b/drivers/usb/host/r8a66597.h
@@ -1,7 +1,7 @@
 /*
  * R8A66597 HCD (Host Controller Driver)
  *
- * Copyright (C) 2006-2007 Renesas Solutions Corp.
+ * Copyright (C) 2006-2013 Renesas Solutions Corp.
  * Portions Copyright (C) 2004 Psion Teklogix (for NetBook PRO)
  * Portions Copyright (C) 2004-2005 David Brownell
  * Portions Copyright (C) 1999 Roman Weissgaerber
@@ -309,9 +309,11 @@ static inline u16 get_xtal_from_pdata(struct r8a66597_platdata *pdata)
 	case R8A66597_PLATDATA_XTAL_12MHZ:
 		clock = XTAL12;
 		break;
+#ifndef CONFIG_ARCH_RZA1
 	case R8A66597_PLATDATA_XTAL_24MHZ:
 		clock = XTAL24;
 		break;
+#endif
 	case R8A66597_PLATDATA_XTAL_48MHZ:
 		clock = XTAL48;
 		break;
diff --git a/drivers/video/Kconfig b/drivers/video/Kconfig
index e7068c5..ba7bf9c 100644
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -2419,6 +2419,7 @@ config FB_PUV3_UNIGFX
 	  Choose this option if you want to use the Unigfx device as a
 	  framebuffer device. Without the support of PCI & AGP.
 
+source "drivers/video/renesas/Kconfig"
 source "drivers/video/omap/Kconfig"
 source "drivers/video/omap2/Kconfig"
 source "drivers/video/exynos/Kconfig"
diff --git a/drivers/video/Makefile b/drivers/video/Makefile
index 768a137..a8f1907 100644
--- a/drivers/video/Makefile
+++ b/drivers/video/Makefile
@@ -137,6 +137,7 @@ obj-$(CONFIG_SH_MIPI_DSI)	  += sh_mipi_dsi.o
 obj-$(CONFIG_FB_SH_MOBILE_HDMI)	  += sh_mobile_hdmi.o
 obj-$(CONFIG_FB_SH_MOBILE_MERAM)  += sh_mobile_meram.o
 obj-$(CONFIG_FB_SH_MOBILE_LCDC)	  += sh_mobile_lcdcfb.o
+obj-$(CONFIG_FB_VDC5)             += renesas/
 obj-$(CONFIG_FB_OMAP)             += omap/
 obj-y                             += omap2/
 obj-$(CONFIG_XEN_FBDEV_FRONTEND)  += xen-fbfront.o
diff --git a/drivers/video/renesas/Kconfig b/drivers/video/renesas/Kconfig
new file mode 100644
index 0000000..c64c957
--- /dev/null
+++ b/drivers/video/renesas/Kconfig
@@ -0,0 +1,35 @@
+config FB_VDC5
+	tristate "RZ/A1H frame-buffer driver for VDC5 (EXPERIMENTAL)"
+	depends on FB
+	depends on ARCH_RZA1
+	select FB_SYS_FILLRECT
+	select FB_SYS_COPYAREA
+	select FB_SYS_IMAGEBLIT
+	select FB_SYS_FOPS
+	select LCD_R0P7724LE0011RL
+	help
+	  Frame-buffer device for the Renesas RZ/A1H based boards.
+	  This version of driver supports the following board and
+	  LCD panels.
+	  + the "Genmai" CPU board with Option board
+	    + Channel 0:
+	      (0) unuse
+	      (1) LCD-KIT-B01 (using J10 connector)
+	      (2) LCD Moniror (using J15 connector)
+	    + Channel 1:
+	      (0) unuse
+	      (1) LCD-KIT-B01 (using J12 connector)
+	      (2) R0P7724LE0011RL (using J14 connector)
+	      (3) LCD Moniror (using J16 connector)
+	  To choose the LCD panel, use vdc5fb0= kernel boot option
+	  for channel 0 and vdc5fb1= for channel 1, like:
+	      vdc5fb0=1 vdc5fb1=0
+	  This example shows that the LCD-KIT-B01 is used for
+	  channel 0, and channel 1 is not used. Please use this
+	  driver with this default configuration.
+	  Note that there are some signal line conflictions
+	  between channel 1 of this device and SDHI/ETHER devices.
+	  So, when you specify other than 0 with vdc5fb1= option,
+	  this driver forcibly disables the SDHI/ETHER drivers.
+	  You also need to change jumper and dip-switch settings.
+
diff --git a/drivers/video/renesas/Makefile b/drivers/video/renesas/Makefile
new file mode 100644
index 0000000..379e685
--- /dev/null
+++ b/drivers/video/renesas/Makefile
@@ -0,0 +1,6 @@
+#
+# Makefile for the Renesas VDC5 framebuffer device driver
+#
+
+obj-$(CONFIG_FB_VDC5) += vdc5fb.o 
+
diff --git a/drivers/video/renesas/vdc5fb-regs.h b/drivers/video/renesas/vdc5fb-regs.h
new file mode 100644
index 0000000..e713749
--- /dev/null
+++ b/drivers/video/renesas/vdc5fb-regs.h
@@ -0,0 +1,1121 @@
+/*
+ * Copyright (C) 2013 Renesas Solutions Corp.
+ *
+ * Based on drivers/video/ren_vdc4.c
+ * Copyright (c) 2012 Renesas Electronics Europe Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef _VDC5FB_REGS_H_
+#define _VDC5FB_REGS_H_
+
+/* REGISTER INDEX */
+enum {
+	/* INPUT CONTROLLER */
+	INP_UPDATE,
+	INP_SEL_CNT,
+	INP_EXT_SYNC_CNT,
+	INP_VSYNC_PH_ADJ,
+	INP_DLY_ADJ,
+
+	/* IMAGE QUALITY ADJUSTMENT BLOCK */
+	IMGCNT_UPDATE,
+	IMGCNT_NR_CNT0,
+	IMGCNT_NR_CNT1,
+	IMGCNT_MTX_MODE,
+	IMGCNT_MTX_YG_ADJ0,
+	IMGCNT_MTX_YG_ADJ1,
+	IMGCNT_MTX_CBB_ADJ0,
+	IMGCNT_MTX_CBB_ADJ1,
+	IMGCNT_MTX_CRR_ADJ0,
+	IMGCNT_MTX_CRR_ADJ1,
+	IMGCNT_DRC_REG,
+
+	/* SCALER 0 */
+	SC0_SCL0_UPDATE,
+	SC0_SCL0_FRC1,
+	SC0_SCL0_FRC2,
+	SC0_SCL0_FRC3,
+	SC0_SCL0_FRC4,
+	SC0_SCL0_FRC5,
+	SC0_SCL0_FRC6,
+	SC0_SCL0_FRC7,
+	SC0_SCL0_FRC9,
+	SC0_SCL0_MON0,
+	SC0_SCL0_INT,
+	SC0_SCL0_DS1,
+	SC0_SCL0_DS2,
+	SC0_SCL0_DS3,
+	SC0_SCL0_DS4,
+	SC0_SCL0_DS5,
+	SC0_SCL0_DS6,
+	SC0_SCL0_DS7,
+	SC0_SCL0_US1,
+	SC0_SCL0_US2,
+	SC0_SCL0_US3,
+	SC0_SCL0_US4,
+	SC0_SCL0_US5,
+	SC0_SCL0_US6,
+	SC0_SCL0_US7,
+	SC0_SCL0_US8,
+	SC0_SCL0_OVR1,
+	SC0_SCL1_UPDATE,
+	SC0_SCL1_WR1,
+	SC0_SCL1_WR2,
+	SC0_SCL1_WR3,
+	SC0_SCL1_WR4,
+	SC0_SCL1_WR5,
+	SC0_SCL1_WR6,
+	SC0_SCL1_WR7,
+	SC0_SCL1_WR8,
+	SC0_SCL1_WR9,
+	SC0_SCL1_WR10,
+	SC0_SCL1_WR11,
+	SC0_SCL1_MON1,
+	SC0_SCL1_PBUF0,
+	SC0_SCL1_PBUF1,
+	SC0_SCL1_PBUF2,
+	SC0_SCL1_PBUF3,
+	SC0_SCL1_PBUF_FLD,
+	SC0_SCL1_PBUF_CNT,
+
+	/* GRAPHICS 0 */
+	GR0_UPDATE,
+	GR0_FLM_RD,
+	GR0_FLM1,
+	GR0_FLM2,
+	GR0_FLM3,
+	GR0_FLM4,
+	GR0_FLM5,
+	GR0_FLM6,
+	GR0_AB1,
+	GR0_AB2,
+	GR0_AB3,
+	GR0_AB7,
+	GR0_AB8,
+	GR0_AB9,
+	GR0_AB10,
+	GR0_AB11,
+	GR0_BASE,
+	GR0_CLUT,
+	GR0_MON,
+
+	/* SCALER 1 */
+	SC1_SCL0_UPDATE,
+	SC1_SCL0_FRC1,
+	SC1_SCL0_FRC2,
+	SC1_SCL0_FRC3,
+	SC1_SCL0_FRC4,
+	SC1_SCL0_FRC5,
+	SC1_SCL0_FRC6,
+	SC1_SCL0_FRC7,
+	SC1_SCL0_FRC9,
+	SC1_SCL0_MON0,
+	SC1_SCL0_INT,
+	SC1_SCL0_DS1,
+	SC1_SCL0_DS2,
+	SC1_SCL0_DS3,
+	SC1_SCL0_DS4,
+	SC1_SCL0_DS5,
+	SC1_SCL0_DS6,
+	SC1_SCL0_DS7,
+	SC1_SCL0_US1,
+	SC1_SCL0_US2,
+	SC1_SCL0_US3,
+	SC1_SCL0_US4,
+	SC1_SCL0_US5,
+	SC1_SCL0_US6,
+	SC1_SCL0_US7,
+	SC1_SCL0_US8,
+	SC1_SCL0_OVR1,
+	SC1_SCL1_UPDATE,
+	SC1_SCL1_WR1,
+	SC1_SCL1_WR2,
+	SC1_SCL1_WR3,
+	SC1_SCL1_WR4,
+	SC1_SCL1_WR5,
+	SC1_SCL1_WR6,
+	SC1_SCL1_WR7,
+	SC1_SCL1_WR8,
+	SC1_SCL1_WR9,
+	SC1_SCL1_WR10,
+	SC1_SCL1_WR11,
+	SC1_SCL1_MON1,
+	SC1_SCL1_PBUF0,
+	SC1_SCL1_PBUF1,
+	SC1_SCL1_PBUF2,
+	SC1_SCL1_PBUF3,
+	SC1_SCL1_PBUF_FLD,
+	SC1_SCL1_PBUF_CNT,
+
+	/* GRAPHICS 1 */
+	GR1_UPDATE,
+	GR1_FLM_RD,
+	GR1_FLM1,
+	GR1_FLM2,
+	GR1_FLM3,
+	GR1_FLM4,
+	GR1_FLM5,
+	GR1_FLM6,
+	GR1_AB1,
+	GR1_AB2,
+	GR1_AB3,
+	GR1_AB4,
+	GR1_AB5,
+	GR1_AB6,
+	GR1_AB7,
+	GR1_AB8,
+	GR1_AB9,
+	GR1_AB10,
+	GR1_AB11,
+	GR1_BASE,
+	GR1_CLUT,
+	GR1_MON,
+
+	/* IMAGE QUALITY IMPROVER 0 */
+	ADJ0_UPDATE,
+	ADJ0_BKSTR_SET,
+	ADJ0_ENH_TIM1,
+	ADJ0_ENH_TIM2,
+	ADJ0_ENH_TIM3,
+	ADJ0_ENH_SHP1,
+	ADJ0_ENH_SHP2,
+	ADJ0_ENH_SHP3,
+	ADJ0_ENH_SHP4,
+	ADJ0_ENH_SHP5,
+	ADJ0_ENH_SHP6,
+	ADJ0_ENH_LTI1,
+	ADJ0_ENH_LTI2,
+	ADJ0_MTX_MODE,
+	ADJ0_MTX_YG_ADJ0,
+	ADJ0_MTX_YG_ADJ1,
+	ADJ0_MTX_CBB_ADJ0,
+	ADJ0_MTX_CBB_ADJ1,
+	ADJ0_MTX_CRR_ADJ0,
+	ADJ0_MTX_CRR_ADJ1,
+
+	/* IMAGE QUALITY IMPROVER 1 */
+	ADJ1_UPDATE,
+	ADJ1_BKSTR_SET,
+	ADJ1_ENH_TIM1,
+	ADJ1_ENH_TIM2,
+	ADJ1_ENH_TIM3,
+	ADJ1_ENH_SHP1,
+	ADJ1_ENH_SHP2,
+	ADJ1_ENH_SHP3,
+	ADJ1_ENH_SHP4,
+	ADJ1_ENH_SHP5,
+	ADJ1_ENH_SHP6,
+	ADJ1_ENH_LTI1,
+	ADJ1_ENH_LTI2,
+	ADJ1_MTX_MODE,
+	ADJ1_MTX_YG_ADJ0,
+	ADJ1_MTX_YG_ADJ1,
+	ADJ1_MTX_CBB_ADJ0,
+	ADJ1_MTX_CBB_ADJ1,
+	ADJ1_MTX_CRR_ADJ0,
+	ADJ1_MTX_CRR_ADJ1,
+
+	/* GRAPHICS 2 */
+	GR2_UPDATE,
+	GR2_FLM_RD,
+	GR2_FLM1,
+	GR2_FLM2,
+	GR2_FLM3,
+	GR2_FLM4,
+	GR2_FLM5,
+	GR2_FLM6,
+	GR2_AB1,
+	GR2_AB2,
+	GR2_AB3,
+	GR2_AB4,
+	GR2_AB5,
+	GR2_AB6,
+	GR2_AB7,
+	GR2_AB8,
+	GR2_AB9,
+	GR2_AB10,
+	GR2_AB11,
+	GR2_BASE,
+	GR2_CLUT,
+	GR2_MON,
+
+	/* GRAPHICS 3 */
+	GR3_UPDATE,
+	GR3_FLM_RD,
+	GR3_FLM1,
+	GR3_FLM2,
+	GR3_FLM3,
+	GR3_FLM4,
+	GR3_FLM5,
+	GR3_FLM6,
+	GR3_AB1,
+	GR3_AB2,
+	GR3_AB3,
+	GR3_AB4,
+	GR3_AB5,
+	GR3_AB6,
+	GR3_AB7,
+	GR3_AB8,
+	GR3_AB9,
+	GR3_AB10,
+	GR3_AB11,
+	GR3_BASE,
+	GR3_CLUT_INT,
+	GR3_MON,
+
+	/* VIN SYNTHESIZER */
+	GR_VIN_UPDATE,
+	GR_VIN_AB1,
+	GR_VIN_AB2,
+	GR_VIN_AB3,
+	GR_VIN_AB4,
+	GR_VIN_AB5,
+	GR_VIN_AB6,
+	GR_VIN_AB7,
+	GR_VIN_BASE,
+	GR_VIN_MON,
+
+	/* OUTPUT IMAGE GENERATOR */
+	OIR_SCL0_UPDATE,
+	OIR_SCL0_FRC1,
+	OIR_SCL0_FRC2,
+	OIR_SCL0_FRC3,
+	OIR_SCL0_FRC4,
+	OIR_SCL0_FRC5,
+	OIR_SCL0_FRC6,
+	OIR_SCL0_FRC7,
+	OIR_SCL0_DS1,
+	OIR_SCL0_DS2,
+	OIR_SCL0_DS3,
+	OIR_SCL0_DS7,
+	OIR_SCL0_US1,
+	OIR_SCL0_US2,
+	OIR_SCL0_US3,
+	OIR_SCL0_US8,
+	OIR_SCL0_OVR1,
+	OIR_SCL1_UPDATE,
+	OIR_SCL1_WR1,
+	OIR_SCL1_WR2,
+	OIR_SCL1_WR3,
+	OIR_SCL1_WR4,
+	OIR_SCL1_WR5,
+	OIR_SCL1_WR6,
+	OIR_SCL1_WR7,
+
+	/* GRAPHICS OIR */
+	GR_OIR_UPDATE,
+	GR_OIR_FLM_RD,
+	GR_OIR_FLM1,
+	GR_OIR_FLM2,
+	GR_OIR_FLM3,
+	GR_OIR_FLM4,
+	GR_OIR_FLM5,
+	GR_OIR_FLM6,
+	GR_OIR_AB1,
+	GR_OIR_AB2,
+	GR_OIR_AB3,
+	GR_OIR_AB7,
+	GR_OIR_AB8,
+	GR_OIR_AB9,
+	GR_OIR_AB10,
+	GR_OIR_AB11,
+	GR_OIR_BASE,
+	GR_OIR_CLUT,
+	GR_OIR_MON,
+
+	/* GAMMA CORRECTION BLOCK */
+	GAM_G_UPDATE,
+	GAM_SW,
+	GAM_G_LUT1,
+	GAM_G_LUT2,
+	GAM_G_LUT3,
+	GAM_G_LUT4,
+	GAM_G_LUT5,
+	GAM_G_LUT6,
+	GAM_G_LUT7,
+	GAM_G_LUT8,
+	GAM_G_LUT9,
+	GAM_G_LUT10,
+	GAM_G_LUT11,
+	GAM_G_LUT12,
+	GAM_G_LUT13,
+	GAM_G_LUT14,
+	GAM_G_LUT15,
+	GAM_G_LUT16,
+	GAM_G_AREA1,
+	GAM_G_AREA2,
+	GAM_G_AREA3,
+	GAM_G_AREA4,
+	GAM_G_AREA5,
+	GAM_G_AREA6,
+	GAM_G_AREA7,
+	GAM_G_AREA8,
+	GAM_B_UPDATE,
+	GAM_B_LUT1,
+	GAM_B_LUT2,
+	GAM_B_LUT3,
+	GAM_B_LUT4,
+	GAM_B_LUT5,
+	GAM_B_LUT6,
+	GAM_B_LUT7,
+	GAM_B_LUT8,
+	GAM_B_LUT9,
+	GAM_B_LUT10,
+	GAM_B_LUT11,
+	GAM_B_LUT12,
+	GAM_B_LUT13,
+	GAM_B_LUT14,
+	GAM_B_LUT15,
+	GAM_B_LUT16,
+	GAM_B_AREA1,
+	GAM_B_AREA2,
+	GAM_B_AREA3,
+	GAM_B_AREA4,
+	GAM_B_AREA5,
+	GAM_B_AREA6,
+	GAM_B_AREA7,
+	GAM_B_AREA8,
+	GAM_R_UPDATE,
+	GAM_R_LUT1,
+	GAM_R_LUT2,
+	GAM_R_LUT3,
+	GAM_R_LUT4,
+	GAM_R_LUT5,
+	GAM_R_LUT6,
+	GAM_R_LUT7,
+	GAM_R_LUT8,
+	GAM_R_LUT9,
+	GAM_R_LUT10,
+	GAM_R_LUT11,
+	GAM_R_LUT12,
+	GAM_R_LUT13,
+	GAM_R_LUT14,
+	GAM_R_LUT15,
+	GAM_R_LUT16,
+	GAM_R_AREA1,
+	GAM_R_AREA2,
+	GAM_R_AREA3,
+	GAM_R_AREA4,
+	GAM_R_AREA5,
+	GAM_R_AREA6,
+	GAM_R_AREA7,
+	GAM_R_AREA8,
+
+	/* TCON BLOCK */
+	TCON_UPDATE,
+	TCON_TIM,
+	TCON_TIM_STVA1,
+	TCON_TIM_STVA2,
+	TCON_TIM_STVB1,
+	TCON_TIM_STVB2,
+	TCON_TIM_STH1,
+	TCON_TIM_STH2,
+	TCON_TIM_STB1,
+	TCON_TIM_STB2,
+	TCON_TIM_CPV1,
+	TCON_TIM_CPV2,
+	TCON_TIM_POLA1,
+	TCON_TIM_POLA2,
+	TCON_TIM_POLB1,
+	TCON_TIM_POLB2,
+	TCON_TIM_DE,
+
+	/* OUTPUT CONTROLLER */
+	OUT_UPDATE,
+	OUT_SET,
+	OUT_BRIGHT1,
+	OUT_BRIGHT2,
+	OUT_CONTRAST,
+	OUT_PDTHA,
+	OUT_CLK_PHASE,
+
+	/* SYSTEM CONTROLLER */
+	SYSCNT_INT1,
+	SYSCNT_INT2,
+	SYSCNT_INT3,
+	SYSCNT_INT4,
+	SYSCNT_INT5,
+	SYSCNT_INT6,
+	SYSCNT_PANEL_CLK,
+	SYSCNT_CLUT,
+
+	VDC5FB_MAX_REGS,
+};
+
+/* IRQ INDEX */
+enum {
+	S0_VI_VSYNC = 0,
+	S0_LO_VSYNC,
+	S0_VSYNCERR,
+	GR3_VLINE,
+	S0_VFIELD,
+	IV1_VBUFERR,
+	IV3_VBUFERR,
+	IV5_VBUFERR,
+	IV6_VBUFERR,
+	S0_WLINE,
+	S1_VI_VSYNC,
+	S1_LO_VSYNC,
+	S1_VSYNCERR,
+	S1_VFIELD,
+	IV2_VBUFERR,
+	IV4_VBUFERR,
+	S1_WLINE,
+	OIR_VI_VSYNC,
+	OIR_LO_VSYNC,
+	OIR_VLINE,
+	OIR_VFIELD,
+	IV7_VBUFERR,
+	IV8_VBUFERR,
+	VDC5FB_MAX_IRQS,
+};
+
+/* REGISTER ADDRESS OFFSET */
+#define	VDC5FB_OFFSET(x)	((x) - VDC5FB_REG_BASE(0))
+static unsigned long vdc5fb_offsets[VDC5FB_MAX_REGS] = {
+	/* INPUT CONTROLLER */
+	[INP_UPDATE]		= VDC5FB_OFFSET(0xFCFF7400),
+	[INP_SEL_CNT]		= VDC5FB_OFFSET(0xFCFF7404),
+	[INP_EXT_SYNC_CNT]	= VDC5FB_OFFSET(0xFCFF7408),
+	[INP_VSYNC_PH_ADJ]	= VDC5FB_OFFSET(0xFCFF740C),
+	[INP_DLY_ADJ]		= VDC5FB_OFFSET(0xFCFF7410),
+
+	/* IMAGE QUALITY ADJUSTMENT BLOCK */
+	[IMGCNT_UPDATE]		= VDC5FB_OFFSET(0xFCFF7480),
+	[IMGCNT_NR_CNT0]	= VDC5FB_OFFSET(0xFCFF7484),
+	[IMGCNT_NR_CNT1]	= VDC5FB_OFFSET(0xFCFF7488),
+	[IMGCNT_MTX_MODE]	= VDC5FB_OFFSET(0xFCFF74A0),
+	[IMGCNT_MTX_YG_ADJ0]	= VDC5FB_OFFSET(0xFCFF74A4),
+	[IMGCNT_MTX_YG_ADJ1]	= VDC5FB_OFFSET(0xFCFF74A8),
+	[IMGCNT_MTX_CBB_ADJ0]	= VDC5FB_OFFSET(0xFCFF74AC),
+	[IMGCNT_MTX_CBB_ADJ1]	= VDC5FB_OFFSET(0xFCFF74B0),
+	[IMGCNT_MTX_CRR_ADJ0]	= VDC5FB_OFFSET(0xFCFF74B4),
+	[IMGCNT_MTX_CRR_ADJ1]	= VDC5FB_OFFSET(0xFCFF74B8),
+	[IMGCNT_DRC_REG]	= VDC5FB_OFFSET(0xFCFF74C0),
+
+	/* SCALER 0 */
+	[SC0_SCL0_UPDATE]	= VDC5FB_OFFSET(0xFCFF7500),
+	[SC0_SCL0_FRC1]		= VDC5FB_OFFSET(0xFCFF7504),
+	[SC0_SCL0_FRC2]		= VDC5FB_OFFSET(0xFCFF7508),
+	[SC0_SCL0_FRC3]		= VDC5FB_OFFSET(0xFCFF750C),
+	[SC0_SCL0_FRC4]		= VDC5FB_OFFSET(0xFCFF7510),
+	[SC0_SCL0_FRC5]		= VDC5FB_OFFSET(0xFCFF7514),
+	[SC0_SCL0_FRC6]		= VDC5FB_OFFSET(0xFCFF7518),
+	[SC0_SCL0_FRC7]		= VDC5FB_OFFSET(0xFCFF751C),
+	[SC0_SCL0_FRC9]		= VDC5FB_OFFSET(0xFCFF7524),
+	[SC0_SCL0_MON0]		= VDC5FB_OFFSET(0xFCFF7528),	/* 16bit */
+	[SC0_SCL0_INT]		= VDC5FB_OFFSET(0xFCFF752A),	/* 16bit */
+	[SC0_SCL0_DS1]		= VDC5FB_OFFSET(0xFCFF752C),
+	[SC0_SCL0_DS2]		= VDC5FB_OFFSET(0xFCFF7530),
+	[SC0_SCL0_DS3]		= VDC5FB_OFFSET(0xFCFF7534),
+	[SC0_SCL0_DS4]		= VDC5FB_OFFSET(0xFCFF7538),
+	[SC0_SCL0_DS5]		= VDC5FB_OFFSET(0xFCFF753C),
+	[SC0_SCL0_DS6]		= VDC5FB_OFFSET(0xFCFF7540),
+	[SC0_SCL0_DS7]		= VDC5FB_OFFSET(0xFCFF7544),
+	[SC0_SCL0_US1]		= VDC5FB_OFFSET(0xFCFF7548),
+	[SC0_SCL0_US2]		= VDC5FB_OFFSET(0xFCFF754C),
+	[SC0_SCL0_US3]		= VDC5FB_OFFSET(0xFCFF7550),
+	[SC0_SCL0_US4]		= VDC5FB_OFFSET(0xFCFF7554),
+	[SC0_SCL0_US5]		= VDC5FB_OFFSET(0xFCFF7558),
+	[SC0_SCL0_US6]		= VDC5FB_OFFSET(0xFCFF755C),
+	[SC0_SCL0_US7]		= VDC5FB_OFFSET(0xFCFF7560),
+	[SC0_SCL0_US8]		= VDC5FB_OFFSET(0xFCFF7564),
+	[SC0_SCL0_OVR1]		= VDC5FB_OFFSET(0xFCFF756C),
+	[SC0_SCL1_UPDATE]	= VDC5FB_OFFSET(0xFCFF7580),
+	[SC0_SCL1_WR1]		= VDC5FB_OFFSET(0xFCFF7588),
+	[SC0_SCL1_WR2]		= VDC5FB_OFFSET(0xFCFF758C),
+	[SC0_SCL1_WR3]		= VDC5FB_OFFSET(0xFCFF7590),
+	[SC0_SCL1_WR4]		= VDC5FB_OFFSET(0xFCFF7594),
+	[SC0_SCL1_WR5]		= VDC5FB_OFFSET(0xFCFF759C),
+	[SC0_SCL1_WR6]		= VDC5FB_OFFSET(0xFCFF75A0),
+	[SC0_SCL1_WR7]		= VDC5FB_OFFSET(0xFCFF75A4),
+	[SC0_SCL1_WR8]		= VDC5FB_OFFSET(0xFCFF75A8),
+	[SC0_SCL1_WR9]		= VDC5FB_OFFSET(0xFCFF75AC),
+	[SC0_SCL1_WR10]		= VDC5FB_OFFSET(0xFCFF75B0),
+	[SC0_SCL1_WR11]		= VDC5FB_OFFSET(0xFCFF75B4),
+	[SC0_SCL1_MON1]		= VDC5FB_OFFSET(0xFCFF75B8),
+	[SC0_SCL1_PBUF0]	= VDC5FB_OFFSET(0xFCFF75BC),
+	[SC0_SCL1_PBUF1]	= VDC5FB_OFFSET(0xFCFF75C0),
+	[SC0_SCL1_PBUF2]	= VDC5FB_OFFSET(0xFCFF75C4),
+	[SC0_SCL1_PBUF3]	= VDC5FB_OFFSET(0xFCFF75C8),
+	[SC0_SCL1_PBUF_FLD]	= VDC5FB_OFFSET(0xFCFF75CC),
+	[SC0_SCL1_PBUF_CNT]	= VDC5FB_OFFSET(0xFCFF75D0),
+
+	/* GRAPHICS 0 */
+	[GR0_UPDATE]		= VDC5FB_OFFSET(0xFCFF7600),
+	[GR0_FLM_RD]		= VDC5FB_OFFSET(0xFCFF7604),
+	[GR0_FLM1]		= VDC5FB_OFFSET(0xFCFF7608),
+	[GR0_FLM2]		= VDC5FB_OFFSET(0xFCFF760C),
+	[GR0_FLM3]		= VDC5FB_OFFSET(0xFCFF7610),
+	[GR0_FLM4]		= VDC5FB_OFFSET(0xFCFF7614),
+	[GR0_FLM5]		= VDC5FB_OFFSET(0xFCFF7618),
+	[GR0_FLM6]		= VDC5FB_OFFSET(0xFCFF761C),
+	[GR0_AB1]		= VDC5FB_OFFSET(0xFCFF7620),
+	[GR0_AB2]		= VDC5FB_OFFSET(0xFCFF7624),
+	[GR0_AB3]		= VDC5FB_OFFSET(0xFCFF7628),
+	[GR0_AB7]		= VDC5FB_OFFSET(0xFCFF7638),
+	[GR0_AB8]		= VDC5FB_OFFSET(0xFCFF763C),
+	[GR0_AB9]		= VDC5FB_OFFSET(0xFCFF7640),
+	[GR0_AB10]		= VDC5FB_OFFSET(0xFCFF7644),
+	[GR0_AB11]		= VDC5FB_OFFSET(0xFCFF7648),
+	[GR0_BASE]		= VDC5FB_OFFSET(0xFCFF764C),
+	[GR0_CLUT]		= VDC5FB_OFFSET(0xFCFF7650),
+	[GR0_MON]		= VDC5FB_OFFSET(0xFCFF7654),
+
+	/* SCALER 1 */
+	[SC1_SCL0_UPDATE]	= VDC5FB_OFFSET(0xFCFF7C00),
+	[SC1_SCL0_FRC1]		= VDC5FB_OFFSET(0xFCFF7C04),
+	[SC1_SCL0_FRC2]		= VDC5FB_OFFSET(0xFCFF7C08),
+	[SC1_SCL0_FRC3]		= VDC5FB_OFFSET(0xFCFF7C0C),
+	[SC1_SCL0_FRC4]		= VDC5FB_OFFSET(0xFCFF7C10),
+	[SC1_SCL0_FRC5]		= VDC5FB_OFFSET(0xFCFF7C14),
+	[SC1_SCL0_FRC6]		= VDC5FB_OFFSET(0xFCFF7C18),
+	[SC1_SCL0_FRC7]		= VDC5FB_OFFSET(0xFCFF7C1C),
+	[SC1_SCL0_FRC9]		= VDC5FB_OFFSET(0xFCFF7C20),
+	[SC1_SCL0_MON0]		= VDC5FB_OFFSET(0xFCFF7C24),
+	[SC1_SCL0_INT]		= VDC5FB_OFFSET(0xFCFF7C28),
+	[SC1_SCL0_DS1]		= VDC5FB_OFFSET(0xFCFF7C2C),
+	[SC1_SCL0_DS2]		= VDC5FB_OFFSET(0xFCFF7C30),
+	[SC1_SCL0_DS3]		= VDC5FB_OFFSET(0xFCFF7C34),
+	[SC1_SCL0_DS4]		= VDC5FB_OFFSET(0xFCFF7C38),
+	[SC1_SCL0_DS5]		= VDC5FB_OFFSET(0xFCFF7C3C),
+	[SC1_SCL0_DS6]		= VDC5FB_OFFSET(0xFCFF7C40),
+	[SC1_SCL0_DS7]		= VDC5FB_OFFSET(0xFCFF7C44),
+	[SC1_SCL0_US1]		= VDC5FB_OFFSET(0xFCFF7C48),
+	[SC1_SCL0_US2]		= VDC5FB_OFFSET(0xFCFF7C4C),
+	[SC1_SCL0_US3]		= VDC5FB_OFFSET(0xFCFF7C50),
+	[SC1_SCL0_US4]		= VDC5FB_OFFSET(0xFCFF7C54),
+	[SC1_SCL0_US5]		= VDC5FB_OFFSET(0xFCFF7C58),
+	[SC1_SCL0_US6]		= VDC5FB_OFFSET(0xFCFF7C5C),
+	[SC1_SCL0_US7]		= VDC5FB_OFFSET(0xFCFF7C60),
+	[SC1_SCL0_US8]		= VDC5FB_OFFSET(0xFCFF7C64),
+	[SC1_SCL0_OVR1]		= VDC5FB_OFFSET(0xFCFF7C6C),
+	[SC1_SCL1_UPDATE]	= VDC5FB_OFFSET(0xFCFF7C80),
+	[SC1_SCL1_WR1]		= VDC5FB_OFFSET(0xFCFF7C88),
+	[SC1_SCL1_WR2]		= VDC5FB_OFFSET(0xFCFF7C8C),
+	[SC1_SCL1_WR3]		= VDC5FB_OFFSET(0xFCFF7C90),
+	[SC1_SCL1_WR4]		= VDC5FB_OFFSET(0xFCFF7C94),
+	[SC1_SCL1_WR5]		= VDC5FB_OFFSET(0xFCFF7C9C),
+	[SC1_SCL1_WR6]		= VDC5FB_OFFSET(0xFCFF7CA0),
+	[SC1_SCL1_WR7]		= VDC5FB_OFFSET(0xFCFF7CA4),
+	[SC1_SCL1_WR8]		= VDC5FB_OFFSET(0xFCFF7CA8),
+	[SC1_SCL1_WR9]		= VDC5FB_OFFSET(0xFCFF7CAC),
+	[SC1_SCL1_WR10]		= VDC5FB_OFFSET(0xFCFF7CB0),
+	[SC1_SCL1_WR11]		= VDC5FB_OFFSET(0xFCFF7CB4),
+	[SC1_SCL1_MON1]		= VDC5FB_OFFSET(0xFCFF7CB8),
+	[SC1_SCL1_PBUF0]	= VDC5FB_OFFSET(0xFCFF7CBC),
+	[SC1_SCL1_PBUF1]	= VDC5FB_OFFSET(0xFCFF7CC0),
+	[SC1_SCL1_PBUF2]	= VDC5FB_OFFSET(0xFCFF7CC4),
+	[SC1_SCL1_PBUF3]	= VDC5FB_OFFSET(0xFCFF7CC9),
+	[SC1_SCL1_PBUF_FLD]	= VDC5FB_OFFSET(0xFCFF7CCC),
+	[SC1_SCL1_PBUF_CNT]	= VDC5FB_OFFSET(0xFCFF7CD0),
+
+	/* GRAPHICS 1 */
+	[GR1_UPDATE]		= VDC5FB_OFFSET(0xFCFF7D00),
+	[GR1_FLM_RD]		= VDC5FB_OFFSET(0xFCFF7D04),
+	[GR1_FLM1]		= VDC5FB_OFFSET(0xFCFF7D08),
+	[GR1_FLM2]		= VDC5FB_OFFSET(0xFCFF7D0C),
+	[GR1_FLM3]		= VDC5FB_OFFSET(0xFCFF7D10),
+	[GR1_FLM4]		= VDC5FB_OFFSET(0xFCFF7D14),
+	[GR1_FLM5]		= VDC5FB_OFFSET(0xFCFF7D18),
+	[GR1_FLM6]		= VDC5FB_OFFSET(0xFCFF7D1C),
+	[GR1_AB1]		= VDC5FB_OFFSET(0xFCFF7D20),
+	[GR1_AB2]		= VDC5FB_OFFSET(0xFCFF7D24),
+	[GR1_AB3]		= VDC5FB_OFFSET(0xFCFF7D28),
+	[GR1_AB4]		= VDC5FB_OFFSET(0xFCFF7D2C),
+	[GR1_AB5]		= VDC5FB_OFFSET(0xFCFF7D30),
+	[GR1_AB6]		= VDC5FB_OFFSET(0xFCFF7D34),
+	[GR1_AB7]		= VDC5FB_OFFSET(0xFCFF7D38),
+	[GR1_AB8]		= VDC5FB_OFFSET(0xFCFF7D3C),
+	[GR1_AB9]		= VDC5FB_OFFSET(0xFCFF7D40),
+	[GR1_AB10]		= VDC5FB_OFFSET(0xFCFF7D44),
+	[GR1_AB11]		= VDC5FB_OFFSET(0xFCFF7D48),
+	[GR1_BASE]		= VDC5FB_OFFSET(0xFCFF7D4C),
+	[GR1_CLUT]		= VDC5FB_OFFSET(0xFCFF7D50),
+	[GR1_MON]		= VDC5FB_OFFSET(0xFCFF7D54),
+
+	/* IMAGE QUALITY IMPROVER 0 */
+	[ADJ0_UPDATE]		= VDC5FB_OFFSET(0xFCFF7680),
+	[ADJ0_BKSTR_SET]	= VDC5FB_OFFSET(0xFCFF7684),
+	[ADJ0_ENH_TIM1]		= VDC5FB_OFFSET(0xFCFF7688),
+	[ADJ0_ENH_TIM2]		= VDC5FB_OFFSET(0xFCFF768C),
+	[ADJ0_ENH_TIM3]		= VDC5FB_OFFSET(0xFCFF7690),
+	[ADJ0_ENH_SHP1]		= VDC5FB_OFFSET(0xFCFF7694),
+	[ADJ0_ENH_SHP2]		= VDC5FB_OFFSET(0xFCFF7698),
+	[ADJ0_ENH_SHP3]		= VDC5FB_OFFSET(0xFCFF769C),
+	[ADJ0_ENH_SHP4]		= VDC5FB_OFFSET(0xFCFF76A0),
+	[ADJ0_ENH_SHP5]		= VDC5FB_OFFSET(0xFCFF76A4),
+	[ADJ0_ENH_SHP6]		= VDC5FB_OFFSET(0xFCFF76A8),
+	[ADJ0_ENH_LTI1]		= VDC5FB_OFFSET(0xFCFF76AC),
+	[ADJ0_ENH_LTI2]		= VDC5FB_OFFSET(0xFCFF76B0),
+	[ADJ0_MTX_MODE]		= VDC5FB_OFFSET(0xFCFF76B4),
+	[ADJ0_MTX_YG_ADJ0]	= VDC5FB_OFFSET(0xFCFF76B8),
+	[ADJ0_MTX_YG_ADJ1]	= VDC5FB_OFFSET(0xFCFF76BC),
+	[ADJ0_MTX_CBB_ADJ0]	= VDC5FB_OFFSET(0xFCFF76C0),
+	[ADJ0_MTX_CBB_ADJ1]	= VDC5FB_OFFSET(0xFCFF76C4),
+	[ADJ0_MTX_CRR_ADJ0]	= VDC5FB_OFFSET(0xFCFF76C8),
+	[ADJ0_MTX_CRR_ADJ1]	= VDC5FB_OFFSET(0xFCFF76CC),
+
+	/* IMAGE QUALITY IMPROVER 1 */
+	[ADJ1_UPDATE]		= VDC5FB_OFFSET(0xFCFF7D80),
+	[ADJ1_BKSTR_SET]	= VDC5FB_OFFSET(0xFCFF7D84),
+	[ADJ1_ENH_TIM1]		= VDC5FB_OFFSET(0xFCFF7D88),
+	[ADJ1_ENH_TIM2]		= VDC5FB_OFFSET(0xFCFF7D8C),
+	[ADJ1_ENH_TIM3]		= VDC5FB_OFFSET(0xFCFF7D90),
+	[ADJ1_ENH_SHP1]		= VDC5FB_OFFSET(0xFCFF7D94),
+	[ADJ1_ENH_SHP2]		= VDC5FB_OFFSET(0xFCFF7D98),
+	[ADJ1_ENH_SHP3]		= VDC5FB_OFFSET(0xFCFF7D9C),
+	[ADJ1_ENH_SHP4]		= VDC5FB_OFFSET(0xFCFF7DA0),
+	[ADJ1_ENH_SHP5]		= VDC5FB_OFFSET(0xFCFF7DA4),
+	[ADJ1_ENH_SHP6]		= VDC5FB_OFFSET(0xFCFF7DA8),
+	[ADJ1_ENH_LTI1]		= VDC5FB_OFFSET(0xFCFF7DA8),
+	[ADJ1_ENH_LTI2]		= VDC5FB_OFFSET(0xFCFF7DB0),
+	[ADJ1_MTX_MODE]		= VDC5FB_OFFSET(0xFCFF7DB4),
+	[ADJ1_MTX_YG_ADJ0]	= VDC5FB_OFFSET(0xFCFF7DB8),
+	[ADJ1_MTX_YG_ADJ1]	= VDC5FB_OFFSET(0xFCFF7DBC),
+	[ADJ1_MTX_CBB_ADJ0]	= VDC5FB_OFFSET(0xFCFF7DC0),
+	[ADJ1_MTX_CBB_ADJ1]	= VDC5FB_OFFSET(0xFCFF7CC4),
+	[ADJ1_MTX_CRR_ADJ0]	= VDC5FB_OFFSET(0xFCFF7DC8),
+	[ADJ1_MTX_CRR_ADJ1]	= VDC5FB_OFFSET(0xFCFF7DCC),
+
+	/* GRAPHICS 2 */
+	[GR2_UPDATE]		= VDC5FB_OFFSET(0xFCFF7700),
+	[GR2_FLM_RD]		= VDC5FB_OFFSET(0xFCFF7704),
+	[GR2_FLM1]		= VDC5FB_OFFSET(0xFCFF7708),
+	[GR2_FLM2]		= VDC5FB_OFFSET(0xFCFF770C),
+	[GR2_FLM3]		= VDC5FB_OFFSET(0xFCFF7710),
+	[GR2_FLM4]		= VDC5FB_OFFSET(0xFCFF7714),
+	[GR2_FLM5]		= VDC5FB_OFFSET(0xFCFF7718),
+	[GR2_FLM6]		= VDC5FB_OFFSET(0xFCFF771C),
+	[GR2_AB1]		= VDC5FB_OFFSET(0xFCFF7720),
+	[GR2_AB2]		= VDC5FB_OFFSET(0xFCFF7724),
+	[GR2_AB3]		= VDC5FB_OFFSET(0xFCFF7728),
+	[GR2_AB4]		= VDC5FB_OFFSET(0xFCFF772C),
+	[GR2_AB5]		= VDC5FB_OFFSET(0xFCFF7730),
+	[GR2_AB6]		= VDC5FB_OFFSET(0xFCFF7734),
+	[GR2_AB7]		= VDC5FB_OFFSET(0xFCFF7738),
+	[GR2_AB8]		= VDC5FB_OFFSET(0xFCFF773C),
+	[GR2_AB9]		= VDC5FB_OFFSET(0xFCFF7740),
+	[GR2_AB10]		= VDC5FB_OFFSET(0xFCFF7744),
+	[GR2_AB11]		= VDC5FB_OFFSET(0xFCFF7748),
+	[GR2_BASE]		= VDC5FB_OFFSET(0xFCFF774C),
+	[GR2_CLUT]		= VDC5FB_OFFSET(0xFCFF7750),
+	[GR2_MON]		= VDC5FB_OFFSET(0xFCFF7754),
+
+	/* GRAPHICS 3 */
+	[GR3_UPDATE]		= VDC5FB_OFFSET(0xFCFF7780),
+	[GR3_FLM_RD]		= VDC5FB_OFFSET(0xFCFF7784),
+	[GR3_FLM1]		= VDC5FB_OFFSET(0xFCFF7788),
+	[GR3_FLM2]		= VDC5FB_OFFSET(0xFCFF778C),
+	[GR3_FLM3]		= VDC5FB_OFFSET(0xFCFF7790),
+	[GR3_FLM4]		= VDC5FB_OFFSET(0xFCFF7794),
+	[GR3_FLM5]		= VDC5FB_OFFSET(0xFCFF7798),
+	[GR3_FLM6]		= VDC5FB_OFFSET(0xFCFF779C),
+	[GR3_AB1]		= VDC5FB_OFFSET(0xFCFF77A0),
+	[GR3_AB2]		= VDC5FB_OFFSET(0xFCFF77A4),
+	[GR3_AB3]		= VDC5FB_OFFSET(0xFCFF77A8),
+	[GR3_AB4]		= VDC5FB_OFFSET(0xFCFF77AC),
+	[GR3_AB5]		= VDC5FB_OFFSET(0xFCFF77B0),
+	[GR3_AB6]		= VDC5FB_OFFSET(0xFCFF77B4),
+	[GR3_AB7]		= VDC5FB_OFFSET(0xFCFF77B8),
+	[GR3_AB8]		= VDC5FB_OFFSET(0xFCFF77BC),
+	[GR3_AB9]		= VDC5FB_OFFSET(0xFCFF77C0),
+	[GR3_AB10]		= VDC5FB_OFFSET(0xFCFF77C4),
+	[GR3_AB11]		= VDC5FB_OFFSET(0xFCFF77C8),
+	[GR3_BASE]		= VDC5FB_OFFSET(0xFCFF77CC),
+	[GR3_CLUT_INT]		= VDC5FB_OFFSET(0xFCFF77D0),
+	[GR3_MON]		= VDC5FB_OFFSET(0xFCFF77D4),
+
+	/* VIN SYNTHESIZER */
+	[GR_VIN_UPDATE]		= VDC5FB_OFFSET(0xFCFF7E00),
+	[GR_VIN_AB1]		= VDC5FB_OFFSET(0xFCFF7E20),
+	[GR_VIN_AB2]		= VDC5FB_OFFSET(0xFCFF7E24),
+	[GR_VIN_AB3]		= VDC5FB_OFFSET(0xFCFF7E28),
+	[GR_VIN_AB4]		= VDC5FB_OFFSET(0xFCFF7E2C),
+	[GR_VIN_AB5]		= VDC5FB_OFFSET(0xFCFF7E30),
+	[GR_VIN_AB6]		= VDC5FB_OFFSET(0xFCFF7E34),
+	[GR_VIN_AB7]		= VDC5FB_OFFSET(0xFCFF7E38),
+	[GR_VIN_BASE]		= VDC5FB_OFFSET(0xFCFF7E4C),
+	[GR_VIN_MON]		= VDC5FB_OFFSET(0xFCFF7E54),
+
+	/* OUTPUT IMAGE GENERATOR */
+	[OIR_SCL0_UPDATE]	= VDC5FB_OFFSET(0xFCFF7E80),
+	[OIR_SCL0_FRC1]		= VDC5FB_OFFSET(0xFCFF7E84),
+	[OIR_SCL0_FRC2]		= VDC5FB_OFFSET(0xFCFF7E88),
+	[OIR_SCL0_FRC3]		= VDC5FB_OFFSET(0xFCFF7E8C),
+	[OIR_SCL0_FRC4]		= VDC5FB_OFFSET(0xFCFF7E90),
+	[OIR_SCL0_FRC5]		= VDC5FB_OFFSET(0xFCFF7E94),
+	[OIR_SCL0_FRC6]		= VDC5FB_OFFSET(0xFCFF7E98),
+	[OIR_SCL0_FRC7]		= VDC5FB_OFFSET(0xFCFF7E9C),
+	[OIR_SCL0_DS1]		= VDC5FB_OFFSET(0xFCFF7EAC),
+	[OIR_SCL0_DS2]		= VDC5FB_OFFSET(0xFCFF7EB0),
+	[OIR_SCL0_DS3]		= VDC5FB_OFFSET(0xFCFF7EB4),
+	[OIR_SCL0_DS7]		= VDC5FB_OFFSET(0xFCFF7EC4),
+	[OIR_SCL0_US1]		= VDC5FB_OFFSET(0xFCFF7EC8),
+	[OIR_SCL0_US2]		= VDC5FB_OFFSET(0xFCFF7ECC),
+	[OIR_SCL0_US3]		= VDC5FB_OFFSET(0xFCFF7ED0),
+	[OIR_SCL0_US8]		= VDC5FB_OFFSET(0xFCFF7EE4),
+	[OIR_SCL0_OVR1]		= VDC5FB_OFFSET(0xFCFF7EEC),
+	[OIR_SCL1_UPDATE]	= VDC5FB_OFFSET(0xFCFF7F00),
+	[OIR_SCL1_WR1]		= VDC5FB_OFFSET(0xFCFF7F08),
+	[OIR_SCL1_WR2]		= VDC5FB_OFFSET(0xFCFF7F0C),
+	[OIR_SCL1_WR3]		= VDC5FB_OFFSET(0xFCFF7F10),
+	[OIR_SCL1_WR4]		= VDC5FB_OFFSET(0xFCFF7F14),
+	[OIR_SCL1_WR5]		= VDC5FB_OFFSET(0xFCFF7F1C),
+	[OIR_SCL1_WR6]		= VDC5FB_OFFSET(0xFCFF7F20),
+	[OIR_SCL1_WR7]		= VDC5FB_OFFSET(0xFCFF7F24),
+
+	/* GRAPHICS OIR */
+	[GR_OIR_UPDATE]		= VDC5FB_OFFSET(0xFCFF7F80),
+	[GR_OIR_FLM_RD]		= VDC5FB_OFFSET(0xFCFF7F84),
+	[GR_OIR_FLM1]		= VDC5FB_OFFSET(0xFCFF7F88),
+	[GR_OIR_FLM2]		= VDC5FB_OFFSET(0xFCFF7F8C),
+	[GR_OIR_FLM3]		= VDC5FB_OFFSET(0xFCFF7F90),
+	[GR_OIR_FLM4]		= VDC5FB_OFFSET(0xFCFF7F94),
+	[GR_OIR_FLM5]		= VDC5FB_OFFSET(0xFCFF7F98),
+	[GR_OIR_FLM6]		= VDC5FB_OFFSET(0xFCFF7F9C),
+	[GR_OIR_AB1]		= VDC5FB_OFFSET(0xFCFF7FA0),
+	[GR_OIR_AB2]		= VDC5FB_OFFSET(0xFCFF7FA4),
+	[GR_OIR_AB3]		= VDC5FB_OFFSET(0xFCFF7FA8),
+	[GR_OIR_AB7]		= VDC5FB_OFFSET(0xFCFF7FB8),
+	[GR_OIR_AB8]		= VDC5FB_OFFSET(0xFCFF7FBC),
+	[GR_OIR_AB9]		= VDC5FB_OFFSET(0xFCFF7FC0),
+	[GR_OIR_AB10]		= VDC5FB_OFFSET(0xFCFF7FC4),
+	[GR_OIR_AB11]		= VDC5FB_OFFSET(0xFCFF7FC8),
+	[GR_OIR_BASE]		= VDC5FB_OFFSET(0xFCFF7FCC),
+	[GR_OIR_CLUT]		= VDC5FB_OFFSET(0xFCFF7FD0),
+	[GR_OIR_MON]		= VDC5FB_OFFSET(0xFCFF7FD4),
+
+	/* GAMMA CORRECTION BLOCK */
+	[GAM_G_UPDATE]		= VDC5FB_OFFSET(0xFCFF7800),
+	[GAM_SW]		= VDC5FB_OFFSET(0xFCFF7804),
+	[GAM_G_LUT1]		= VDC5FB_OFFSET(0xFCFF7808),
+	[GAM_G_LUT2]		= VDC5FB_OFFSET(0xFCFF780C),
+	[GAM_G_LUT3]		= VDC5FB_OFFSET(0xFCFF7810),
+	[GAM_G_LUT4]		= VDC5FB_OFFSET(0xFCFF7814),
+	[GAM_G_LUT5]		= VDC5FB_OFFSET(0xFCFF7818),
+	[GAM_G_LUT6]		= VDC5FB_OFFSET(0xFCFF781C),
+	[GAM_G_LUT7]		= VDC5FB_OFFSET(0xFCFF7820),
+	[GAM_G_LUT8]		= VDC5FB_OFFSET(0xFCFF7824),
+	[GAM_G_LUT9]		= VDC5FB_OFFSET(0xFCFF7828),
+	[GAM_G_LUT10]		= VDC5FB_OFFSET(0xFCFF782C),
+	[GAM_G_LUT11]		= VDC5FB_OFFSET(0xFCFF7830),
+	[GAM_G_LUT12]		= VDC5FB_OFFSET(0xFCFF7834),
+	[GAM_G_LUT13]		= VDC5FB_OFFSET(0xFCFF7838),
+	[GAM_G_LUT14]		= VDC5FB_OFFSET(0xFCFF783C),
+	[GAM_G_LUT15]		= VDC5FB_OFFSET(0xFCFF7840),
+	[GAM_G_LUT16]		= VDC5FB_OFFSET(0xFCFF7844),
+	[GAM_G_AREA1]		= VDC5FB_OFFSET(0xFCFF7848),
+	[GAM_G_AREA2]		= VDC5FB_OFFSET(0xFCFF784C),
+	[GAM_G_AREA3]		= VDC5FB_OFFSET(0xFCFF7850),
+	[GAM_G_AREA4]		= VDC5FB_OFFSET(0xFCFF7854),
+	[GAM_G_AREA5]		= VDC5FB_OFFSET(0xFCFF7858),
+	[GAM_G_AREA6]		= VDC5FB_OFFSET(0xFCFF785C),
+	[GAM_G_AREA7]		= VDC5FB_OFFSET(0xFCFF7860),
+	[GAM_G_AREA8]		= VDC5FB_OFFSET(0xFCFF7864),
+	[GAM_B_UPDATE]		= VDC5FB_OFFSET(0xFCFF7880),
+	[GAM_B_LUT1]		= VDC5FB_OFFSET(0xFCFF7888),
+	[GAM_B_LUT2]		= VDC5FB_OFFSET(0xFCFF788C),
+	[GAM_B_LUT3]		= VDC5FB_OFFSET(0xFCFF7890),
+	[GAM_B_LUT4]		= VDC5FB_OFFSET(0xFCFF7894),
+	[GAM_B_LUT5]		= VDC5FB_OFFSET(0xFCFF7898),
+	[GAM_B_LUT6]		= VDC5FB_OFFSET(0xFCFF789C),
+	[GAM_B_LUT7]		= VDC5FB_OFFSET(0xFCFF78A0),
+	[GAM_B_LUT8]		= VDC5FB_OFFSET(0xFCFF78A4),
+	[GAM_B_LUT9]		= VDC5FB_OFFSET(0xFCFF78A8),
+	[GAM_B_LUT10]		= VDC5FB_OFFSET(0xFCFF78AC),
+	[GAM_B_LUT11]		= VDC5FB_OFFSET(0xFCFF78B0),
+	[GAM_B_LUT12]		= VDC5FB_OFFSET(0xFCFF78B4),
+	[GAM_B_LUT13]		= VDC5FB_OFFSET(0xFCFF78B8),
+	[GAM_B_LUT14]		= VDC5FB_OFFSET(0xFCFF78BC),
+	[GAM_B_LUT15]		= VDC5FB_OFFSET(0xFCFF78C0),
+	[GAM_B_LUT16]		= VDC5FB_OFFSET(0xFCFF78C4),
+	[GAM_B_AREA1]		= VDC5FB_OFFSET(0xFCFF78C8),
+	[GAM_B_AREA2]		= VDC5FB_OFFSET(0xFCFF78CC),
+	[GAM_B_AREA3]		= VDC5FB_OFFSET(0xFCFF78D0),
+	[GAM_B_AREA4]		= VDC5FB_OFFSET(0xFCFF78D4),
+	[GAM_B_AREA5]		= VDC5FB_OFFSET(0xFCFF78D8),
+	[GAM_B_AREA6]		= VDC5FB_OFFSET(0xFCFF78DC),
+	[GAM_B_AREA7]		= VDC5FB_OFFSET(0xFCFF78E0),
+	[GAM_B_AREA8]		= VDC5FB_OFFSET(0xFCFF78E4),
+	[GAM_R_UPDATE]		= VDC5FB_OFFSET(0xFCFF7900),
+	[GAM_R_LUT1]		= VDC5FB_OFFSET(0xFCFF7908),
+	[GAM_R_LUT2]		= VDC5FB_OFFSET(0xFCFF790C),
+	[GAM_R_LUT3]		= VDC5FB_OFFSET(0xFCFF7910),
+	[GAM_R_LUT4]		= VDC5FB_OFFSET(0xFCFF7914),
+	[GAM_R_LUT5]		= VDC5FB_OFFSET(0xFCFF7918),
+	[GAM_R_LUT6]		= VDC5FB_OFFSET(0xFCFF791C),
+	[GAM_R_LUT7]		= VDC5FB_OFFSET(0xFCFF7920),
+	[GAM_R_LUT8]		= VDC5FB_OFFSET(0xFCFF7924),
+	[GAM_R_LUT9]		= VDC5FB_OFFSET(0xFCFF7928),
+	[GAM_R_LUT10]		= VDC5FB_OFFSET(0xFCFF792C),
+	[GAM_R_LUT11]		= VDC5FB_OFFSET(0xFCFF7930),
+	[GAM_R_LUT12]		= VDC5FB_OFFSET(0xFCFF7934),
+	[GAM_R_LUT13]		= VDC5FB_OFFSET(0xFCFF7938),
+	[GAM_R_LUT14]		= VDC5FB_OFFSET(0xFCFF793C),
+	[GAM_R_LUT15]		= VDC5FB_OFFSET(0xFCFF7940),
+	[GAM_R_LUT16]		= VDC5FB_OFFSET(0xFCFF7944),
+	[GAM_R_AREA1]		= VDC5FB_OFFSET(0xFCFF7948),
+	[GAM_R_AREA2]		= VDC5FB_OFFSET(0xFCFF794C),
+	[GAM_R_AREA3]		= VDC5FB_OFFSET(0xFCFF7950),
+	[GAM_R_AREA4]		= VDC5FB_OFFSET(0xFCFF7954),
+	[GAM_R_AREA5]		= VDC5FB_OFFSET(0xFCFF7958),
+	[GAM_R_AREA6]		= VDC5FB_OFFSET(0xFCFF795C),
+	[GAM_R_AREA7]		= VDC5FB_OFFSET(0xFCFF7960),
+	[GAM_R_AREA8]		= VDC5FB_OFFSET(0xFCFF7964),
+
+	/* TCON BLOCK */
+	[TCON_UPDATE]		= VDC5FB_OFFSET(0xFCFF7980),
+	[TCON_TIM]		= VDC5FB_OFFSET(0xFCFF7984),
+	[TCON_TIM_STVA1]	= VDC5FB_OFFSET(0xFCFF7988),
+	[TCON_TIM_STVA2]	= VDC5FB_OFFSET(0xFCFF798C),
+	[TCON_TIM_STVB1]	= VDC5FB_OFFSET(0xFCFF7990),
+	[TCON_TIM_STVB2]	= VDC5FB_OFFSET(0xFCFF7994),
+	[TCON_TIM_STH1]		= VDC5FB_OFFSET(0xFCFF7998),
+	[TCON_TIM_STH2]		= VDC5FB_OFFSET(0xFCFF799C),
+	[TCON_TIM_STB1]		= VDC5FB_OFFSET(0xFCFF79A0),
+	[TCON_TIM_STB2]		= VDC5FB_OFFSET(0xFCFF79A4),
+	[TCON_TIM_CPV1]		= VDC5FB_OFFSET(0xFCFF79A8),
+	[TCON_TIM_CPV2]		= VDC5FB_OFFSET(0xFCFF79AC),
+	[TCON_TIM_POLA1]	= VDC5FB_OFFSET(0xFCFF79B0),
+	[TCON_TIM_POLA2]	= VDC5FB_OFFSET(0xFCFF79B4),
+	[TCON_TIM_POLB1]	= VDC5FB_OFFSET(0xFCFF79B8),
+	[TCON_TIM_POLB2]	= VDC5FB_OFFSET(0xFCFF79BC),
+	[TCON_TIM_DE]		= VDC5FB_OFFSET(0xFCFF79C0),
+
+	/* OUTPUT CONTROLLER */
+	[OUT_UPDATE]		= VDC5FB_OFFSET(0xFCFF7A00),
+	[OUT_SET]		= VDC5FB_OFFSET(0xFCFF7A04),
+	[OUT_BRIGHT1]		= VDC5FB_OFFSET(0xFCFF7A08),
+	[OUT_BRIGHT2]		= VDC5FB_OFFSET(0xFCFF7A0C),
+	[OUT_CONTRAST]		= VDC5FB_OFFSET(0xFCFF7A10),
+	[OUT_PDTHA]		= VDC5FB_OFFSET(0xFCFF7A14),
+	[OUT_CLK_PHASE]		= VDC5FB_OFFSET(0xFCFF7A24),
+
+	/* SYSTEM CONTROLLER */
+	[SYSCNT_INT1]		= VDC5FB_OFFSET(0xFCFF7A80),
+	[SYSCNT_INT2]		= VDC5FB_OFFSET(0xFCFF7A84),
+	[SYSCNT_INT3]		= VDC5FB_OFFSET(0xFCFF7A88),
+	[SYSCNT_INT4]		= VDC5FB_OFFSET(0xFCFF7A8C),
+	[SYSCNT_INT5]		= VDC5FB_OFFSET(0xFCFF7A90),
+	[SYSCNT_INT6]		= VDC5FB_OFFSET(0xFCFF7A94),
+	[SYSCNT_PANEL_CLK]	= VDC5FB_OFFSET(0xFCFF7A98), /* 16-bit */
+	[SYSCNT_CLUT]		= VDC5FB_OFFSET(0xFCFF7A9A), /* 16-bit */
+};
+
+/* INTERRUPT NAME */
+static const char *irq_names[VDC5FB_MAX_IRQS] = {
+	[S0_VI_VSYNC]		= "s0_vi_vsync",
+	[S0_LO_VSYNC]		= "s0_lo_vsync",
+	[S0_VSYNCERR]		= "s0_vsyncerr",
+	[GR3_VLINE]		= "gr3_vline",
+	[S0_VFIELD]		= "s0_vfield",
+	[IV1_VBUFERR]		= "iv1_vbuferr",
+	[IV3_VBUFERR]		= "iv3_vbuferr",
+	[IV5_VBUFERR]		= "iv5_vbuferr",
+	[IV6_VBUFERR]		= "iv6_vbuferr",
+	[S0_WLINE]		= "s0_wline",
+	[S1_VI_VSYNC]		= "s1_vi_vsync",
+	[S1_LO_VSYNC]		= "s1_lo_vsync",
+	[S1_VSYNCERR]		= "s1_vsyncerr",
+	[S1_VFIELD]		= "s1_vfield",
+	[IV2_VBUFERR]		= "iv2_vbuferr",
+	[IV4_VBUFERR]		= "iv4_vbuferr",
+	[S1_WLINE]		= "s1_wline",
+	[OIR_VI_VSYNC]		= "oir_vi_vsync",
+	[OIR_LO_VSYNC]		= "oir_lo_vsync",
+	[OIR_VLINE]		= "oir_vline",
+	[OIR_VFIELD]		= "oir_vfield",
+	[IV7_VBUFERR]		= "iv7_vbuferr",
+	[IV8_VBUFERR]		= "iv8_vbuferr",
+};
+
+/************************************************************************/
+/* REGISTER BITS */
+
+#define	RGB888(r, g, b)		\
+	((((r) & 0xffu) << 16) | (((g) & 0xffu) << 8) | ((b) & 0xffu))
+#define	GBR888(g, b, r)		\
+	((((g) & 0xffu) << 16) | (((b) & 0xffu) << 8) | ((r) & 0xffu))
+#define	AGBR(a, g, b, r)		\
+	((((a) & 0xffu) << 24) | (((g) & 0xffu) << 16) \
+	| (((b) & 0xffu) << 8) | ((r) & 0xffu))
+
+/* SYSCNT_PANEL_CLK */
+#define	PANEL_DCDR(x)		(((x) & 0x3fu) << 0)
+#define PANEL_ICKEN		(1u << 8)
+#define PANEL_OCKSEL(x)		(((x) & 0x3u) << 10)
+#define PANEL_ICKSEL(x)         (((x) & 0x3u) << 12)
+
+/* SCx_SCL0_FRC1, OIR_SCL0_FRC1 (x=0,1) */
+#define	SC_RES_VMASK_ON		(1u << 0)
+#define	SC_RES_VMASK(x)		(((x) & 0xffffu) << 16)
+/* SCx_SCL0_FRC2, OIR_SCL0_FRC2 */
+#define	SC_RES_VLACK_ON		(1u << 0)
+#define	SC_RES_VLACK(x)		(((x) & 0xffffu) << 16)
+/* SCx_SCL0_FRC3, OIR_SCL0_FRC3 */
+#define	SC_RES_VS_SEL		(1u << 0)
+#define	SC_RES_VS_IN_SEL	(1u << 8)		/* SC0, SC1 only */
+#define	OIR_RES_EN		(1u << 16)		/* OIR only */
+/* SCx_SCL0_FRC4, OIR_SCL0_FRC4 */
+#define	SC_RES_FH(x)		(((x) & 0x7ffu) << 0)
+#define	SC_RES_FV(x)		(((x) & 0x7ffu) << 16)
+/* SCx_SCL0_FRC5, OIR_SCL0_FRC5 */
+#define	SC_RES_VSDLY(x)		(((x) & 0xffu) << 0)
+#define	SC_RES_FLD_DLY_SEL	(1u << 8)		/* SC0, SC1 only */
+/* SCx_SCL0_FRC6, OIR_SCL0_FRC6 */
+#define	SC_RES_F_VW(x)		(((x) & 0x7ffu) << 0)
+#define	SC_RES_F_VS(x)		(((x) & 0x7ffu) << 16)
+/* SCx_SCL0_FRC7, OIR_SCL0_FRC7 */
+#define	SC_RES_F_HW(x)		(((x) & 0x7ffu) << 0)
+#define	SC_RES_F_HS(x)		(((x) & 0x7ffu) << 16)
+/* SCx_SCL0_OVR1, OIR_SCL0_OVR1 */
+#define	D_SC_RES_BK_COL		RGB888(0, 0, 0)
+/* SCx_SCL0_US8, OIR_SCL0_US8 */
+#define	SC_RES_IBUS_SYNC_SEL	(1u << 4)
+
+/* GRx_FLM_RD, GR_OIR_FLM_RD (x=0,1,2,3) */
+#define	GR_R_ENB		(1u << 0)
+/* GRx_FLM1, GR_OIR_FLM1 */
+#define	GR_BST_MD		(1u << 0)
+#define	GR_OIR_IMR_FLM_INV	(1u << 4)		/* GR_OIR only */
+#define	GR_FLM_SEL(x)		(((x) & 0x3u) << 8)
+#define	GR_LN_OFF_DIR		(1u << 16)
+/* GRx_FLM3, GR_OIR_FLM3 */
+#define	GR_FLM_NUM(x)		(((x) & 0x3ffu) << 0)
+#define	GR_LN_OFF(x)		(((x) & 0x7fffu) << 16)
+/* GRx_FLM4, GR_OIR_FLM4 */
+#define	GR_FLM_OFF(x)		(((x) & 0x7fffffu) << 0)
+/* GRx_FLM5, GR_OIR_FLM5 */
+#define	GR_FLM_LOOP(x)		(((x) & 0x7ffu) << 0)
+#define	GR_FLM_LNUM(x)		(((x) & 0x7ffu) << 16)
+/* GRx_FLM6, GR_OIR_FLM6 */
+#define	GR_RDSWA(x)		(((x) & 0x7u) << 10)
+#define	GR_HW(x)		(((x) & 0x3ff) << 16)
+#define	GR_FORMAT(x)		(((x) & 0xfu) << 28)
+#define	D_GR_FLM6_RGB565	(GR_RDSWA(6) | GR_FORMAT(0))
+#define	D_GR_FLM6_ARGB8888	(GR_RDSWA(4) | GR_FORMAT(4))
+/* GRx_AB1, GR_VIN_AB1, GR_OIR_AB1 */
+#define	GR_DISP_SEL(x)		(((x) & 0x3u) << 0)
+#define	GR_VIN_SCL_UND_SEL	(1u << 2)		/* GR_VIN only */
+#define	GR1_CUS_CON_ON		(1u << 28)		/* GR1 only */
+#define	GR_AB1_MASK		0xeffffff4u
+/* GRx_AB2, GR_VIN_AB2, GR_OIR_AB2 */
+#define	GR_GRC_VW(x)		(((x) & 0x7ffu) << 0)
+#define	GR_GRC_VS(x)		(((x) & 0x7ffu) << 16)
+/* GRx_AB3, GR_VIN_AB3, GR_OIR_AB3 */
+#define	GR_GRC_HW(x)		(((x) & 0x7ffu) << 0)
+#define	GR_GRC_HS(x)		(((x) & 0x7ffu) << 16)
+/* GRx_AB8, GR_VIN_AB8, GR_OIR_AB8 */
+/* GRx_AB9, GR_VIN_AB9, GR_OIR_AB9 */
+/* GRx_AB10, GR_VIN_AB10, GR_OIR_AB10 */
+/* GRx_AB11, GR_VIN_AB11, GR_OIR_AB11 */
+#define	D_GR_AB8		AGBR(0, 0, 0, 0)
+#define	D_GR_AB9		AGBR(0xffu, 0, 0, 0)
+#define	D_GR_AB10		AGBR(0xffu, 0, 0, 0)
+#define	D_GR_AB11		AGBR(0xffu, 0, 0, 0)
+/* GR0_BASE */
+#define	D_GR_BASE		GBR888(0, 0, 0)
+
+/* OUT_CLK_PHASE */
+#define	D_OUT_CLK_PHASE		0
+/* OUT_BRIGHT1, OUT_BRIGHT2 */
+#define	PBRT_G(x)		(((x) & 0x3ffu) << 0)
+#define	PBRT_B(x)		(((x) & 0x3ffu) << 16)
+#define	PBRT_R(x)		(((x) & 0x3ffu) << 0)
+/* OUT_CONTRAST */
+#define	CONT_R(x)		(((x) & 0xffu) << 0)
+#define	CONT_B(x)		(((x) & 0xffu) << 8)
+#define	CONT_G(x)		(((x) & 0xffu) << 16)
+/* OUT_PDTHA */
+#define	PDTHA_FORMAT(x)		(((x) & 0x3u) << 16)
+#define	D_OUT_PDTHA		0x00003021u
+/* OUT_SET */
+#define	OUT_FORMAT(x)		(((x) & 0x3u) << 12)
+#define	D_OUT_SET		0x001f0000u
+
+/* TCON_TIM */
+#define	TCON_OFFSET(x)          (((x) & 0x7ffu) << 0)
+#define	TCON_HALF(x)            (((x) & 0x7ffu) << 16)
+/* TCON_TIM_xxxx */
+#define	TCON_VW(x)		(((x) & 0x7ffu) << 0)
+#define	TCON_VS(x)		(((x) & 0x7ffu) << 16)
+#define	TCON_SEL(x)		(((x) & 0x7u) << 0)
+#define	TCON_INV		(0x1u << 4)
+#define	TCON_HW(x)		(((x) & 0x7ffu) << 0)
+#define	TCON_HS(x)		(((x) & 0x7ffu) << 16)
+#define	TCON_SEL(x)		(((x) & 0x7u) << 0)
+#define	TCON_INV		(0x1u << 4)
+#define	TCON_HS_SEL		(0x1u << 8)
+#define	TCON_MD(x)		(((x) & 0x3u) << 12)
+#define	TCON_DE_INV		(0x1u << 0)
+
+/* INP_UPDATE */
+#define	INP_IMG_UPDATE		(1u << 0)
+#define	INP_EXT_UPDATE		(1u << 4)
+/* IMGCNT_UPDATE */
+#define	IMGCNT_VEN		(1u << 0)
+/* SCx_SCLx_UPDATE, GRx_UPADTE, OIR_SCLx_UPDATE (x=0,1) */
+#define	SC_SCL_VEN_A		(1u << 0)
+#define	SC_SCL_VEN_B		(1u << 4)
+#define	SC_SCL_UPDATE		(1u << 8)
+#define	SC_SCL_VEN_C		(1u << 12)	/* not OIR_SCL1_UPDATE */
+#define	SC_SCL_VEN_D		(1u << 13)	/* not OIR_SCL1_UPDATE */
+/* ADJx_UPDATE */
+#define	ADJ_VEN			(1u << 0)
+/* GRx_UPDATE, GR_OIR_UPDATE (x=2,3) */
+#define	GR_IBUS_VEN		(1u << 0)
+#define	GR_P_VEN		(1u << 4)
+#define	GR_UPDATE		(1u << 8)
+/* GAM_x_UPDATE (x=G,B,R) */
+#define	GAM_VEN			(1u << 0)
+/* TCON_UPDATE */
+#define	TCON_VEN		(1u << 0)
+/* OUT_UPDATE */
+#define	OUTCNT_VEN		(1u << 0)
+
+/************************************************************************/
+/* READ / WRITE VDC5 REGISTERS */
+
+static void vdc5fb_write(struct vdc5fb_priv *priv, int reg, u32 data)
+{
+	if ((SYSCNT_PANEL_CLK == reg) || (SYSCNT_CLUT == reg))
+		iowrite16((u16)data, (priv->base + vdc5fb_offsets[reg]));
+	else
+		iowrite32((u32)data, (priv->base + vdc5fb_offsets[reg]));
+}
+
+static unsigned long vdc5fb_read(struct vdc5fb_priv *priv, int reg)
+{
+	if ((SYSCNT_PANEL_CLK == reg) || (SYSCNT_CLUT == reg))
+		return ioread16(priv->base + vdc5fb_offsets[reg]);
+	else
+		return ioread32(priv->base + vdc5fb_offsets[reg]);
+}
+
+static void vdc5fb_setbits(struct vdc5fb_priv *priv, int reg, u32 bits)
+{
+	u32 tmp;
+
+	tmp = vdc5fb_read(priv, reg);
+	tmp |= bits;
+	vdc5fb_write(priv, reg, tmp);
+}
+
+/************************************************************************/
+
+#endif /* _VDC5FB_REGS_H_ */
diff --git a/drivers/video/renesas/vdc5fb.c b/drivers/video/renesas/vdc5fb.c
new file mode 100644
index 0000000..1a2f222
--- /dev/null
+++ b/drivers/video/renesas/vdc5fb.c
@@ -0,0 +1,1339 @@
+/*
+ * Copyright (C) 2013 Renesas Solutions Corp.
+ *
+ * Based on drivers/video/ren_vdc4.c
+ * Copyright (c) 2012 Renesas Electronics Europe Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/clk.h>
+#include <linux/sh_clk.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/vmalloc.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/fb.h>
+#include <asm/div64.h>
+#include <video/vdc5fb.h>
+
+/************************************************************************/
+
+#define PALETTE_NR 16
+
+struct vdc5fb_priv {
+	struct platform_device *pdev;
+	struct vdc5fb_pdata *pdata;
+	const char *dev_name;
+	struct fb_videomode *videomode;	/* current */
+	/* clock */
+	struct clk *clk;
+	struct clk *dot_clk;
+	struct clk *lvds_clk;
+	/* framebuffers */
+	void __iomem *base;
+	dma_addr_t dma_handle;
+	unsigned long flm_off;
+	unsigned long flm_num;
+	int fb_nofree;
+	/* irq */
+	struct {
+		int start;		/* start irq number */
+		int end;		/* end irq number, inclusive */
+		u32 mask[3];		/* curremnt irq mask */
+		char longname[VDC5FB_IRQ_SIZE][32];	/* ire name */
+	} irq;
+	/* display */
+	struct fb_info *info;
+	unsigned long dc;		/* dot clock in Hz */
+	unsigned int dcdr;		/* dot clock divisor */
+	unsigned int rr;		/* refresh rate in Hz */
+	unsigned int res_fv;		/* vsync period (in fh) */
+	unsigned int res_fh;		/* hsync period (in dc) */
+	u32 pseudo_palette[PALETTE_NR];
+};
+
+/************************************************************************/
+/* Workplace for vdc5-regs.h */
+#include "vdc5fb-regs.h"
+
+/************************************************************************/
+
+static int vdc5fb_init_syscnt(struct vdc5fb_priv *priv);
+static int vdc5fb_init_sync(struct vdc5fb_priv *priv);
+static int vdc5fb_init_scalers(struct vdc5fb_priv *priv);
+static int vdc5fb_init_graphics(struct vdc5fb_priv *priv);
+static int vdc5fb_init_outcnt(struct vdc5fb_priv *priv);
+static int vdc5fb_init_tcon(struct vdc5fb_priv *priv);
+static int vdc5fb_remove(struct platform_device *pdev);
+
+/************************************************************************/
+
+static inline struct vdc5fb_pdata *priv_to_pdata(struct vdc5fb_priv *priv)
+{
+	return (struct vdc5fb_pdata *)(priv->pdev->dev.platform_data);
+}
+
+/************************************************************************/
+/* INTERUPT HANDLING */
+
+static irqreturn_t vdc5fb_irq(int irq, void *data)
+{
+	struct vdc5fb_priv *priv = (struct vdc5fb_priv *)data;
+
+	irq = irq - priv->irq.start;
+	switch (irq) {
+	case S0_VI_VSYNC:	/* INT0 */
+	case S0_LO_VSYNC:	/* INT1 */
+	case S0_VSYNCERR:	/* INT2 */
+	case GR3_VLINE:		/* INT3 */
+	case S0_VFIELD:		/* INT4 */
+	case IV1_VBUFERR:	/* INT5 */
+	case IV3_VBUFERR:	/* INT6 */
+	case IV5_VBUFERR:	/* INT7 */
+		break;
+	case IV6_VBUFERR:	/* INT8 */
+	case S0_WLINE:		/* INT9 */
+	case S1_VI_VSYNC:	/* INT10 */
+	case S1_LO_VSYNC:	/* INT11 */
+	case S1_VSYNCERR:	/* INT12 */
+	case S1_VFIELD:		/* INT13 */
+	case IV2_VBUFERR:	/* INT14 */
+	case IV4_VBUFERR:	/* INT15 */
+		break;
+	case S1_WLINE:		/* INT16 */
+	case OIR_VI_VSYNC:	/* INT17 */
+	case OIR_LO_VSYNC:	/* INT18 */
+	case OIR_VLINE:		/* INT19 */
+	case OIR_VFIELD:	/* INT20 */
+	case IV7_VBUFERR:	/* INT21 */
+	case IV8_VBUFERR:	/* INT22 */
+		break;
+	default:
+		dev_err(&priv->pdev->dev, "unexpected irq (%d+%d)\n",
+			priv->irq.start, irq);
+		break;
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int vdc5fb_init_irqs(struct vdc5fb_priv *priv)
+{
+	int error = -EINVAL;
+	struct platform_device *pdev;
+	struct resource *res;
+	int irq;
+
+	pdev = priv->pdev;
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!res)
+		return error;
+
+	priv->irq.start = res->start;
+	priv->irq.end = res->end;
+	BUG_ON((priv->irq.end - priv->irq.start + 1) != VDC5FB_MAX_IRQS);
+
+	for (irq = 0; irq < VDC5FB_MAX_IRQS; irq++) {
+		snprintf(priv->irq.longname[irq],
+			sizeof(priv->irq.longname[0]), "%s: %s",
+			priv->dev_name, irq_names[irq]);
+		error = request_irq((priv->irq.start + irq),
+			vdc5fb_irq, 0, priv->irq.longname[irq], priv);
+		if (error < 0) {
+			while (--irq >= 0)
+				free_irq(priv->irq.start + irq, priv);
+			return error;
+		}
+	}
+
+	return 0;
+}
+
+static void vdc5fb_deinit_irqs(struct vdc5fb_priv *priv)
+{
+	int irq;
+
+	for (irq = priv->irq.start; irq <= priv->irq.end; irq++)
+		free_irq(irq, priv);
+}
+
+/************************************************************************/
+/* CLOCK HANDLING */
+
+static int vdc5fb_init_clocks(struct vdc5fb_priv *priv)
+{
+	static const char clkname_p1clk[] = "peripheral_clk";
+					/* TODO: should be global */
+	static const char clkname_lvds[] = "lvds";
+					/* TODO: should be global */
+	struct vdc5fb_pdata *pdata = priv_to_pdata(priv);
+	struct platform_device *pdev = priv->pdev;
+
+	priv->clk = clk_get(&pdev->dev, priv->dev_name);
+	if (IS_ERR(priv->clk)) {
+		dev_err(&pdev->dev, "cannot get clock \"%s\"\n",
+			priv->dev_name);
+		return PTR_ERR(priv->clk);
+	}
+
+	priv->dot_clk = clk_get(&pdev->dev, clkname_p1clk);
+	if (IS_ERR(priv->dot_clk)) {
+		dev_err(&pdev->dev, "cannot get clock \"%s\"\n", clkname_p1clk);
+		clk_put(priv->clk);
+		return PTR_ERR(priv->dot_clk);
+	}
+
+	if (pdata->use_lvds) {
+		priv->lvds_clk = clk_get(&pdev->dev, clkname_lvds);
+		if (IS_ERR(priv->lvds_clk)) {
+			dev_err(&pdev->dev, "cannot get clock \"%s\"\n",
+				clkname_lvds);
+			clk_put(priv->clk);
+			clk_put(priv->dot_clk);
+			return PTR_ERR(priv->lvds_clk);
+		}
+	}
+
+	return 0;
+}
+
+static void vdc5fb_deinit_clocks(struct vdc5fb_priv *priv)
+{
+	if (priv->lvds_clk)
+		clk_put(priv->lvds_clk);
+	if (priv->dot_clk)
+		clk_put(priv->dot_clk);
+	if (priv->clk)
+		clk_put(priv->clk);
+}
+
+/************************************************************************/
+
+static void vdc5fb_clear_fb(struct vdc5fb_priv *priv)
+{
+	struct vdc5fb_pdata *pdata = priv_to_pdata(priv);
+	char *start;
+	size_t size;
+
+	start = (char *)priv->info->screen_base;
+	size = pdata->videomode->xres * pdata->videomode->yres
+		* (pdata->bpp / 8);
+
+/* TEMPORARY CODE: WRITE ENABLE SRAM */
+	iowrite8(0xff, (void *)0xFCFE0400);
+	iowrite8(0xff, (void *)0xFCFE0404);
+	iowrite8(0x0f, (void *)0xFCFE0408);
+
+	memset(start, 0x0, size);
+}
+
+static int vdc5fb_update_regs(struct vdc5fb_priv *priv,
+	int reg, uint32_t bits, int wait)
+{
+	uint32_t tmp;
+	long timeout;
+
+	tmp = vdc5fb_read(priv, reg);
+	tmp |= bits;
+	vdc5fb_write(priv, reg, tmp);
+
+	if (wait) {
+		timeout = 50;
+		do {
+			tmp = vdc5fb_read(priv, reg);
+			if ((tmp & bits) == 0)
+				return 0;
+			udelay(1000);
+		} while (--timeout > 0);
+	/* wait for max. 50 ms... */
+	}
+	dev_err(&priv->pdev->dev, "update_regs timeout at %d in %s\n",
+		__LINE__, __func__);
+	return -1;
+}
+
+/************************************************************************/
+
+static int vdc5fb_set_panel_clock(struct vdc5fb_priv *priv,
+	struct fb_videomode *mode)
+{
+	static const unsigned char dcdr_list[13] = {
+		1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 16, 24, 32,
+	};
+	uint64_t desired64 = 1000000000000;
+	unsigned long desired;
+	unsigned long source;
+	unsigned long used;
+	int n;
+
+	source = clk_get_rate(priv->dot_clk);
+	BUG_ON(source == 0);
+
+	(void)do_div(desired64, mode->pixclock);
+	desired = (unsigned long)desired64;
+	for (n = 0; n < ARRAY_SIZE(dcdr_list); n++) {
+		used = source / dcdr_list[n];
+		if (used <= desired) {
+			priv->dcdr = dcdr_list[n];
+			priv->dc = used;
+			return 0;
+		}
+	}
+	return -1;
+}
+
+/************************************************************************/
+
+static int vdc5fb_init_syscnt(struct vdc5fb_priv *priv)
+{
+	struct vdc5fb_pdata *pdata = priv_to_pdata(priv);
+	u32 tmp;
+
+	/* Ignore all irqs here */
+	priv->irq.mask[0] = 0;
+	priv->irq.mask[1] = 0;
+	priv->irq.mask[2] = 0;
+	vdc5fb_write(priv, SYSCNT_INT4, priv->irq.mask[0]);
+	vdc5fb_write(priv, SYSCNT_INT5, priv->irq.mask[1]);
+	vdc5fb_write(priv, SYSCNT_INT6, priv->irq.mask[2]);
+
+	/* Clear all pending irqs */
+	vdc5fb_write(priv, SYSCNT_INT1, 0);
+	vdc5fb_write(priv, SYSCNT_INT2, 0);
+	vdc5fb_write(priv, SYSCNT_INT3, 0);
+
+	/* Setup panel clock */
+	tmp = PANEL_DCDR(priv->dcdr);
+	tmp |= PANEL_ICKEN;
+	tmp |= PANEL_OCKSEL(0);
+	tmp |= PANEL_ICKSEL(pdata->panel_icksel);
+	vdc5fb_write(priv, SYSCNT_PANEL_CLK, tmp);
+
+	return 0;
+}
+
+static int vdc5fb_init_sync(struct vdc5fb_priv *priv)
+{
+	struct fb_videomode *mode = priv->videomode;
+	u32 tmp;
+
+	/* (TODO) Freq. vsync masking and missing vsync
+	 * compensation are not supported.
+	 */
+	vdc5fb_write(priv, SC0_SCL0_FRC1, 0);
+	vdc5fb_write(priv, SC0_SCL0_FRC2, 0);
+	vdc5fb_write(priv, SC1_SCL0_FRC1, 0);
+	vdc5fb_write(priv, SC1_SCL0_FRC2, 0);
+	vdc5fb_write(priv, OIR_SCL0_FRC1, 0);
+	vdc5fb_write(priv, OIR_SCL0_FRC2, 0);
+
+	/* Set the same free-running hsync/vsync period to
+	 * all scalers (sc0, sc1 and oir). The hsync/vsync
+	 * from scaler 0 is used by all scalers.
+	 * (TODO) External input vsync is not supported.
+	 */
+	tmp = SC_RES_FH(priv->res_fh);
+	tmp |= SC_RES_FV(priv->res_fv);
+	vdc5fb_write(priv, SC0_SCL0_FRC4, tmp);
+	vdc5fb_write(priv, SC1_SCL0_FRC4, tmp);
+	vdc5fb_write(priv, OIR_SCL0_FRC4, tmp);
+
+	tmp = (SC_RES_FLD_DLY_SEL | SC_RES_VSDLY(1));
+	vdc5fb_write(priv, SC0_SCL0_FRC5, tmp);
+	vdc5fb_write(priv, SC1_SCL0_FRC5, tmp);
+	tmp = SC_RES_VSDLY(1);
+	vdc5fb_write(priv, OIR_SCL0_FRC5, tmp);
+
+	vdc5fb_write(priv, SC0_SCL0_FRC3, SC_RES_VS_SEL);
+	vdc5fb_write(priv, SC1_SCL0_FRC3, (SC_RES_VS_SEL | SC_RES_VS_IN_SEL));
+	vdc5fb_write(priv, OIR_SCL0_FRC3, 0);
+	/* Note that OIR is not enabled here */
+
+	/* Set full-screen size */
+	tmp = SC_RES_F_VW(mode->yres);
+	tmp |= SC_RES_F_VS(mode->vsync_len + mode->upper_margin);
+	vdc5fb_write(priv, SC0_SCL0_FRC6, tmp);
+	vdc5fb_write(priv, SC1_SCL0_FRC6, tmp);
+	vdc5fb_write(priv, OIR_SCL0_FRC6, tmp);
+	tmp = SC_RES_F_HW(mode->xres);
+	tmp |= SC_RES_F_HS(mode->hsync_len + mode->left_margin);
+	vdc5fb_write(priv, SC0_SCL0_FRC7, tmp);
+	vdc5fb_write(priv, SC1_SCL0_FRC7, tmp);
+	vdc5fb_write(priv, OIR_SCL0_FRC7, tmp);
+
+	/* Cascade on */
+	vdc5fb_setbits(priv, GR1_AB1, GR1_CUS_CON_ON);
+	/* Set GR0 as current, GR1 as underlaying */
+	vdc5fb_setbits(priv, GR_VIN_AB1, GR_VIN_SCL_UND_SEL);
+
+	/* Do update here. */
+	tmp = (SC_SCL_UPDATE | SC_SCL_VEN_B);
+	vdc5fb_update_regs(priv, SC0_SCL0_UPDATE, tmp, 1);
+	vdc5fb_update_regs(priv, SC1_SCL0_UPDATE, tmp, 1);
+	vdc5fb_update_regs(priv, OIR_SCL0_UPDATE, tmp, 1);
+	tmp = (GR_UPDATE | GR_P_VEN);
+	vdc5fb_update_regs(priv, GR1_UPDATE, tmp, 1);
+	vdc5fb_update_regs(priv, GR_VIN_UPDATE, tmp, 1);
+
+	return 0;
+}
+
+static int vdc5fb_init_scalers(struct vdc5fb_priv *priv)
+{
+	struct fb_videomode *mode = priv->videomode;
+	u32 tmp;
+
+	/* Disable scaler 0 */
+	vdc5fb_write(priv, SC0_SCL0_DS1, 0);
+	vdc5fb_write(priv, SC0_SCL0_US1, 0);
+	vdc5fb_write(priv, SC0_SCL0_OVR1, D_SC_RES_BK_COL);
+
+	/* Disable scaler 1 */
+	vdc5fb_write(priv, SC1_SCL0_DS1, 0);
+	vdc5fb_write(priv, SC1_SCL0_US1, 0);
+	vdc5fb_write(priv, SC1_SCL0_OVR1, D_SC_RES_BK_COL);
+
+	/* Enable and setup OIR scaler */
+	vdc5fb_write(priv, OIR_SCL0_FRC3, OIR_RES_EN);
+	vdc5fb_update_regs(priv, OIR_SCL0_UPDATE, SC_SCL_UPDATE, 1);
+
+	vdc5fb_write(priv, OIR_SCL0_DS1, 0);
+	vdc5fb_write(priv, OIR_SCL0_US1, 0);
+	vdc5fb_write(priv, OIR_SCL0_OVR1, D_SC_RES_BK_COL);
+
+	tmp = (mode->vsync_len + mode->upper_margin - 1) << 16;
+	tmp |= mode->yres;
+	vdc5fb_write(priv, OIR_SCL0_DS2, tmp);
+	vdc5fb_write(priv, OIR_SCL0_US2, tmp);
+
+	tmp = (mode->hsync_len + mode->left_margin) << 16;
+	tmp |= mode->xres;
+	vdc5fb_write(priv, OIR_SCL0_DS3, tmp);
+	vdc5fb_write(priv, OIR_SCL0_US3, tmp);
+
+	tmp = mode->yres << 16;
+	tmp |= mode->xres;
+	vdc5fb_write(priv, OIR_SCL0_DS7, tmp);
+
+	tmp = SC_RES_IBUS_SYNC_SEL;
+	vdc5fb_write(priv, OIR_SCL0_US8, tmp);
+
+	return 0;
+}
+
+static int vdc5fb_init_graphics(struct vdc5fb_priv *priv)
+{
+	struct fb_videomode *mode = priv->videomode;
+	struct vdc5fb_pdata *pdata = priv_to_pdata(priv);
+	u32 tmp;
+
+	/* Graphics 0 (Scaler 0) */
+	vdc5fb_write(priv, GR0_FLM_RD, 0);
+	tmp = vdc5fb_read(priv, GR0_AB1);
+	tmp &= GR_AB1_MASK;
+	tmp |= GR_DISP_SEL(0);		/* background */
+	vdc5fb_write(priv, GR0_AB1, tmp);
+	vdc5fb_write(priv, GR0_BASE, D_GR_BASE);
+
+	/* Graphics 1 (Scaler 1) */
+	vdc5fb_write(priv, GR1_FLM_RD, 0);
+	tmp = vdc5fb_read(priv, GR1_AB1);
+	tmp &= GR_AB1_MASK;
+	tmp |= GR_DISP_SEL(0);		/* background */
+	vdc5fb_write(priv, GR1_AB1, tmp);
+	vdc5fb_write(priv, GR1_BASE, D_GR_BASE);
+
+	/* Graphics 2 (Image Synthsizer) */
+	vdc5fb_write(priv, GR2_FLM_RD, 0);
+	vdc5fb_write(priv, GR2_AB1, GR_DISP_SEL(0));
+	vdc5fb_write(priv, GR3_BASE, D_GR_BASE);
+
+	/* Graphics 3 (Image Synthsizer) */
+	vdc5fb_write(priv, GR3_FLM_RD, 0);
+	vdc5fb_write(priv, GR3_AB1, GR_DISP_SEL(0));
+	vdc5fb_write(priv, GR2_BASE, D_GR_BASE);
+
+	/* Graphics VIN (Image Synthsizer) */
+	tmp = vdc5fb_read(priv, GR_VIN_AB1);
+	tmp &= GR_AB1_MASK;
+	tmp |= GR_DISP_SEL(0);		/* background */
+	vdc5fb_write(priv, GR_VIN_AB1, tmp);
+	vdc5fb_write(priv, GR_VIN_BASE, D_GR_BASE);
+
+	/* Graphics OIR */
+	vdc5fb_write(priv, GR_OIR_FLM_RD, GR_R_ENB);
+	vdc5fb_write(priv, GR_OIR_FLM1, GR_FLM_SEL(1));
+	vdc5fb_write(priv, GR_OIR_FLM2, priv->dma_handle);
+	tmp = GR_FLM_NUM(priv->flm_num);
+	tmp |= GR_LN_OFF(mode->xres * (pdata->bpp / 8));
+	vdc5fb_write(priv, GR_OIR_FLM3, tmp);
+	tmp = GR_FLM_OFF(priv->flm_off);
+	vdc5fb_write(priv, GR_OIR_FLM4, tmp);
+	tmp = GR_FLM_LOOP(mode->yres - 1);
+	tmp |= GR_FLM_LNUM(mode->yres - 1);
+	vdc5fb_write(priv, GR_OIR_FLM5, tmp);
+	if (pdata->bpp == 16)
+		tmp = D_GR_FLM6_RGB565;		/* RGB565 LE, 78563412 */
+	else
+		tmp = D_GR_FLM6_ARGB8888;	/* ARGB8888 LE, 56781234 */
+	tmp |= GR_HW(mode->xres - 1);
+	vdc5fb_write(priv, GR_OIR_FLM6, tmp);
+
+	tmp = vdc5fb_read(priv, GR_OIR_AB1);
+	tmp &= GR_AB1_MASK;
+	tmp |= GR_DISP_SEL(2);		/* current graphics */
+	vdc5fb_write(priv, GR_OIR_AB1, tmp);
+
+	tmp = GR_GRC_VW(mode->yres);
+	tmp |= GR_GRC_VS(mode->vsync_len + mode->upper_margin);
+	vdc5fb_write(priv, GR_OIR_AB2, tmp);
+
+	tmp = GR_GRC_HW(mode->xres);
+	tmp |= GR_GRC_HS(mode->hsync_len + mode->left_margin);
+	vdc5fb_write(priv, GR_OIR_AB3, tmp);
+
+	vdc5fb_write(priv, GR_OIR_AB7, 0);
+	vdc5fb_write(priv, GR_OIR_AB8, D_GR_AB8);
+	vdc5fb_write(priv, GR_OIR_AB9, D_GR_AB9);
+	vdc5fb_write(priv, GR_OIR_AB10, D_GR_AB10);
+	vdc5fb_write(priv, GR_OIR_AB11, D_GR_AB11);
+
+	vdc5fb_write(priv, GR_OIR_BASE, D_GR_BASE);
+
+	return 0;
+}
+
+static int vdc5fb_init_outcnt(struct vdc5fb_priv *priv)
+{
+	struct vdc5fb_pdata *pdata = priv_to_pdata(priv);
+	u32 tmp;
+
+	vdc5fb_write(priv, OUT_CLK_PHASE, D_OUT_CLK_PHASE);
+	vdc5fb_write(priv, OUT_BRIGHT1, PBRT_G(512));
+	vdc5fb_write(priv, OUT_BRIGHT2, (PBRT_B(512) | PBRT_R(512)));
+	tmp = (CONT_G(128) | CONT_B(128) | CONT_R(128));
+	vdc5fb_write(priv, OUT_CONTRAST, tmp);
+
+	vdc5fb_write(priv, GAM_SW, 0);
+
+	tmp = D_OUT_PDTHA;
+	tmp |= PDTHA_FORMAT(pdata->out_format);
+					/* 0=RGB888,1=RGB666,2=RGB565 */
+	vdc5fb_write(priv, OUT_PDTHA, tmp);
+
+	tmp = D_OUT_SET;
+	tmp |= OUT_FORMAT(pdata->out_format);
+					/* 0=RGB888,1=RGB666,2=RGB565 */
+	vdc5fb_write(priv, OUT_SET, tmp);
+
+	return 0;
+}
+
+static int vdc5fb_init_tcon(struct vdc5fb_priv *priv)
+{
+	static const unsigned char tcon_sel[LCD_MAX_TCON]
+		= { 0, 1, 2, 7, 4, 5, 6, };
+	struct fb_videomode *mode = priv->videomode;
+	struct vdc5fb_pdata *pdata = priv_to_pdata(priv);
+	u32 vs_s, vs_w, ve_s, ve_w;
+	u32 hs_s, hs_w, he_s, he_w;
+	u32 tmp1, tmp2;
+
+	tmp1 = TCON_OFFSET(0);
+	tmp1 |= TCON_HALF(priv->res_fh / 2);
+	vdc5fb_write(priv, TCON_TIM, tmp1);
+	tmp2 = 0;
+#if 0
+	tmp2 = TCON_DE_INV;
+#endif
+	vdc5fb_write(priv, TCON_TIM_DE, tmp2);
+
+	vs_s = (2 * 0);
+	vs_w = (2 * mode->vsync_len);
+	ve_s = (2 * (mode->vsync_len + mode->upper_margin));
+	ve_w = (2 * mode->yres);
+
+	tmp1 = TCON_VW(vs_w);
+	tmp1 |= TCON_VS(vs_s);
+	vdc5fb_write(priv, TCON_TIM_STVA1, tmp1);
+	if (pdata->tcon_sel[LCD_TCON0] == TCON_SEL_UNUSED)
+		tmp2 = TCON_SEL(tcon_sel[LCD_TCON0]);
+	else
+		tmp2 = TCON_SEL(pdata->tcon_sel[LCD_TCON0]);
+	if (!(mode->sync & FB_SYNC_VERT_HIGH_ACT))
+		tmp2 |= TCON_INV;
+	vdc5fb_write(priv, TCON_TIM_STVA2, tmp2);
+
+	tmp1 = TCON_VW(ve_w);
+	tmp1 |= TCON_VS(ve_s);
+	vdc5fb_write(priv, TCON_TIM_STVB1, tmp1);
+	if (pdata->tcon_sel[LCD_TCON1] == TCON_SEL_UNUSED)
+		tmp2 = TCON_SEL(tcon_sel[LCD_TCON1]);
+	else
+		tmp2 = TCON_SEL(pdata->tcon_sel[LCD_TCON1]);
+#if 0
+	tmp2 |= TCON_INV;
+#endif
+	vdc5fb_write(priv, TCON_TIM_STVB2, tmp2);
+
+	hs_s = 0;
+	hs_w = mode->hsync_len;
+	he_s = (mode->hsync_len + mode->left_margin);
+	he_w = mode->xres;
+
+	tmp1 = TCON_HW(hs_w);
+	tmp1 |= TCON_HS(hs_s);
+	vdc5fb_write(priv, TCON_TIM_STH1, tmp1);
+	if (pdata->tcon_sel[LCD_TCON2] == TCON_SEL_UNUSED)
+		tmp2 = TCON_SEL(tcon_sel[LCD_TCON2]);
+	else
+		tmp2 = TCON_SEL(pdata->tcon_sel[LCD_TCON2]);
+	if (!(mode->sync & FB_SYNC_HOR_HIGH_ACT))
+		tmp2 |= TCON_INV;
+#if 0
+	tmp2 |= TCON_HS_SEL;
+#endif
+	vdc5fb_write(priv, TCON_TIM_STH2, tmp2);
+
+	tmp1 = TCON_HW(he_w);
+	tmp1 |= TCON_HS(he_s);
+	vdc5fb_write(priv, TCON_TIM_STB1, tmp1);
+	if (pdata->tcon_sel[LCD_TCON3] == TCON_SEL_UNUSED)
+		tmp2 = TCON_SEL(tcon_sel[LCD_TCON3]);
+	else
+		tmp2 = TCON_SEL(pdata->tcon_sel[LCD_TCON3]);
+#if 0
+	tmp2 |= TCON_INV;
+	tmp2 |= TCON_HS_SEL;
+#endif
+	vdc5fb_write(priv, TCON_TIM_STB2, tmp2);
+
+	tmp1 = TCON_HW(hs_w);
+	tmp1 |= TCON_HS(hs_s);
+	vdc5fb_write(priv, TCON_TIM_CPV1, tmp1);
+	if (pdata->tcon_sel[LCD_TCON4] == TCON_SEL_UNUSED)
+		tmp2 = TCON_SEL(tcon_sel[LCD_TCON4]);
+	else
+		tmp2 = TCON_SEL(pdata->tcon_sel[LCD_TCON4]);
+#if 0
+	tmp2 |= TCON_INV;
+	tmp2 |= TCON_HS_SEL;
+#endif
+	vdc5fb_write(priv, TCON_TIM_CPV2, tmp2);
+
+	tmp1 = TCON_HW(he_w);
+	tmp1 |= TCON_HS(he_s);
+	vdc5fb_write(priv, TCON_TIM_POLA1, tmp1);
+	if (pdata->tcon_sel[LCD_TCON5] == TCON_SEL_UNUSED)
+		tmp2 = TCON_SEL(tcon_sel[LCD_TCON5]);
+	else
+		tmp2 = TCON_SEL(pdata->tcon_sel[LCD_TCON5]);
+#if 0
+	tmp2 |= TCON_HS_SEL;
+	tmp2 |= TCON_INV;
+	tmp2 |= TCON_MD;
+#endif
+	vdc5fb_write(priv, TCON_TIM_POLA2, tmp2);
+
+	tmp1 = TCON_HW(he_w);
+	tmp1 |= TCON_HS(he_s);
+	vdc5fb_write(priv, TCON_TIM_POLB1, tmp1);
+	if (pdata->tcon_sel[LCD_TCON6] == TCON_SEL_UNUSED)
+		tmp2 = TCON_SEL(tcon_sel[LCD_TCON6]);
+	else
+		tmp2 = TCON_SEL(pdata->tcon_sel[LCD_TCON6]);
+#if 0
+	tmp2 |= TCON_INV;
+	tmp2 |= TCON_HS_SEL;
+	tmp2 |= TCON_MD;
+#endif
+	vdc5fb_write(priv, TCON_TIM_POLB2, tmp2);
+
+	return 0;
+}
+
+static int vdc5fb_update_all(struct vdc5fb_priv *priv)
+{
+	u32 tmp;
+
+	tmp = IMGCNT_VEN;
+	vdc5fb_update_regs(priv, IMGCNT_UPDATE, tmp, 1);
+
+	tmp = (SC_SCL_VEN_A | SC_SCL_VEN_B | SC_SCL_UPDATE
+		| SC_SCL_VEN_C | SC_SCL_VEN_D);
+	vdc5fb_update_regs(priv, SC0_SCL0_UPDATE, tmp, 1);
+	vdc5fb_update_regs(priv, SC0_SCL1_UPDATE, tmp, 1);
+
+	tmp = (GR_IBUS_VEN | GR_P_VEN | GR_UPDATE);
+	vdc5fb_update_regs(priv, GR0_UPDATE, tmp, 1);
+	vdc5fb_update_regs(priv, GR1_UPDATE, tmp, 1);
+
+	tmp = ADJ_VEN;
+	vdc5fb_write(priv, ADJ0_UPDATE, tmp);
+	vdc5fb_write(priv, ADJ1_UPDATE, tmp);
+
+	tmp = (GR_IBUS_VEN | GR_P_VEN | GR_UPDATE);
+	vdc5fb_update_regs(priv, GR2_UPDATE, tmp, 1);
+	vdc5fb_update_regs(priv, GR3_UPDATE, tmp, 1);
+
+	tmp = (GR_P_VEN | GR_UPDATE);
+	vdc5fb_update_regs(priv, GR_VIN_UPDATE, tmp, 1);
+
+	tmp = (SC_SCL_VEN_A | SC_SCL_VEN_B | SC_SCL_UPDATE
+		| SC_SCL_VEN_C | SC_SCL_VEN_D);
+	vdc5fb_update_regs(priv, OIR_SCL0_UPDATE, tmp, 1);
+	vdc5fb_update_regs(priv, OIR_SCL1_UPDATE, tmp, 1);
+
+	tmp = (GR_IBUS_VEN | GR_P_VEN | GR_UPDATE);
+	vdc5fb_update_regs(priv, GR_OIR_UPDATE, tmp, 1);
+
+	tmp = OUTCNT_VEN;
+	vdc5fb_update_regs(priv, OUT_UPDATE, tmp, 1);
+	tmp = GAM_VEN;
+	vdc5fb_update_regs(priv, GAM_G_UPDATE, tmp, 1);
+	vdc5fb_update_regs(priv, GAM_B_UPDATE, tmp, 1);
+	vdc5fb_update_regs(priv, GAM_R_UPDATE, tmp, 1);
+	tmp = TCON_VEN;
+	vdc5fb_update_regs(priv, TCON_UPDATE, tmp, 1);
+
+	return 0;
+}
+
+static void vdc5fb_set_videomode(struct vdc5fb_priv *priv,
+	struct fb_videomode *new)
+{
+	struct vdc5fb_pdata *pdata = priv_to_pdata(priv);
+	struct fb_videomode *mode = pdata->videomode;
+	u32 tmp;
+
+	if (new)
+		mode = new;
+	priv->videomode = mode;
+
+	if (priv->info->screen_base)	/* sanity check */
+		vdc5fb_clear_fb(priv);
+
+	if (vdc5fb_set_panel_clock(priv, mode) < 0)
+		dev_err(&priv->pdev->dev, "cannot get dcdr\n");
+
+	dev_info(&priv->pdev->dev,
+		"%s: [%s] dotclock %lu.%03u MHz, dcdr %u\n",
+		priv->dev_name, pdata->name,
+		(priv->dc / 1000000),
+		(unsigned int)((priv->dc % 1000000) / 1000),
+		priv->dcdr);
+
+	priv->res_fh = mode->hsync_len + mode->left_margin + mode->xres
+		+ mode->right_margin;
+	priv->res_fv = mode->vsync_len + mode->upper_margin + mode->yres
+		+ mode->lower_margin;
+	priv->rr = (priv->dc / (priv->res_fh * priv->res_fv));
+
+	tmp =  mode->xres * mode->yres * (pdata->bpp / 8);
+	priv->flm_off = tmp & ~0xfff;	/* page align */
+	if (tmp & 0xfff)
+		priv->flm_off += 0x1000;
+	priv->flm_num = 0;
+
+	vdc5fb_init_syscnt(priv);
+	vdc5fb_init_sync(priv);
+	vdc5fb_init_scalers(priv);
+	vdc5fb_init_graphics(priv);
+	vdc5fb_init_outcnt(priv);
+	vdc5fb_init_tcon(priv);
+
+	vdc5fb_update_all(priv);
+
+	vdc5fb_clear_fb(priv);
+}
+
+/************************************************************************/
+
+static int vdc5fb_put_bright(struct vdc5fb_priv *priv,
+	struct fbio_bright *param)
+{
+	uint32_t tmp;
+
+	tmp = PBRT_G(param->pbrt_g);
+	vdc5fb_write(priv, OUT_BRIGHT1, tmp);
+	tmp = PBRT_B(param->pbrt_b);
+	tmp |= PBRT_R(param->pbrt_r);
+	vdc5fb_write(priv, OUT_BRIGHT2, tmp);
+	vdc5fb_update_regs(priv, OUT_UPDATE, OUTCNT_VEN, 1);
+
+	return 0;
+}
+
+static int vdc5fb_get_bright(struct vdc5fb_priv *priv,
+	struct fbio_bright *param)
+{
+	uint32_t tmp;
+
+	tmp = vdc5fb_read(priv, OUT_BRIGHT1);
+	param->pbrt_g = (tmp & 0x3ffu);
+	tmp = vdc5fb_read(priv, OUT_BRIGHT2);
+	param->pbrt_b = ((tmp >> 16) & 0x3ffu);
+	param->pbrt_r = (tmp & 0x3ffu);
+
+	return 0;
+}
+
+static int vdc5fb_put_contrast(struct vdc5fb_priv *priv,
+	struct fbio_contrast *param)
+{
+	uint32_t tmp;
+
+	tmp = CONT_G(param->cont_g);
+	tmp |= CONT_B(param->cont_b);
+	tmp |= CONT_R(param->cont_r);
+	vdc5fb_write(priv, OUT_CONTRAST, tmp);
+	vdc5fb_update_regs(priv, OUT_UPDATE, OUTCNT_VEN, 1);
+
+	return 0;
+}
+
+static int vdc5fb_get_contrast(struct vdc5fb_priv *priv,
+	struct fbio_contrast *param)
+{
+	uint32_t tmp;
+
+	tmp = vdc5fb_read(priv, OUT_CONTRAST);
+	param->cont_g = ((tmp >> 16) & 0xffu);
+	param->cont_b = ((tmp >> 8) & 0xffu);
+	param->cont_r = (tmp & 0xffu);
+
+	return 0;
+}
+
+static int vdc5fb_put_frame(struct vdc5fb_priv *priv,
+	struct fbio_frame *param)
+{
+	struct vdc5fb_pdata *pdata = priv_to_pdata(priv);
+	uint32_t tmp;
+
+	if (param->fr_num >= pdata->flm_max)
+		return -EINVAL;
+
+	tmp = vdc5fb_read(priv, GR_OIR_FLM3);
+	tmp &= ~0x3ffu;
+	tmp |= GR_FLM_NUM(param->fr_num);
+	vdc5fb_write(priv, GR_OIR_FLM3, tmp);
+	vdc5fb_update_regs(priv, GR_OIR_UPDATE, GR_IBUS_VEN, 1);
+
+	return 0;
+}
+
+static int vdc5fb_get_frame(struct vdc5fb_priv *priv,
+	struct fbio_frame *param)
+{
+	struct vdc5fb_pdata *pdata = priv_to_pdata(priv);
+	uint32_t tmp;
+
+	tmp = vdc5fb_read(priv, GR_OIR_FLM3);
+	param->fr_max = pdata->flm_max;
+	param->fr_num = (tmp & 0x3ffu);
+
+	return 0;
+}
+
+/************************************************************************/
+
+static int vdc5fb_setcolreg(u_int regno,
+	u_int red, u_int green, u_int blue,
+	u_int transp, struct fb_info *info)
+{
+	u32 *palette = info->pseudo_palette;
+
+	if (regno >= PALETTE_NR)
+		return -EINVAL;
+
+	/* only FB_VISUAL_TRUECOLOR supported */
+	red    >>= 16 - info->var.red.length;
+	green  >>= 16 - info->var.green.length;
+	blue   >>= 16 - info->var.blue.length;
+	transp >>= 16 - info->var.transp.length;
+
+	palette[regno] = (red << info->var.red.offset) |
+		(green << info->var.green.offset) |
+		(blue << info->var.blue.offset) |
+		(transp << info->var.transp.offset);
+
+	return 0;
+}
+
+static int vdc5fb_ioctl(struct fb_info *info, unsigned int cmd,
+	unsigned long arg)
+{
+	struct vdc5fb_priv *priv = (struct vdc5fb_priv *)info->par;
+
+	switch (cmd) {
+
+	case FBIOGET_VSCREENINFO:	/* 0x00 */
+	case FBIOPUT_VSCREENINFO:	/* 0x01 */
+	case FBIOGET_FSCREENINFO:	/* 0x02 */
+	/* Done by higher, OK */
+		break;
+
+	case FBIOGETCMAP:		/* 0x04 */
+	case FBIOPUTCMAP:		/* 0x05 */
+	case FBIOPAN_DISPLAY:		/* 0x06 */
+	case FBIO_CURSOR:		/* 0x08 */
+	case FBIOGET_CON2FBMAP:		/* 0x0F */
+	case FBIOPUT_CON2FBMAP:		/* 0x10 */
+	case FBIOBLANK:			/* 0x11 */
+	/* Done by higher, NG */
+		break;
+
+	case FBIOGET_VBLANK:		/* 0x12 */
+	case FBIO_ALLOC:		/* 0x13 */
+	case FBIO_FREE:			/* 0x14 */
+	case FBIOGET_GLYPH:		/* 0x15 */
+	case FBIOGET_HWCINFO:		/* 0x16 */
+	case FBIOPUT_MODEINFO:		/* 0x17 */
+	case FBIOGET_DISPINFO:		/* 0x18 */
+	case FBIO_WAITFORVSYNC:		/* 0x20 */
+	/* Done by higher, NG (not supported) */
+	/* vdc5fb_ioctl is also called */
+		return -EINVAL;
+		break;
+
+	default:
+	/* 0x03, 0x07, 0x09-0x0E, 0x19-0x1F, 0x21- (unknown) */
+	/* vdc5fb_ioctl is called */
+		return -EINVAL;
+		break;
+
+	case FBIOPUT_BRIGHT:
+		{
+			struct fbio_bright bright;
+
+			if (copy_from_user(&bright, (void __user *)arg,
+				sizeof(bright)))
+				return -EFAULT;
+			if (bright.pbrt_r > 1023)
+				bright.pbrt_r = 1023;
+			if (bright.pbrt_g > 1023)
+				bright.pbrt_g = 1023;
+			if (bright.pbrt_b > 1023)
+				bright.pbrt_b = 1023;
+			return vdc5fb_put_bright(priv, &bright);
+		}
+	case FBIOGET_BRIGHT:
+		{
+			struct fbio_bright bright;
+			int ret;
+
+			ret = vdc5fb_get_bright(priv, &bright);
+			if (ret < 0)
+				return ret;
+			if (copy_to_user((void __user *)arg, &bright,
+				sizeof(bright)))
+				return -EFAULT;
+			return 0;
+		}
+
+	case FBIOPUT_CONTRAST:
+		{
+			struct fbio_contrast contrast;
+
+			if (copy_from_user(&contrast, (void __user *)arg,
+				sizeof(contrast)))
+				return -EFAULT;
+			if (contrast.cont_r > 255)
+				contrast.cont_r = 255;
+			if (contrast.cont_g > 255)
+				contrast.cont_g = 255;
+			if (contrast.cont_b > 255)
+				contrast.cont_b = 255;
+			return vdc5fb_put_contrast(priv, &contrast);
+		}
+	case FBIOGET_CONTRAST:
+		{
+			struct fbio_contrast contrast;
+			int ret;
+
+			ret = vdc5fb_get_contrast(priv, &contrast);
+			if (ret < 0)
+				return ret;
+			if (copy_to_user((void __user *)arg, &contrast,
+				sizeof(contrast)))
+				return -EFAULT;
+			return 0;
+		}
+	case FBIOPUT_FRAME:
+		{
+			struct fbio_frame frame;
+
+			if (copy_from_user(&frame, (void __user *)arg,
+				sizeof(frame)))
+				return -EFAULT;
+			return vdc5fb_put_frame(priv, &frame);
+		}
+	case FBIOGET_FRAME:
+		{
+			struct fbio_frame frame;
+			int ret;
+
+			ret = vdc5fb_get_frame(priv, &frame);
+			if (ret < 0)
+				return ret;
+			if (copy_to_user((void __user *)arg, &frame,
+				sizeof(frame)))
+				return -EFAULT;
+			return 0;
+		}
+	}
+
+	return 0;
+}
+
+static struct fb_fix_screeninfo vdc5fb_fix = {
+	.id		= "vdc5fb",
+	.type		= FB_TYPE_PACKED_PIXELS,
+	.visual		= FB_VISUAL_TRUECOLOR,
+	.accel		= FB_ACCEL_NONE,
+};
+
+static int vdc5fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	/* NOT SUPPORTED IN THIS VERSION */
+
+	return -EINVAL;
+}
+
+static int vdc5fb_set_par(struct fb_info *info)
+{
+	/* NOT SUPPORTED IN THIS VERSION */
+
+	return 0;
+}
+
+static struct fb_ops vdc5fb_ops = {
+	.owner          = THIS_MODULE,
+	.fb_read        = fb_sys_read,
+	.fb_write       = fb_sys_write,
+	.fb_check_var	= vdc5fb_check_var,
+	.fb_set_par	= vdc5fb_set_par,
+	.fb_setcolreg	= vdc5fb_setcolreg,
+	.fb_fillrect	= sys_fillrect,
+	.fb_copyarea	= sys_copyarea,
+	.fb_imageblit	= sys_imageblit,
+	.fb_ioctl	= vdc5fb_ioctl,
+};
+
+static int vdc5fb_set_bpp(struct fb_var_screeninfo *var, int bpp)
+{
+	switch (bpp) {
+	case 16: /* RGB 565 */
+		var->blue.offset = 0;
+		var->blue.length = 5;
+		var->green.offset = 5;
+		var->green.length = 6;
+		var->red.offset = 11;
+		var->red.length = 5;
+		var->transp.offset = 0;
+		var->transp.length = 0;
+		break;
+	case 32: /* ARGB 8888 */
+		var->blue.offset = 0;
+		var->blue.length = 8;
+		var->green.offset = 8;
+		var->green.length = 8;
+		var->red.offset = 16;
+		var->red.length = 8;
+		var->transp.offset = 24;
+		var->transp.length = 8;
+		break;
+	default:
+		return -EINVAL;
+	}
+	var->bits_per_pixel = bpp;
+	var->red.msb_right = 0;
+	var->green.msb_right = 0;
+	var->blue.msb_right = 0;
+	var->transp.msb_right = 0;
+	return 0;
+}
+
+static int vdc5fb_start(struct vdc5fb_priv *priv)
+{
+	struct vdc5fb_pdata *pdata = priv_to_pdata(priv);
+	int error;
+
+	if (pdata->pinmux) {
+		if (pdata->pinmux(priv->pdev) < 0) {
+			dev_err(&priv->pdev->dev, "cannot setup pinmux\n");
+			return -EIO;
+		}
+	}
+	if (pdata->reset) {
+		if (pdata->reset(priv->pdev) < 0) {
+			dev_err(&priv->pdev->dev, "cannot setup LCD\n");
+			return -EIO;
+		}
+	}
+
+	error = clk_enable(priv->clk);
+	if (error < 0)
+		return error;
+
+	if (priv->dot_clk) {
+		error = clk_enable(priv->dot_clk);
+		if (error < 0)
+			return error;
+	}
+
+	vdc5fb_set_videomode(priv, NULL);
+
+	return error;
+}
+
+static void vdc5fb_stop(struct vdc5fb_priv *priv)
+{
+	if (priv->dot_clk)
+		clk_disable(priv->dot_clk);
+	clk_disable(priv->clk);
+}
+
+static int vdc5fb_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+
+	vdc5fb_stop(platform_get_drvdata(pdev));
+	return 0;
+}
+
+static int vdc5fb_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+
+	return vdc5fb_start(platform_get_drvdata(pdev));
+}
+
+static const struct dev_pm_ops vdc5fb_dev_pm_ops = {
+	.suspend = vdc5fb_suspend,
+	.resume = vdc5fb_resume,
+};
+
+static int vdc5fb_probe(struct platform_device *pdev)
+{
+	int error = -EINVAL;
+	struct vdc5fb_priv *priv = NULL;
+	struct vdc5fb_pdata *pdata;
+	struct fb_info *info;
+	struct resource *res;
+	void *buf;
+
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv) {
+		dev_err(&pdev->dev, "cannot allocate private data\n");
+		error = -ENOMEM;
+		goto err0;
+	}
+	platform_set_drvdata(pdev, priv);
+	priv->pdev = pdev;
+	priv->dev_name = dev_name(&pdev->dev);
+
+	pdata = pdev->dev.platform_data;
+	if (!pdata) {
+		dev_err(&pdev->dev, "cannot get platform data\n");
+		goto err1;
+	}
+	priv->pdata = pdata;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "cannot get resources (reg)\n");
+		goto err1;
+	}
+	priv->base = ioremap_nocache(res->start, resource_size(res));
+	if (!priv->base) {
+		dev_err(&pdev->dev, "cannot ioremap (reg)\n");
+		goto err1;
+	}
+
+	error = vdc5fb_init_clocks(priv);
+	if (error) {
+		dev_err(&pdev->dev, "cannot init clocks\n");
+		goto err1;
+	}
+
+	error = vdc5fb_init_irqs(priv);
+	if (error < 0) {
+		dev_err(&pdev->dev, "cannot init irqs\n");
+		goto err1;
+	}
+
+	info = framebuffer_alloc(0, &pdev->dev);
+	if (!info) {
+		dev_err(&pdev->dev, "cannot allocate fb_info\n");
+		goto err1;
+	}
+	priv->info = info;
+
+	info->fbops = &vdc5fb_ops;
+
+	info->var.xres = info->var.xres_virtual = pdata->videomode->xres;
+	info->var.yres = info->var.yres_virtual = pdata->videomode->yres;
+	info->var.width = pdata->panel_width;
+	info->var.height = pdata->panel_height;
+	info->var.activate = FB_ACTIVATE_NOW;
+	info->pseudo_palette = priv->pseudo_palette;
+	error = vdc5fb_set_bpp(&info->var, pdata->bpp);
+	if (error) {
+		dev_err(&pdev->dev, "cannot set bpp\n");
+		goto err2;
+	}
+	info->fix = vdc5fb_fix;
+	info->fix.line_length = pdata->videomode->xres * (pdata->bpp / 8);
+	info->fix.smem_len = info->fix.line_length * pdata->videomode->yres;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (!res) {
+		dev_err(&pdev->dev, "cannot get resources (fb)\n");
+		goto err2;
+	}
+	if (res->start) {
+		if ((res->end - res->start + 1) < info->fix.smem_len)
+			goto err2;
+		priv->dma_handle = res->start;
+		buf = ioremap_nocache(res->start,
+			(res->end - res->start + 1));
+		priv->fb_nofree = 1;
+	} else {
+		buf = dma_alloc_writecombine(&pdev->dev, info->fix.smem_len,
+			&priv->dma_handle, GFP_KERNEL);
+		priv->fb_nofree = 0;
+		if (!buf) {
+			dev_err(&pdev->dev, "cannot allocate buffer\n");
+			goto err2;
+		}
+	}
+	info->flags = FBINFO_FLAG_DEFAULT;
+
+	error = fb_alloc_cmap(&info->cmap, PALETTE_NR, 0);
+	if (error < 0) {
+		dev_err(&pdev->dev, "cannot allocate cmap\n");
+		goto err3;
+	}
+
+	info->fix.smem_start = priv->dma_handle;
+	info->screen_base = buf;
+	info->device = &pdev->dev;
+	info->par = priv;
+
+	error = vdc5fb_start(priv);
+	if (error) {
+		dev_err(&pdev->dev, "cannot start hardware\n");
+		goto err4;
+	}
+
+	error = register_framebuffer(info);
+	if (error < 0)
+		goto err5;
+
+	dev_info(info->dev,
+		"registered %s as %ux%u @ %u Hz, %d bpp.\n",
+		priv->dev_name,
+		pdata->videomode->xres,
+		pdata->videomode->yres,
+		priv->rr,
+		pdata->bpp);
+
+	return 0;
+
+err5:
+	unregister_framebuffer(priv->info);
+err4:
+	vdc5fb_stop(priv);
+err3:
+	fb_dealloc_cmap(&info->cmap);
+	if (priv->fb_nofree)
+		iounmap(priv->base);
+	else
+		dma_free_writecombine(&pdev->dev, info->fix.smem_len,
+			info->screen_base, info->fix.smem_start);
+err2:
+	framebuffer_release(info);
+	vdc5fb_deinit_irqs(priv);
+	vdc5fb_deinit_clocks(priv);
+err1:
+	kfree(priv);
+err0:
+	return error;
+}
+
+static int vdc5fb_remove(struct platform_device *pdev)
+{
+	struct vdc5fb_priv *priv = platform_get_drvdata(pdev);
+	struct fb_info *info;
+
+	if (priv->info->dev)
+		unregister_framebuffer(priv->info);
+
+	vdc5fb_stop(priv);
+
+	info = priv->info;
+
+	fb_dealloc_cmap(&info->cmap);
+	if (priv->fb_nofree)
+		iounmap(priv->base);
+	else
+		dma_free_writecombine(&pdev->dev, info->fix.smem_len,
+			info->screen_base, info->fix.smem_start);
+
+	framebuffer_release(info);
+	vdc5fb_deinit_irqs(priv);
+	vdc5fb_deinit_clocks(priv);
+
+	kfree(priv);
+
+	return 0;
+}
+
+static struct platform_driver vdc5fb_driver = {
+	.driver		= {
+		.name		= "vdc5fb",
+		.owner		= THIS_MODULE,
+		.pm		= &vdc5fb_dev_pm_ops,
+	},
+	.probe		= vdc5fb_probe,
+	.remove		= vdc5fb_remove,
+};
+
+static int __init vdc5fb_init(void)
+{
+	return platform_driver_register(&vdc5fb_driver);
+}
+
+static void __exit vdc5fb_exit(void)
+{
+	platform_driver_unregister(&vdc5fb_driver);
+}
+
+module_init(vdc5fb_init);
+module_exit(vdc5fb_exit);
+
+MODULE_DESCRIPTION("Renesas VDC5 Framebuffer driver");
+MODULE_AUTHOR("Phil Edworthy <phil.edworthy@renesas.com>");
+MODULE_LICENSE("GPL v2");
+
diff --git a/fs/fuse/Kconfig b/fs/fuse/Kconfig
index 1b2f6c2..6372de4 100644
--- a/fs/fuse/Kconfig
+++ b/fs/fuse/Kconfig
@@ -1,5 +1,6 @@
 config FUSE_FS
 	tristate "FUSE (Filesystem in Userspace) support"
+	default y
 	help
 	  With FUSE it is possible to implement a fully functional filesystem
 	  in a userspace program.
diff --git a/include/linux/i2c/riic.h b/include/linux/i2c/riic.h
new file mode 100644
index 0000000..e2010bc
--- /dev/null
+++ b/include/linux/i2c/riic.h
@@ -0,0 +1,42 @@
+/*
+ * RIIC bus driver
+ *
+ * Copyright (C) 2011-2013  Renesas Solutions Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef _RIIC_H_
+#define _RIIC_H_
+
+struct riic_platform_data {
+	int	clock;		/* i2c clock (kHZ) */
+};
+
+struct riic_core_packet {
+	unsigned short slave_address;
+	void *data;
+	int len;
+	int buf_idx;
+	unsigned char rw;
+#define RIIC_CORE_RW_MASTER_TRANSMIT	0
+#define RIIC_CORE_RW_MASTER_RECEIVE	1
+#define RIIC_CORE_RW_SLAVE_TRANSMIT	2
+#define RIIC_CORE_RW_SLAVE_RECEIVE	3
+
+	unsigned done:1;
+};
+
+#endif
diff --git a/include/linux/platform_data/dma-rza1.h b/include/linux/platform_data/dma-rza1.h
new file mode 100644
index 0000000..61f0a74
--- /dev/null
+++ b/include/linux/platform_data/dma-rza1.h
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2013 Renesas Solutions Corp.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_RZA1_DMA_H__
+#define __ASM_ARCH_RZA1_DMA_H__
+
+#include <linux/scatterlist.h>
+#include <linux/device.h>
+#include <linux/dmaengine.h>
+
+/* DMA slave IDs */
+enum {
+	RZA1DMA_SLAVE_PCM_MEM_SSI0 = 1,	/* DMA0		MEM->(DMA0)->SSI0 */
+	RZA1DMA_SLAVE_PCM_MEM_SRC1,		/* DMA1		MEM->(DMA1)->FFD0_1->SRC1->SSI0 */
+	RZA1DMA_SLAVE_PCM_SSI0_MEM,		/* DMA2		SSI0->(DMA2)->MEM */
+	RZA1DMA_SLAVE_PCM_SRC0_MEM,		/* DMA3		SSI0->SRC0->FFU0_0->(DMA3)->MEM */
+	RZA1DMA_SLAVE_PCM_MAX,
+	RZA1DMA_SLAVE_SDHI0_TX,
+	RZA1DMA_SLAVE_SDHI0_RX,
+	RZA1DMA_SLAVE_SDHI1_TX,
+	RZA1DMA_SLAVE_SDHI1_RX,
+	RZA1DMA_SLAVE_MMCIF_TX,
+	RZA1DMA_SLAVE_MMCIF_RX,
+};
+
+struct chcfg_reg {
+	u32	reqd:1;
+	u32	loen:1;
+	u32	hien:1;
+	u32	lvl:1;
+	u32	am:3;
+	u32	sds:4;
+	u32	dds:4;
+	u32	tm:1;
+};
+
+struct dmars_reg {
+	u32	rid:2;
+	u32	mid:7;
+};
+
+/*
+ * Drivers, using this library are expected to embed struct shdma_dev,
+ * struct shdma_chan, struct shdma_desc, and struct shdma_slave
+ * in their respective device, channel, descriptor and slave objects.
+ */
+
+struct rza1dma_slave {
+	int slave_id;
+};
+
+/* Used by slave DMA clients to request DMA to/from a specific peripheral */
+struct rza1_dma_slave {
+	struct rza1dma_slave	rza1dma_slaveid;	/* Set by the platform */
+};
+
+struct rza1_dma_slave_config {
+	int			slave_id;
+	dma_addr_t		addr;
+	struct chcfg_reg	chcfg;
+	struct dmars_reg	dmars;
+};
+
+struct rza1_dma_pdata {
+	const struct rza1_dma_slave_config *slave;
+	int slave_num;
+	int channel_num;
+};
+
+bool rza1dma_chan_filter(struct dma_chan *chan, void *arg);
+#endif
diff --git a/include/linux/platform_data/sh_adc.h b/include/linux/platform_data/sh_adc.h
new file mode 100644
index 0000000..47158aa
--- /dev/null
+++ b/include/linux/platform_data/sh_adc.h
@@ -0,0 +1,29 @@
+/*
+ * SH ADC platform data
+ *
+ * Copyright (C) 2013  Renesas Solutions Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+#ifndef __LINUX_PLATFORM_DATA_SH_ADC_H__
+#define __LINUX_PLATFORM_DATA_SH_ADC_H__
+
+struct sh_adc_data {
+	u8	num_channels;
+	u8	mtu2_ch;
+};
+
+#endif /* __LINUX_PLATFORM_DATA_SH_ADC_H__ */
+
diff --git a/include/linux/spi/rspi.h b/include/linux/spi/rspi.h
index 900f0e3..676bace 100644
--- a/include/linux/spi/rspi.h
+++ b/include/linux/spi/rspi.h
@@ -1,7 +1,7 @@
 /*
  * Renesas SPI driver
  *
- * Copyright (C) 2012  Renesas Solutions Corp.
+ * Copyright (C) 2012-2013  Renesas Solutions Corp.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -22,6 +22,10 @@
 #define __LINUX_SPI_RENESAS_SPI_H__
 
 struct rspi_plat_data {
+	u8 data_width; /* data register access width */
+	bool txmode;	/* tx only mode  */
+	bool spcr;	/* set parity register */
+
 	unsigned int dma_tx_id;
 	unsigned int dma_rx_id;
 
diff --git a/include/linux/spi/sh_spibsc.h b/include/linux/spi/sh_spibsc.h
new file mode 100644
index 0000000..9536612
--- /dev/null
+++ b/include/linux/spi/sh_spibsc.h
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2013 Renesas Solutions Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef SH_SPIBSC_H
+#define SH_SPIBSC_H
+
+struct sh_spibsc_info {
+	int bus_num;
+};
+
+#endif
diff --git a/include/linux/spi/smanalog.h b/include/linux/spi/smanalog.h
new file mode 100644
index 0000000..0ad8a24
--- /dev/null
+++ b/include/linux/spi/smanalog.h
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2013 Renesas Solutions Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef SMANALOG_H
+#define SMANALOG_H
+
+struct sman_platform_data {
+	u16	model;
+};
+#endif /* SMANALOG_H */
+
diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index f629189..bee06df 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -1,4 +1,5 @@
 /*
+ * Copyright (C) 2013 Renesas Solutions Corp.
  * Copyright (C) 2005 David Brownell
  *
  * This program is free software; you can redistribute it and/or modify
@@ -57,6 +58,12 @@ extern struct bus_type spi_bus_type;
  * @modalias: Name of the driver to use with this device, or an alias
  *	for that name.  This appears in the sysfs "modalias" attribute
  *	for driver coldplugging, and in uevents used for hotplugging
+ * @clk_delay: The length of delay between edge of SPI Enable signal and
+ *	first clock edge.
+ * @cs_negate_delay: The length of delay between negated SPI Enable signal
+ *	and last clock edge.
+ * @next_access_delay: The length of delay until starting next SPI Enable
+ *	signal.
  *
  * A @spi_device is used to interchange data between an SPI slave
  * (usually a discrete chip) and CPU memory.
@@ -91,6 +98,9 @@ struct spi_device {
 	void			*controller_data;
 	char			modalias[SPI_NAME_SIZE];
 	int			cs_gpio;	/* chip select gpio */
+	u8			clk_delay;
+	u8			cs_negate_delay;
+	u8			next_access_delay;
 
 	/*
 	 * likely need more hooks for more protocol options affecting how
@@ -811,6 +821,13 @@ struct spi_board_info {
 	 */
 	u8		mode;
 
+	/*
+	 * The delay values for SPI clock timing.
+	 */
+	u8		clk_delay;
+	u8		cs_negate_delay;
+	u8		next_access_delay;
+
 	/* ... may need additional spi_device chip config data here.
 	 * avoid stuff protocol drivers can set; but include stuff
 	 * needed to behave without being bound to a driver:
diff --git a/include/linux/usb/r8a66597.h b/include/linux/usb/r8a66597.h
index 55805f9..23036e2 100644
--- a/include/linux/usb/r8a66597.h
+++ b/include/linux/usb/r8a66597.h
@@ -1,7 +1,7 @@
 /*
  * R8A66597 driver platform data
  *
- * Copyright (C) 2009  Renesas Solutions Corp.
+ * Copyright (C) 2009-2013  Renesas Solutions Corp.
  *
  * Author : Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
  *
@@ -132,7 +132,11 @@ struct r8a66597_platdata {
 #define DEVADD8		0xE0
 #define DEVADD9		0xE2
 #define DEVADDA		0xE4
+#ifdef CONFIG_ARCH_RZA1
+#define SUSPMODE0	0x102
+#endif
 
+#ifndef CONFIG_ARCH_RZA1
 /* System Configuration Control Register */
 #define	XTAL		0xC000	/* b15-14: Crystal selection */
 #define	  XTAL48	 0x8000	  /* 48MHz */
@@ -477,5 +481,331 @@ struct r8a66597_platdata {
 #define CH1ENDC		0x0002 /* b2: Ch1 DMA Transfer End Int Stat Clear */
 #define CH0ENDC		0x0001 /* b1: Ch0 DMA Transfer End Int Stat Clear */
 
+#else
+
+/* System Configuration Control Register */
+#define	HSE		0x0080	/* b7: Hi-speed enable */
+#define	DCFM		0x0040	/* b6: Controller function select  */
+#define	DRPD		0x0020	/* b5: D+/- pull down control */
+#define	DPRPU		0x0010	/* b4: D+ pull up control */
+#define	XTAL		0x0004	/* b2: Crystal selection */
+#define	  XTAL12	 0x0004	  /* 12MHz */
+#define	  XTAL48	 0x0000	  /* 48MHz */
+#define	UPLLE		0x0002	/* b1: internal PLL control */
+#define	USBE		0x0001	/* b0: USB module operation enable */
+
+/* System Configuration Status Register */
+#define	OVCBIT		0x8000	/* b15-14: Over-current bit */
+#define	OVCMON		0xC000	/* b15-14: Over-current monitor */
+#define	SOFEA		0x0020	/* b5: SOF monitor */
+#define	IDMON		0x0004	/* b3: ID-pin monitor */
+#define	LNST		0x0003	/* b1-0: D+, D- line status */
+#define	  SE1		 0x0003	  /* SE1 */
+#define	  FS_KSTS	 0x0002	  /* Full-Speed K State */
+#define	  FS_JSTS	 0x0001	  /* Full-Speed J State */
+#define	  LS_JSTS	 0x0002	  /* Low-Speed J State */
+#define	  LS_KSTS	 0x0001	  /* Low-Speed K State */
+#define	  SE0		 0x0000	  /* SE0 */
+
+/* Device State Control Register */
+#define	EXTLP0		0x0400	/* b10: External port */
+#define	VBOUT		0x0200	/* b9: VBUS output */
+#define	WKUP		0x0100	/* b8: Remote wakeup */
+#define	RWUPE		0x0080	/* b7: Remote wakeup sense */
+#define	USBRST		0x0040	/* b6: USB reset enable */
+#define	RESUME		0x0020	/* b5: Resume enable */
+#define	UACT		0x0010	/* b4: USB bus enable */
+#define	RHST		0x0007	/* b1-0: Reset handshake status */
+#define	  HSPROC	 0x0004	  /* HS handshake is processing */
+#define	  HSMODE	 0x0003	  /* Hi-Speed mode */
+#define	  FSMODE	 0x0002	  /* Full-Speed mode */
+#define	  LSMODE	 0x0001	  /* Low-Speed mode */
+#define	  UNDECID	 0x0000	  /* Undecided */
+
+/* Test Mode Register */
+#define	UTST			0x000F	/* b3-0: Test select */
+#define	  H_TST_PACKET		 0x000C	  /* HOST TEST Packet */
+#define	  H_TST_SE0_NAK		 0x000B	  /* HOST TEST SE0 NAK */
+#define	  H_TST_K		 0x000A	  /* HOST TEST K */
+#define	  H_TST_J		 0x0009	  /* HOST TEST J */
+#define	  H_TST_NORMAL		 0x0000	  /* HOST Normal Mode */
+#define	  P_TST_PACKET		 0x0004	  /* PERI TEST Packet */
+#define	  P_TST_SE0_NAK		 0x0003	  /* PERI TEST SE0 NAK */
+#define	  P_TST_K		 0x0002	  /* PERI TEST K */
+#define	  P_TST_J		 0x0001	  /* PERI TEST J */
+#define	  P_TST_NORMAL		 0x0000	  /* PERI Normal Mode */
+
+/* DMAx Pin Configuration Register */
+#define	DENDE			0x0010	/* b4: Tend enable */
+
+/* CFIFO/DxFIFO Port Select Register */
+#define	RCNT		0x8000	/* b15: Read count mode */
+#define	REW		0x4000	/* b14: Buffer rewind */
+#define	  MBW_8		 0x0000	  /*  8bit */
+#define	  MBW_16	 0x0400	  /* 16bit */
+#define	  MBW_32	 0x0800   /* 32bit */
+#define	BIGEND		0x0100	/* b8: Big endian mode */
+#define	  BYTE_LITTLE	 0x0000		/* little dendian */
+#define	  BYTE_BIG	 0x0100		/* big endifan */
+#define	ISEL		0x0020	/* b5: DCP FIFO port direction select */
+#define	CURPIPE		0x000F	/* b2-0: PIPE select */
+
+/* CFIFO/DxFIFO Port Control Register */
+#define	BVAL		0x8000	/* b15: Buffer valid flag */
+#define	BCLR		0x4000	/* b14: Buffer clear */
+#define	FRDY		0x2000	/* b13: FIFO ready */
+#define	DTLN		0x0FFF	/* b11-0: FIFO received data length */
+
+/* Interrupt Enable Register 0 */
+#define	VBSE	0x8000	/* b15: VBUS interrupt */
+#define	RSME	0x4000	/* b14: Resume interrupt */
+#define	SOFE	0x2000	/* b13: Frame update interrupt */
+#define	DVSE	0x1000	/* b12: Device state transition interrupt */
+#define	CTRE	0x0800	/* b11: Control transfer stage transition interrupt */
+#define	BEMPE	0x0400	/* b10: Buffer empty interrupt */
+#define	NRDYE	0x0200	/* b9: Buffer not ready interrupt */
+#define	BRDYE	0x0100	/* b8: Buffer ready interrupt */
+
+/* Interrupt Enable Register 1 */
+#define	OVRCRE		0x8000	/* b15: Over-current interrupt */
+#define	BCHGE		0x4000	/* b14: USB us chenge interrupt */
+#define	DTCHE		0x1000	/* b12: Detach sense interrupt */
+#define	ATTCHE		0x0800	/* b11: Attach sense interrupt */
+#define	EOFERRE		0x0040	/* b6: EOF error interrupt */
+#define	SIGNE		0x0020	/* b5: SETUP IGNORE interrupt */
+#define	SACKE		0x0010	/* b4: SETUP ACK interrupt */
+
+/* BRDY Interrupt Enable/Status Register */
+#define	BRDY9		0x0200	/* b9: PIPE9 */
+#define	BRDY8		0x0100	/* b8: PIPE8 */
+#define	BRDY7		0x0080	/* b7: PIPE7 */
+#define	BRDY6		0x0040	/* b6: PIPE6 */
+#define	BRDY5		0x0020	/* b5: PIPE5 */
+#define	BRDY4		0x0010	/* b4: PIPE4 */
+#define	BRDY3		0x0008	/* b3: PIPE3 */
+#define	BRDY2		0x0004	/* b2: PIPE2 */
+#define	BRDY1		0x0002	/* b1: PIPE1 */
+#define	BRDY0		0x0001	/* b1: PIPE0 */
+
+/* NRDY Interrupt Enable/Status Register */
+#define	NRDY9		0x0200	/* b9: PIPE9 */
+#define	NRDY8		0x0100	/* b8: PIPE8 */
+#define	NRDY7		0x0080	/* b7: PIPE7 */
+#define	NRDY6		0x0040	/* b6: PIPE6 */
+#define	NRDY5		0x0020	/* b5: PIPE5 */
+#define	NRDY4		0x0010	/* b4: PIPE4 */
+#define	NRDY3		0x0008	/* b3: PIPE3 */
+#define	NRDY2		0x0004	/* b2: PIPE2 */
+#define	NRDY1		0x0002	/* b1: PIPE1 */
+#define	NRDY0		0x0001	/* b1: PIPE0 */
+
+/* BEMP Interrupt Enable/Status Register */
+#define	BEMP9		0x0200	/* b9: PIPE9 */
+#define	BEMP8		0x0100	/* b8: PIPE8 */
+#define	BEMP7		0x0080	/* b7: PIPE7 */
+#define	BEMP6		0x0040	/* b6: PIPE6 */
+#define	BEMP5		0x0020	/* b5: PIPE5 */
+#define	BEMP4		0x0010	/* b4: PIPE4 */
+#define	BEMP3		0x0008	/* b3: PIPE3 */
+#define	BEMP2		0x0004	/* b2: PIPE2 */
+#define	BEMP1		0x0002	/* b1: PIPE1 */
+#define	BEMP0		0x0001	/* b0: PIPE0 */
+
+/* SOF Pin Configuration Register */
+#define	TRNENSEL	0x0100	/* b8: Select transaction enable period */
+#define	BRDYM		0x0040	/* b6: BRDY clear timing */
+#define	INTL		0x0020	/* b5: Interrupt sense select */
+#define	EDGESTS		0x0010	/* b4:  */
+#define	SOFMODE		0x000C	/* b3-2: SOF pin select */
+#define	  SOF_125US	 0x0008	  /* SOF OUT 125us Frame Signal */
+#define	  SOF_1MS	 0x0004	  /* SOF OUT 1ms Frame Signal */
+#define	  SOF_DISABLE	 0x0000	  /* SOF OUT Disable */
+
+/* Interrupt Status Register 0 */
+#define	VBINT	0x8000	/* b15: VBUS interrupt */
+#define	RESM	0x4000	/* b14: Resume interrupt */
+#define	SOFR	0x2000	/* b13: SOF frame update interrupt */
+#define	DVST	0x1000	/* b12: Device state transition interrupt */
+#define	CTRT	0x0800	/* b11: Control transfer stage transition interrupt */
+#define	BEMP	0x0400	/* b10: Buffer empty interrupt */
+#define	NRDY	0x0200	/* b9: Buffer not ready interrupt */
+#define	BRDY	0x0100	/* b8: Buffer ready interrupt */
+#define	VBSTS	0x0080	/* b7: VBUS input port */
+#define	DVSQ	0x0070	/* b6-4: Device state */
+#define	  DS_SPD_CNFG	 0x0070	  /* Suspend Configured */
+#define	  DS_SPD_ADDR	 0x0060	  /* Suspend Address */
+#define	  DS_SPD_DFLT	 0x0050	  /* Suspend Default */
+#define	  DS_SPD_POWR	 0x0040	  /* Suspend Powered */
+#define	  DS_SUSP	 0x0040	  /* Suspend */
+#define	  DS_CNFG	 0x0030	  /* Configured */
+#define	  DS_ADDS	 0x0020	  /* Address */
+#define	  DS_DFLT	 0x0010	  /* Default */
+#define	  DS_POWR	 0x0000	  /* Powered */
+#define	DVSQS		0x0030	/* b5-4: Device state */
+#define	VALID		0x0008	/* b3: Setup packet detected flag */
+#define	CTSQ		0x0007	/* b2-0: Control transfer stage */
+#define	  CS_SQER	 0x0006	  /* Sequence error */
+#define	  CS_WRND	 0x0005	  /* Control write nodata status stage */
+#define	  CS_WRSS	 0x0004	  /* Control write status stage */
+#define	  CS_WRDS	 0x0003	  /* Control write data stage */
+#define	  CS_RDSS	 0x0002	  /* Control read status stage */
+#define	  CS_RDDS	 0x0001	  /* Control read data stage */
+#define	  CS_IDST	 0x0000	  /* Idle or setup stage */
+
+/* Interrupt Status Register 1 */
+#define	OVRCR		0x8000	/* b15: Over-current interrupt */
+#define	BCHG		0x4000	/* b14: USB bus chenge interrupt */
+#define	DTCH		0x1000	/* b12: Detach sense interrupt */
+#define	ATTCH		0x0800	/* b11: Attach sense interrupt */
+#define	EOFERR		0x0040	/* b6: EOF-error interrupt */
+#define	SIGN		0x0020	/* b5: Setup ignore interrupt */
+#define	SACK		0x0010	/* b4: Setup acknowledge interrupt */
+
+/* Frame Number Register */
+#define	OVRN		0x8000	/* b15: Overrun error */
+#define	CRCE		0x4000	/* b14: Received data error */
+#define	FRNM		0x07FF	/* b10-0: Frame number */
+
+/* Micro Frame Number Register */
+#define	UFRNM		0x0007	/* b2-0: Micro frame number */
+
+/* Default Control Pipe Maxpacket Size Register */
+/* Pipe Maxpacket Size Register */
+#define	DEVSEL	0xF000	/* b15-14: Device address select */
+#define	MAXP	0x007F	/* b6-0: Maxpacket size of default control pipe */
+
+/* Default Control Pipe Control Register */
+#define	BSTS		0x8000	/* b15: Buffer status */
+#define	SUREQ		0x4000	/* b14: Send USB request  */
+#define	CSCLR		0x2000	/* b13: complete-split status clear */
+#define	CSSTS		0x1000	/* b12: complete-split status */
+#define	SUREQCLR	0x0800	/* b11: stop setup request */
+#define	SQCLR		0x0100	/* b8: Sequence toggle bit clear */
+#define	SQSET		0x0080	/* b7: Sequence toggle bit set */
+#define	SQMON		0x0040	/* b6: Sequence toggle bit monitor */
+#define	PBUSY		0x0020	/* b5: pipe busy */
+#define	PINGE		0x0010	/* b4: ping enable */
+#define	CCPL		0x0004	/* b2: Enable control transfer complete */
+#define	PID		0x0003	/* b1-0: Response PID */
+#define	  PID_STALL11	 0x0003	  /* STALL */
+#define	  PID_STALL	 0x0002	  /* STALL */
+#define	  PID_BUF	 0x0001	  /* BUF */
+#define	  PID_NAK	 0x0000	  /* NAK */
+
+/* Pipe Window Select Register */
+#define	PIPENM		0x0007	/* b2-0: Pipe select */
+
+/* Pipe Configuration Register */
+#define	R8A66597_TYP	0xC000	/* b15-14: Transfer type */
+#define	  R8A66597_ISO	 0xC000		  /* Isochronous */
+#define	  R8A66597_INT	 0x8000		  /* Interrupt */
+#define	  R8A66597_BULK	 0x4000		  /* Bulk */
+#define	R8A66597_BFRE	0x0400	/* b10: Buffer ready interrupt mode select */
+#define	R8A66597_DBLB	0x0200	/* b9: Double buffer mode select */
+#define	R8A66597_CNTMD	0x0100	/* b8: Continuous transfer mode select */
+#define	R8A66597_SHTNAK	0x0080	/* b7: Transfer end NAK */
+#define	R8A66597_DIR	0x0010	/* b4: Transfer direction select */
+#define	R8A66597_EPNUM	0x000F	/* b3-0: Eendpoint number select */
+
+/* Pipe Buffer Configuration Register */
+#define	BUFSIZE		0x7C00	/* b14-10: Pipe buffer size */
+#define	BUFNMB		0x007F	/* b6-0: Pipe buffer number */
+#define	PIPE0BUF	256
+#define	PIPEXBUF	64
+
+/* Pipe Maxpacket Size Register */
+#define	MXPS		0x07FF	/* b10-0: Maxpacket size */
+
+/* Pipe Cycle Configuration Register */
+#define	IFIS	0x1000	/* b12: Isochronous in-buffer flush mode select */
+#define	IITV	0x0007	/* b2-0: Isochronous interval */
+
+/* Pipex Control Register */
+#define	BSTS	0x8000	/* b15: Buffer status */
+#define	INBUFM	0x4000	/* b14: IN buffer monitor (Only for PIPE1 to 5) */
+#define	CSCLR	0x2000	/* b13: complete-split status clear */
+#define	CSSTS	0x1000	/* b12: complete-split status */
+#define	ATREPM	0x0400	/* b10: Auto repeat mode */
+#define	ACLRM	0x0200	/* b9: Out buffer auto clear mode */
+#define	SQCLR	0x0100	/* b8: Sequence toggle bit clear */
+#define	SQSET	0x0080	/* b7: Sequence toggle bit set */
+#define	SQMON	0x0040	/* b6: Sequence toggle bit monitor */
+#define	PBUSY	0x0020	/* b5: pipe busy */
+#define	PID	0x0003	/* b1-0: Response PID */
+
+/* PIPExTRE */
+#define	TRENB		0x0200	/* b9: Transaction counter enable */
+#define	TRCLR		0x0100	/* b8: Transaction counter clear */
+
+/* PIPExTRN */
+#define	TRNCNT		0xFFFF	/* b15-0: Transaction counter */
+
+/* DEVADDx */
+#define	UPPHUB		0x7800
+#define	HUBPORT		0x0700
+#define	USBSPD		0x00C0
+#define	RTPORT		0x0001
+
+/* SUDMAC registers */
+#define CH0CFG		0x00
+#define CH1CFG		0x04
+#define CH0BA		0x10
+#define CH1BA		0x14
+#define CH0BBC		0x18
+#define CH1BBC		0x1C
+#define CH0CA		0x20
+#define CH1CA		0x24
+#define CH0CBC		0x28
+#define CH1CBC		0x2C
+#define CH0DEN		0x30
+#define CH1DEN		0x34
+#define DSTSCLR		0x38
+#define DBUFCTRL	0x3C
+#define DINTCTRL	0x40
+#define DINTSTS		0x44
+#define DINTSTSCLR	0x48
+#define CH0SHCTRL	0x50
+#define CH1SHCTRL	0x54
+
+/* SUDMAC Configuration Registers */
+#define SENDBUFM	0x1000 /* b12: Transmit Buffer Mode */
+#define RCVENDM		0x0100 /* b8: Receive Data Transfer End Mode */
+#define LBA_WAIT	0x0030 /* b5-4: Local Bus Access Wait */
+
+/* DMA Enable Registers */
+#define DEN		0x0001 /* b1: DMA Transfer Enable */
+
+/* DMA Status Clear Register */
+#define CH1STCLR	0x0002 /* b2: Ch1 DMA Status Clear */
+#define CH0STCLR	0x0001 /* b1: Ch0 DMA Status Clear */
+
+/* DMA Buffer Control Register */
+#define CH1BUFW		0x0200 /* b9: Ch1 DMA Buffer Data Transfer Enable */
+#define CH0BUFW		0x0100 /* b8: Ch0 DMA Buffer Data Transfer Enable */
+#define CH1BUFS		0x0002 /* b2: Ch1 DMA Buffer Data Status */
+#define CH0BUFS		0x0001 /* b1: Ch0 DMA Buffer Data Status */
+
+/* DMA Interrupt Control Register */
+#define CH1ERRE		0x0200 /* b9: Ch1 SHwy Res Err Detect Int Enable */
+#define CH0ERRE		0x0100 /* b8: Ch0 SHwy Res Err Detect Int Enable */
+#define CH1ENDE		0x0002 /* b2: Ch1 DMA Transfer End Int Enable */
+#define CH0ENDE		0x0001 /* b1: Ch0 DMA Transfer End Int Enable */
+
+/* DMA Interrupt Status Register */
+#define CH1ERRS		0x0200 /* b9: Ch1 SHwy Res Err Detect Int Status */
+#define CH0ERRS		0x0100 /* b8: Ch0 SHwy Res Err Detect Int Status */
+#define CH1ENDS		0x0002 /* b2: Ch1 DMA Transfer End Int Status */
+#define CH0ENDS		0x0001 /* b1: Ch0 DMA Transfer End Int Status */
+
+/* DMA Interrupt Status Clear Register */
+#define CH1ERRC		0x0200 /* b9: Ch1 SHwy Res Err Detect Int Stat Clear */
+#define CH0ERRC		0x0100 /* b8: Ch0 SHwy Res Err Detect Int Stat Clear */
+#define CH1ENDC		0x0002 /* b2: Ch1 DMA Transfer End Int Stat Clear */
+#define CH0ENDC		0x0001 /* b1: Ch0 DMA Transfer End Int Stat Clear */
+
+/* Suspend Mode Register */
+#define SUSPM		0x4000 /* b14: Suspend */
+#endif /* CONFIG_ARCH_RZA1 */
+
 #endif /* __LINUX_USB_R8A66597_H */
 
diff --git a/include/sound/sh_scux.h b/include/sound/sh_scux.h
new file mode 100644
index 0000000..e9ffb8a
--- /dev/null
+++ b/include/sound/sh_scux.h
@@ -0,0 +1,1322 @@
+/*
+ * include/sound/sh_scux.h
+ *     This file is header file for SCUX peripheral.
+ *
+ * Copyright (C) 2013 Renesas Electronics Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#ifndef SH_SCUX_H
+#define SH_SCUX_H
+
+#include <linux/dmaengine.h>
+#include <linux/list.h>
+#include <linux/types.h>
+#include <sound/soc.h>
+
+/************************************************************************
+	ALSA
+************************************************************************/
+/* buffer information */
+#define SCU_BUFFER_BYTES_MAX	(32 * 1024)
+#define SCU_PERIOD_BYTES_MIN	512
+#define SCU_PERIOD_BYTES_MAX	8192
+#define SCU_PERIODS_MIN		(SCU_BUFFER_BYTES_MAX / SCU_PERIOD_BYTES_MAX)
+#define SCU_PERIODS_MAX		(SCU_BUFFER_BYTES_MAX / SCU_PERIOD_BYTES_MIN)
+
+/* scux dapm route playback route */
+#define	W_SSI0			0x00000001
+#define	W_SRC1			0x00000002
+#define	W_DVC1			0x00000004
+#define RP_MEM_SSI0		W_SSI0
+#define RP_MEM_SRC1_SSI0	(W_SSI0 | W_SRC1)
+#define RP_MEM_SRC1_DVC1_SSI0	(W_SSI0 | W_SRC1 | W_DVC1)
+/* scux dapm route capture route */
+#define	W_SRC0			0x00020000
+#define RC_SSI0_MEM		W_SSI0
+#define RC_SSI0_SRC0_MEM	(W_SSI0 | W_SRC0)
+
+/* dma direction */
+#define	DMA_DIR(d)	((d == 0) ? DMA_TO_DEVICE : DMA_FROM_DEVICE)
+
+/* IP channel */
+#define	MAXCH_SSIF	6
+#define	MAXCH_SRC	2
+#define	MAXCH_DVU	4
+#define MAXCH_DMA	5 /* DMA slave IDs .ex:RP_MEM_SRC1_DVC1_SSI0 */
+
+/* dai Control */
+#define CTRL_PLAYBACK	0
+#define CTRL_CAPTURE	1
+
+/*  rate  */
+#define	RATE_MAX	0x7fffffff
+
+/*  volume  */
+#define	VOLUME_MAX_DVC	0x007fffff
+#define	VOLUME_DEFAULT	0x00100000
+
+/* SRC channel */
+enum {
+	SRC0,
+	SRC1,
+	SRC2,
+	SRC3,
+};
+#define	SCUX_2SRC0_0			(0)
+#define	SCUX_2SRC0_1			(1)
+
+/* SRC_BSDSR */
+#define	SRC_BSD012349_BUFDATA_1_6	(0x180 << 16)
+#define	SRC_BSD012349_BUFDATA_1_4	(0x100 << 16)
+#define	SRC_BSD012349_BUFDATA_1_3	(0x0c0 << 16)
+#define	SRC_BSD012349_BUFDATA_1_2	(0x080 << 16)
+#define	SRC_BSD012349_BUFDATA_2_3	(0x060 << 16)
+#define	SRC_BSD012349_BUFDATA_1_1	(0x040 << 16)
+#define	SRC_BSD5678_BUFDATA_1_6		(0x240 << 16)
+#define	SRC_BSD5678_BUFDATA_1_4		(0x180 << 16)
+#define	SRC_BSD5678_BUFDATA_1_3		(0x120 << 16)
+#define	SRC_BSD5678_BUFDATA_1_2		(0x0c0 << 16)
+#define	SRC_BSD5678_BUFDATA_2_3		(0x090 << 16)
+#define	SRC_BSD5678_BUFDATA_1_1		(0x060 << 16)
+
+/* SRC_BSISR */
+#define	SRC_BSI_IJECPREC		(0x10 << 16)
+#define	SRC_BSI_IJECSIZE_1_6		0x60
+#define	SRC_BSI_IJECSIZE_1_4		0x40
+#define	SRC_BSI_IJECSIZE_1_3		0x30
+#define	SRC_BSI_IJECSIZE_1_2		0x20
+#define	SRC_BSI_IJECSIZE_2_3		0x20
+#define	SRC_BSI_IJECSIZE_1_1		0x20
+
+/* BUFIJEC bit */
+#define BUFIJEC_LOW_DELAY_OFF		(0uL)
+#define BUFIJEC_LOW_DELAY_ON		(5uL)
+#define	BFSSR_BIT_BUFDATA_16BYTE	(16<<16)
+
+/* DVC channel */
+enum {
+	DVC0,
+	DVC1,
+};
+
+/* SSI channel */
+enum {
+	SSI0,
+	SSI1,
+	SSI2,
+	SSI3,
+	SSI4,
+	SSI5,
+	SSI6,
+	SSI7,
+	SSI8,
+	SSI9,
+};
+
+/* SSI input/output */
+#define	SSI_OUT		0
+#define	SSI_IN		1
+
+/* SSI mode */
+enum {
+	SSI_MASTER,
+	SSI_SLAVE,
+};
+
+/* SSI dependant/independat transfer */
+enum {
+	SSI_DEPENDANT,
+	SSI_INDEPENDANT,
+};
+
+/************************************************************************
+	structure
+************************************************************************/
+struct scu_pcm_callback {
+	void (*init_ssi)(int, int, int, int, int);
+	void (*init_src)(int, unsigned int, unsigned int);
+	void (*init_dvc)(int);
+	void (*deinit_ssi)(int, int, int, int);
+	void (*deinit_src)(int);
+	void (*deinit_dvc)(int);
+};
+struct scu_route_info {
+	int p_route;		/* playback route */
+	int c_route;		/* capture route */
+	/* snd_kcontrol */
+	int route_ssi[MAXCH_SSIF];
+	int route_src[MAXCH_SRC];
+	int route_mix[1];
+	int route_dvc[MAXCH_DVU];
+	/* playback callback */
+	struct scu_pcm_callback pcb;
+	/* capture callback */
+	struct scu_pcm_callback ccb;
+};
+
+struct scu_clock_info {
+	struct clk *adg_clk;
+	struct clk *scu_clk;
+	struct clk *src0_clk;
+	struct clk *src1_clk;
+	struct clk *dvc0_clk;
+	struct clk *dvc1_clk;
+	struct clk *ssiu_clk;
+	struct clk *ssi0_clk;
+	struct clk *ssi1_clk;
+};
+
+struct scu_config {
+	int label;
+	int value;
+};
+
+struct scu_platform_data {
+	int ssi_master;
+	int ssi_slave;
+	struct scu_config *ssi_ch;
+	int ssi_ch_num;
+	struct scu_config *src_ch;
+	int src_ch_num;
+	struct scu_config *dvc_ch;
+	int dvc_ch_num;
+	int dma_slave_maxnum;
+	struct scu_config *audma_slave;
+	int audma_slave_num;
+	struct scu_config *ssi_depend;
+	int ssi_depend_num;
+	struct scu_config *ssi_mode;
+	int ssi_mode_num;
+	struct scu_config *src_mode;
+	int src_mode_num;
+};
+
+struct scu_pcm_info {
+	int flag_first;			/* for PCM 1st process */
+	int flag_start;			/* for DMA control */
+	unsigned int period;		/* for buffer control */
+	unsigned int tran_period;	/* A number of transferred period */
+	spinlock_t pcm_lock;		/* for trigger process */
+	struct dma_chan **de_chan;
+	struct rza1_dma_slave *de_param;
+	struct work_struct work;
+	struct workqueue_struct *workq;
+	struct scu_route_info *routeinfo;
+	struct snd_pcm_substream *ss;
+	struct scu_platform_data *pdata;
+};
+
+/************************************************************************
+	inline function
+************************************************************************/
+static inline int scu_find_data(int val, struct scu_config *data, int size)
+{
+	int i;
+	struct scu_config *data_p = data;
+
+	for (i = 0; i < size; data_p++, i++) {
+		if (val == data_p->label)
+			return data_p->value;
+	}
+
+	return -1;
+}
+/******************************************************************************
+ ==== SCUX ====
+******************************************************************************/
+enum scux_ch
+{
+	SCUX_CH_0,
+	SCUX_CH_1,
+	SCUX_CH_2,
+	SCUX_CH_3,
+	NUM_SCUX_CH,	/* 4ch */
+};
+/******************************************************************************
+ ==== SCUX register value list ==== 
+******************************************************************************/
+/* IPCIR Register Value */
+#define IPCIR_INIT_ON    (1uL)       /* Set INIT of IPC */
+
+/* IPSLR Register Value */
+#define IPSLR_SSIF_IPC_ASYNC    (1uL)
+#define IPSLR_FFD_IPC_ASYNC     (3uL)
+#define IPSLR_FFD_IPC_SYNC      (4uL)
+
+/* OPCIR Register Value */
+#define OPCIR_INIT_ON    (1uL)       /* Set INIT of OPC */
+
+/* OPSLR Register Value */
+#define OPSLR_ASYNC_OPC_DVU     (1uL)
+#define OPSLR_ASYNC_OPC_FFU     (3uL)
+#define OPSLR_SYNC_OPC_FFU      (4uL)
+
+/* FFDIR Register Value */
+#define FFDIR_INIT_OFF   (0uL)       /* Set INIT of FFD */
+#define FFDIR_INIT_ON    (1uL)       /* Set INIT of FFD */
+
+/* FDAIR Register Value */
+#define FDAIR_AUDIO_CH_NONE (0uL)
+#define FDAIR_AUDIO_CH_1 (1uL)
+#define FDAIR_AUDIO_CH_2 (2uL)
+#define FDAIR_AUDIO_CH_4 (4uL)
+#define FDAIR_AUDIO_CH_6 (6uL)
+#define FDAIR_AUDIO_CH_8 (8uL)
+
+/* DRQSR Register Value */
+#define DRQSR_REQ_SIZE_256 (0uL)    /* 256data (FFU0_0 and FFU0_1 Only) */
+#define DRQSR_REQ_SIZE_128 (1uL)    /* 128data (FFU0_0 and FFU0_1 Only) */
+#define DRQSR_REQ_SIZE_64  (2uL)    /* 64data   */
+#define DRQSR_REQ_SIZE_32  (3uL)    /* 32data   */
+#define DRQSR_REQ_SIZE_16  (4uL)    /* 16data   */
+#define DRQSR_REQ_SIZE_8   (5uL)    /* 8data    */
+#define DRQSR_REQ_SIZE_4   (6uL)    /* 4data    */
+#define DRQSR_REQ_SIZE_2   (7uL)    /* 2data    */
+#define DRQSR_REQ_SIZE_1   (8uL)    /* 1data    */
+
+/* FFDPR Register Value */
+#define FFDPR_NO_PASS_SELECT    (0uL)
+#define FFDPR_CIM_FFD_IPC_ASYNC (1uL)
+#define FFDPR_CIM_FFD_IPC_SYNC  (2uL)
+
+/* FFDBR Register Value */
+#define FFDBR_HALT_ON (0uL)
+#define FFDBR_BOOT_ON (1uL)
+
+/* DEVMR Register Value */
+/* Configure SCUX
+DEVMR_FFD0_n - FFD0_n FIFO Download Event Mask Register(n=0,1,2,3)
+b31   DEVMUF - FFD Underflow Mask - Interrupt enabled
+b30   DEVMOF - FFD Overflow Mask - Interrupt enabled
+b29   DEVMOL - FFD Overlap Mask - Interrupt enabled
+b28   DEVMIUF - FFD Initialization Underflow Mask - Interrupt enabled
+b15   DEVMRQ - FFD Request Packet Mask - Interrupt disabled
+Other Reserved - The write value should always be 0 */
+#define DEVMR_VALUE         (0xF0000000uL) /* Initial value of DEVMR_FFD0_n Register */
+
+/* DEVCR Register Value */
+#define DEVCR_REG_MASK      (0xF0008000uL) /* Request ON bits make 0, Other bits make 1 */
+
+/* FFUIR Register Value */
+#define FFUIR_INIT_OFF   (0uL)       /* Set INIT of FFU */
+#define FFUIR_INIT_ON    (1uL)       /* Set INIT of FFU */
+
+/* FUAIR Register Value */
+#define FUAIR_AUDIO_CH_NONE (0uL)
+#define FUAIR_AUDIO_CH_1 (1uL)
+#define FUAIR_AUDIO_CH_2 (2uL)
+#define FUAIR_AUDIO_CH_4 (4uL)
+#define FUAIR_AUDIO_CH_6 (6uL)
+#define FUAIR_AUDIO_CH_8 (8uL)
+
+/* URQSR Register Value */
+/*URQSR_FFU0_n - FFU0_n FIFO Upload Request Size Register(n=0,1,2,3)
+b3:b0 SIZE - Request size data - Set parameter
+Other Reserved - The write value should always be 0 */
+#define URQSR_CH0CH1_REQ_SIZE_256 (0uL)    /* 256data (FFU0_0 and FFU0_1 Only) */
+#define URQSR_CH0CH1_REQ_SIZE_128 (1uL)    /* 128data (FFU0_0 and FFU0_1 Only) */
+#define URQSR_CH0CH1_REQ_SIZE_64  (2uL)    /* 64data   */
+#define URQSR_CH0CH1_REQ_SIZE_32  (3uL)    /* 32data   */
+#define URQSR_CH0CH1_REQ_SIZE_16  (4uL)    /* 16data   */
+#define URQSR_CH0CH1_REQ_SIZE_8   (5uL)    /* 8data    */
+#define URQSR_CH0CH1_REQ_SIZE_4   (6uL)    /* 4data    */
+#define URQSR_CH0CH1_REQ_SIZE_2   (7uL)    /* 2data    */
+#define URQSR_CH0CH1_REQ_SIZE_1   (8uL)    /* 1data    */
+/* In the case of SCUX Channel 2 or 3, a value of 64 data is 0.*/
+#define URQSR_CH2CH3_REQ_SIZE_64  (0uL)    /* 64data   */
+#define URQSR_CH2CH3_REQ_SIZE_32  (1uL)    /* 32data   */
+#define URQSR_CH2CH3_REQ_SIZE_16  (2uL)    /* 16data   */
+#define URQSR_CH2CH3_REQ_SIZE_8   (3uL)    /* 8data    */
+#define URQSR_CH2CH3_REQ_SIZE_4   (4uL)    /* 4data    */
+#define URQSR_CH2CH3_REQ_SIZE_2   (5uL)    /* 2data    */
+#define URQSR_CH2CH3_REQ_SIZE_1   (6uL)    /* 1data    */
+
+/* FFUPR Register Value */
+#define FFUPR_NO_PASS_SELECT    (0uL)
+#define FFUPR_CIM_FFU_OPC_ASYNC (1uL)
+#define FFUPR_CIM_FFU_OPC_SYNC  (2uL)
+
+/* UEVMR Register Value */
+#define UEVMR_VALUE         (0xE0000000uL) /* Initial value of UEVMR_FFU0_n Register */
+
+/* UEVCR Register Value */
+#define UEVCR_REG_MASK      (0xE0008000uL)
+#define UEVCR_BIT_UEVCUF    (0x80000000uL)
+#define UEVCR_BIT_UEVCOF    (0x40000000uL)
+#define UEVCR_BIT_UEVCOL    (0x20000000uL)
+#define UEVCR_BIT_UEVCRQ    (0x00008000uL)
+
+/* SRCIR Register Value */
+#define INIT_OFF   (0uL)       /* Clear INIT of SRC */
+#define SRCIR_INIT_ON    (1uL)       /* Set INIT of SRC */
+
+/* SRC_ADINR */
+#define	SRCADIN_OTBL_24BIT	(0<<16)
+#define	SRCADIN_OTBL_22BIT	(2<<16)
+#define	SRCADIN_OTBL_20BIT	(4<<16)
+#define	SRCADIN_OTBL_18BIT	(6<<16)
+#define	SRCADIN_OTBL_16BIT	(8<<16)
+#define	SRCADIN_OTBL_8BIT	(16<<16)
+#define	SRCADIN_CHNUM_0		(0<<0)
+#define	SRCADIN_CHNUM_1		(1<<0)
+#define	SRCADIN_CHNUM_2		(2<<0)
+#define	SRCADIN_CHNUM_4		(4<<0)
+#define	SRCADIN_CHNUM_6		(6<<0)
+#define	SRCADIN_CHNUM_8		(8<<0)
+
+/* SADIR Register Value */
+/* bit 3-0 */
+#define SADIR_AUDIO_CH_NONE (0uL)
+#define SADIR_AUDIO_CH_1 (1uL)
+#define SADIR_AUDIO_CH_2 (2uL)
+#define SADIR_AUDIO_CH_4 (4uL)
+#define SADIR_AUDIO_CH_6 (6uL)
+#define SADIR_AUDIO_CH_8 (8uL)
+/*bit 20-16*/
+#define SADIR_OTBL_24BIT (0<<16)
+#define SADIR_OTBL_16BIT (8<<16)
+
+/* SRCBR Register Value */
+/*SRCBRp_2SRC0_m - 2SRC0_m Bypass Register p(m=0,1 p=0,1)
+b0    BYPASS - Bypass Mode - Set parameter
+Other Reserved - The write value should always be 0 */
+#define SRCBR_BYPASS_OFF (0uL)
+#define SRCBR_BYPASS_ON  (1uL)
+
+/* IFSCR Register Value */
+/* IFSCRp_2SRC0_m - 2SRC0_m IFS Control Register p(m=0,1 p=0,1)
+b0    INTIFSEN - INTIFS value setting enable - Initial value enabled
+Other Reserved - The write value should always be 0 */
+/* Value of IFSCRp_2SRC0_m Register */
+#define IFSCR_VALUE    (1uL)
+
+
+/* IFSVR Register Value */
+#define IFSVR_INTIFS_NOIFSVR         (0uL)
+#define NUM_OUTPUT_FS       (7uL)
+#define NUM_INPUT_FS        (12uL)
+#define	SRC_IFS_FSO	0x00400000ULL	/* 2^22 */
+#define	SRC_IFS_44KHZ	44100ULL
+#define	SRC_IFS_48KHZ	48000ULL
+
+/* SRCCR Register Value */
+/* SRCCRp_2SRC0_m - 2SRC0_m Control Register p(m=0,1 p=0,1)
+b20     WATMD - Wait Time Control of SRC - Set parameter
+b12     BUFMD - Low Delay Control by Buffer Size of SRC - Set parameter
+b0      SRCMD - Select SRC Mode of SRCI - Set parameter
+b16,8,4 Reserved - These bits should be set to 1
+Other   Reserved - The write value should always be 0 */
+#define	SRC_CR_BIT16		(1<<16)
+#define	SRC_CR_BIT12		(1<<12)
+#define	SRC_CR_LOW_DELAY_NON	(0<<12)
+#define	SRC_CR_BIT8		(1<<8)
+#define	SRC_CR_BIT4		(1<<4)
+#define	SRC_CR_SYNC		(1<<0)
+#define	SRC_CR_ASYNC		(0<<0)
+
+/* MNFSR Register Value */
+/*MNFSRp_2SRC0_m - 2SRC0_m Minimum FS Setting Register p(m=0,1 p=0,1)
+b27:b0 MINFS - Set the minimum FS ratio - Set parameter
+Other  Reserved - The write value should always be 0 */
+
+/* BFSSR Register Value */
+/* BFSSRp_2SRC0_m - 2SRC0_m Buffer Size Setting Register p(m=0,1 p=0,1)
+b25:b16 BUFDATA - Set the buffer size of 1 channel in DATA RAM - Set parameter
+b3:b0   BUFIJEC - Set the buffer size of 1 channel in IJEC RAM - Sets 0x5 for low delay mode
+Other   Reserved - The write value should always be 0 */
+#define BFSSR_BUFDATA_MODE1 ( 0x80uL << 16 ) /* Sets 0x80 for low delay mode.1 */
+#define BFSSR_BUFDATA_MODE2 ( 0x40uL << 16 ) /* Sets 0x40 for low delay mode.2 */
+#define BFSSR_BUFIN_LOW_DELAY_OFF   (0uL)
+#define BFSSR_BUFIN_LOW_DELAY_ON    (5uL) /* Sets 0x5 for low delay mode */
+
+/* SC2SR Register Value */
+/* ALL Bit is ReadOnly */
+#define BFSSR_SRCWSTS         (1<<31) /* 1:Reached to wait time */
+#define BFSSR_SC2MUTE         (1<<30) /* 1:Output data of sampling rate conversion is stable. */
+#define BFSSR_SRCWSTS_REST    (0<<28) /* 00:SRC is resetting */
+#define BFSSR_SRCWSTS_INIT    (1<<28) /* 01:SRC is initialized */
+#define BFSSR_SRCWSTS_OPER    (2<<28) /* 10:SRC is operating */
+
+/* WATSR Register Value */
+/*WATSRp_2SRC0_m - 2SRC0_m Wait Time Setting Register p(m=0,1 p=0,1)
+b23:b0 WTIME - wait time - Set parameter
+Other  Reserved - The write value should always be 0 */
+/* SCUX SRC wait time */
+#define SCUX_MIN_WAIT   (0x00000000L)
+#define SCUX_MAX_WAIT   (0x00FFFFFFL)
+#define SCUX_NO_WAIT    (-1L)
+
+/* SEVMR Register Value */
+/* SEVMRp_2SRC0_m - 2SRC0_m Event Mask Register p(m=0,1 p=0,1)
+b31 EVMUF - Sampling Rate Converter Underflow Mask - Interrupt enabled
+b30 EVMOF - Sampling Rate Converter Overflow Mask - Interrupt enabled
+b14 EVMWAIT - Sampling Rate Converter Wait Time Mask - Interrupt enabled
+Other  Reserved - The write value should always be 0 */
+#define SEVMR_VALUE           (0xc0004000uL) /* Value of SEVMRp_2SRC0_m Register */
+
+/* SEVCR Register Value */
+#define SEVCR_REG_MASK      (0xC0004000uL)
+#define SEVCR_EVCUF         (0x80000000uL)
+#define SEVCR_EVCOF         (0x40000000uL)
+#define SEVCR_EVCWAIT       (0x00004000uL)
+
+/* SRCIRR Register Value */
+#define SRCIRR_INIT_ON    (1uL)       /* Set INIT of SRC */
+
+/* DVUIR Register Value */
+#define DVUIR_INIT_ON    (1uL)       /* Set INIT of DVU */
+
+/* VADIR Register Value */
+/* VADIR_DVU0_n - DVU0_n Audio Information Register(n=0,1,2,3)
+b20:b16 OTBL - Bit Length of Output Audio Data - Set parameter
+b3:b0   CHNUM - Channel Number - Set parameter
+Other   Reserved - The write value should always be 0 */
+/*bit 20-16*/
+#define VADIR_OTBL_24BIT (0<<16)
+#define VADIR_OTBL_16BIT (8<<16)
+/* bit 3-0 */
+#define VADIR_CHNUM_CH_NONE (0uL)
+#define VADIR_CHNUM_CH_1 (1uL)
+#define VADIR_CHNUM_CH_2 (2uL)
+#define VADIR_CHNUM_CH_4 (4uL)
+#define VADIR_CHNUM_CH_6 (6uL)
+#define VADIR_CHNUM_CH_8 (8uL)
+
+/* DVUBR Register Value */
+#define DVUBR_BYPASS_OFF    (0uL)
+#define DVUBR_BYPASS_ON     (1uL)
+
+/* DVUCR Register Value */
+#define	DVUCR_VVMD_SLEEP	(0<<8)
+#define	DVUCR_VVMD_USE		(1<<8)
+#define	DVUCR_VRMD_SLEEP	(0<<4)
+#define	DVUCR_VRMD_USE		(1<<4)
+#define	DVUCR_ZCMD_SLEEP	(0<<0)
+#define	DVUCR_ZCMD_USE		(1<<0)
+
+/* ZCMCR Register Value */
+#define ZCMCR_ZCEN0_EN      (1<<0)
+#define ZCMCR_ZCEN1_EN      (1<<1)
+#define ZCMCR_ZCEN2_EN      (1<<2)
+#define ZCMCR_ZCEN3_EN      (1<<3)
+#define ZCMCR_ZCEN4_EN      (1<<4)
+#define ZCMCR_ZCEN5_EN      (1<<5)
+#define ZCMCR_ZCEN6_EN      (1<<6)
+#define ZCMCR_ZCEN7_EN      (1<<7)
+
+/* VRCTR Register Value */
+/* VRCTR_DVU0_n - DVU0_n Volume Ramp Control Register(n=0,1,2,3)
+b7:b0 VREN7:VREN0 - Volume Ramp Enable for Channel 7 to 0 - Set parameter
+Other Reserved - The write value should always be 0 */
+#define VRCTR_VREN0_EN      (1<<0)
+#define VRCTR_VREN1_EN      (1<<1)
+#define VRCTR_VREN2_EN      (1<<2)
+#define VRCTR_VREN3_EN      (1<<3)
+#define VRCTR_VREN4_EN      (1<<4)
+#define VRCTR_VREN5_EN      (1<<5)
+#define VRCTR_VREN6_EN      (1<<6)
+#define VRCTR_VREN7_EN      (1<<7)
+
+/* VRPDR Register Value */
+enum scux_ramp_period
+{
+				/*                vol_up , vol_down             */
+	DVU_PERIOD_1,		/*       1sample (  128dB,   -128dB/1step)      */
+	DVU_PERIOD_2,		/*       2sample (   64dB,    -64dB/1step)      */
+	DVU_PERIOD_4,		/*       4sample (   32dB,    -32dB/1step)      */
+	DVU_PERIOD_8,		/*       8sample (   16dB,    -16dB/1step)      */
+	DVU_PERIOD_16,		/*      16sample (    8dB,     -8dB/1step)      */
+	DVU_PERIOD_32,		/*      32sample (    4dB,     -4dB/1step)      */
+	DVU_PERIOD_64,		/*      64sample (    2dB,     -2dB/1step)      */
+	DVU_PERIOD_128,		/*     128sample (    1dB,     -1dB/1step)      */
+	DVU_PERIOD_256,		/*     256sample (  0.5dB,   -0.5dB/1step)      */
+	DVU_PERIOD_512,		/*     512sample ( 0.25dB,  -0.25dB/1step)      */
+	DVU_PERIOD_1024,	/*    1024sample (0.125dB, -0.125dB/1step)      */
+	DVU_PERIOD_2048,	/*    2048sample (0.125dB, -0.125dB/2step)      */
+	DVU_PERIOD_4096,	/*    4096sample (0.125dB, -0.125dB/4step)      */
+	DVU_PERIOD_8192,	/*    8192sample (0.125dB, -0.125dB/8step)      */
+	DVU_PERIOD_16384,	/*   16384sample (0.125dB, -0.125dB/16step)     */
+	DVU_PERIOD_32768,	/*   32768sample (0.125dB, -0.125dB/32step)     */
+	DVU_PERIOD_65536,	/*   65536sample (0.125dB, -0.125dB/64step)     */
+	DVU_PERIOD_131072,	/*  131072sample (0.125dB, -0.125dB/128step)    */
+	DVU_PERIOD_262144,	/*  262144sample (0.125dB, -0.125dB/256step)    */
+	DVU_PERIOD_524288,	/*  524288sample (0.125dB, -0.125dB/512step)    */
+	DVU_PERIOD_1048576,	/* 1048576sample (0.125dB, -0.125dB/1024step)   */
+	DVU_PERIOD_2097152,	/* 2097152sample (0.125dB, -0.125dB/2048step)   */
+	DVU_PERIOD_4194304,	/* 4194304sample (0.125dB, -0.125dB/4096step)   */
+	DVU_PERIOD_8388608,	/* 8388608sample (0.125dB, -0.125dB/8192step)   */
+};
+#define VRPDR_VRPDUP_PERIOD_1       ( DVU_PERIOD_1       <<8)
+#define VRPDR_VRPDUP_PERIOD_2       ( DVU_PERIOD_2       <<8)
+#define VRPDR_VRPDUP_PERIOD_4       ( DVU_PERIOD_4       <<8)
+#define VRPDR_VRPDUP_PERIOD_8       ( DVU_PERIOD_8       <<8)
+#define VRPDR_VRPDUP_PERIOD_16      ( DVU_PERIOD_16      <<8)
+#define VRPDR_VRPDUP_PERIOD_32      ( DVU_PERIOD_32      <<8)
+#define VRPDR_VRPDUP_PERIOD_64      ( DVU_PERIOD_64      <<8)
+#define VRPDR_VRPDUP_PERIOD_128     ( DVU_PERIOD_128     <<8)
+#define VRPDR_VRPDUP_PERIOD_256     ( DVU_PERIOD_256     <<8)
+#define VRPDR_VRPDUP_PERIOD_512     ( DVU_PERIOD_512     <<8)
+#define VRPDR_VRPDUP_PERIOD_1024    ( DVU_PERIOD_1024    <<8)
+#define VRPDR_VRPDUP_PERIOD_2048    ( DVU_PERIOD_2048    <<8)
+#define VRPDR_VRPDUP_PERIOD_4096    ( DVU_PERIOD_4096    <<8)
+#define VRPDR_VRPDUP_PERIOD_8192    ( DVU_PERIOD_8192    <<8)
+#define VRPDR_VRPDUP_PERIOD_16384   ( DVU_PERIOD_16384   <<8)
+#define VRPDR_VRPDUP_PERIOD_32768   ( DVU_PERIOD_32768   <<8)
+#define VRPDR_VRPDUP_PERIOD_65536   ( DVU_PERIOD_65536   <<8)
+#define VRPDR_VRPDUP_PERIOD_131072  ( DVU_PERIOD_131072  <<8)
+#define VRPDR_VRPDUP_PERIOD_262144  ( DVU_PERIOD_262144  <<8)
+#define VRPDR_VRPDUP_PERIOD_524288  ( DVU_PERIOD_524288  <<8)
+#define VRPDR_VRPDUP_PERIOD_1048576 ( DVU_PERIOD_1048576 <<8)
+#define VRPDR_VRPDUP_PERIOD_2097152 ( DVU_PERIOD_2097152 <<8)
+#define VRPDR_VRPDUP_PERIOD_4194304 ( DVU_PERIOD_4194304 <<8)
+#define VRPDR_VRPDUP_PERIOD_8388608 ( DVU_PERIOD_8388608 <<8)
+
+#define VRPDR_VRPDDW_PERIOD_1       ( DVU_PERIOD_1       )
+#define VRPDR_VRPDDW_PERIOD_2       ( DVU_PERIOD_2       )
+#define VRPDR_VRPDDW_PERIOD_4       ( DVU_PERIOD_4       )
+#define VRPDR_VRPDDW_PERIOD_8       ( DVU_PERIOD_8       )
+#define VRPDR_VRPDDW_PERIOD_16      ( DVU_PERIOD_16      )
+#define VRPDR_VRPDDW_PERIOD_32      ( DVU_PERIOD_32      )
+#define VRPDR_VRPDDW_PERIOD_64      ( DVU_PERIOD_64      )
+#define VRPDR_VRPDDW_PERIOD_128     ( DVU_PERIOD_128     )
+#define VRPDR_VRPDDW_PERIOD_256     ( DVU_PERIOD_256     )
+#define VRPDR_VRPDDW_PERIOD_512     ( DVU_PERIOD_512     )
+#define VRPDR_VRPDDW_PERIOD_1024    ( DVU_PERIOD_1024    )
+#define VRPDR_VRPDDW_PERIOD_2048    ( DVU_PERIOD_2048    )
+#define VRPDR_VRPDDW_PERIOD_4096    ( DVU_PERIOD_4096    )
+#define VRPDR_VRPDDW_PERIOD_8192    ( DVU_PERIOD_8192    )
+#define VRPDR_VRPDDW_PERIOD_16384   ( DVU_PERIOD_16384   )
+#define VRPDR_VRPDDW_PERIOD_32768   ( DVU_PERIOD_32768   )
+#define VRPDR_VRPDDW_PERIOD_65536   ( DVU_PERIOD_65536   )
+#define VRPDR_VRPDDW_PERIOD_131072  ( DVU_PERIOD_131072  )
+#define VRPDR_VRPDDW_PERIOD_262144  ( DVU_PERIOD_262144  )
+#define VRPDR_VRPDDW_PERIOD_524288  ( DVU_PERIOD_524288  )
+#define VRPDR_VRPDDW_PERIOD_1048576 ( DVU_PERIOD_1048576 )
+#define VRPDR_VRPDDW_PERIOD_2097152 ( DVU_PERIOD_2097152 )
+#define VRPDR_VRPDDW_PERIOD_4194304 ( DVU_PERIOD_4194304 )
+#define VRPDR_VRPDDW_PERIOD_8388608 ( DVU_PERIOD_8388608 )
+
+/* VRDBR Register Value */
+#define VRDBR_VRDB_MUTE      (0x000003FFuL)
+#define VRDBR_VRDB_0DB       (0x00000000uL)
+
+/* VRWTR Register Value */
+#define VRWTR_VRWT       (0x00FFFFFFuL)
+
+/* VOL0R~VOL7R Register Value */
+#define SCUX_MAX_VOL_VALUE  (0x007FFFFFuL) /* SCUX DVU digital volume level */
+
+/* DVUER Register Value */
+#define DVUER_DVUEN_DI (0uL)
+#define DVUER_DVUEN_EN (1uL) /* Set DVUER_DVU0_n register - DVUEN bit */
+
+/* DVUSR Register Value */
+#define DVUSR_VRSTS_MUTE (0uL)
+#define DVUSR_VRSTS_VOLRAMPDOWN (1uL)
+#define DVUSR_VRSTS_VOLRAMPUP   (2uL)
+#define DVUSR_VRSTS_VRDBRREG    (3uL)
+#define DVUSR_VRSTS_VOLINDATA   (4uL)
+
+#define DVUSR_ZSTS0_MUTE   (1<<16)
+#define DVUSR_ZSTS1_MUTE   (1<<17)
+#define DVUSR_ZSTS2_MUTE   (1<<18)
+#define DVUSR_ZSTS3_MUTE   (1<<19)
+#define DVUSR_ZSTS4_MUTE   (1<<20)
+#define DVUSR_ZSTS5_MUTE   (1<<21)
+#define DVUSR_ZSTS6_MUTE   (1<<22)
+#define DVUSR_ZSTS7_MUTE   (1<<23)
+
+/* VEVMR Register Value */
+#define VEVMR_VEVMZCM7_EN  (1<<31)
+#define VEVMR_VEVMZCM6_EN  (1<<30)
+#define VEVMR_VEVMZCM5_EN  (1<<29)
+#define VEVMR_VEVMZCM4_EN  (1<<28)
+#define VEVMR_VEVMZCM3_EN  (1<<27)
+#define VEVMR_VEVMZCM2_EN  (1<<26)
+#define VEVMR_VEVMZCM1_EN  (1<<25)
+#define VEVMR_VEVMZCM0_EN  (1<<24)
+#define VEVMR_VEVMVR_EN    (1<<15)
+
+/* VEVCR Register Value */
+#define VEVCR_VEVCZCM7_EN  (1<<31)
+#define VEVCR_VEVCZCM6_EN  (1<<30)
+#define VEVCR_VEVCZCM5_EN  (1<<29)
+#define VEVCR_VEVCZCM4_EN  (1<<28)
+#define VEVCR_VEVCZCM3_EN  (1<<27)
+#define VEVCR_VEVCZCM2_EN  (1<<26)
+#define VEVCR_VEVCZCM1_EN  (1<<25)
+#define VEVCR_VEVCZCM0_EN  (1<<24)
+#define VEVCR_VEVCVR_EN    (1<<15)
+
+/* SWRSR Register Value */
+#define SWRSR_SWRST_RST  (0uL)
+#define SWRSR_SWRST_OPE  (1uL)
+
+/* DMACR Register Value */
+#define DMACR_DMAMDFFD0_EN  (1<<0)
+#define DMACR_DMAMDFFD1_EN  (1<<1)
+#define DMACR_DMAMDFFD2_EN  (1<<2)
+#define DMACR_DMAMDFFD3_EN  (1<<3)
+#define DMACR_DMAMDFFU0_EN  (1<<4)
+#define DMACR_DMAMDFFU1_EN  (1<<5)
+#define DMACR_DMAMDFFU2_EN  (1<<6)
+#define DMACR_DMAMDFFU3_EN  (1<<7)
+
+/* SSIRSEL Register Value */
+/* SSIRSEL_CIM - SSI Route Select Register
+b31:b30 SISEL3 - SRC3 SSIF Input Select - Set parameter
+b29:b28 SISEL2 - SRC2 SSIF Input Select - Set parameter
+b27:b26 SISEL1 - SRC1 SSIF Input Select - Input from SSIF3
+b25:b24 SISEL0 - SRC0 SSIF Input Select - input from SSIF0
+b21:b20 SOSEL5 - SSIF5 Output Select - Output from SRC3 (DVU0_3)
+b17:b16 SOSEL4 - SSIF4 Output Select - Output from SRC2 (DVU0_2)
+b13:b12 SOSEL3 - SSIF3 Output Select - Set parameter
+b9:b8   SOSEL2 - SSIF2 Output Select - Output from SRC3 (DVU0_3)
+b5:b4   SOSEL1 - SSIF1 Output Select - Output from SRC2 (DVU0_2)
+b1:b0   SOSEL0 - SSIF0 Output Select - Set parameter
+Other Reserved - The write value should always be 0 */
+#define SSIRSEL_SISEL3_USE_SSIF2    (0<<30)
+#define SSIRSEL_SISEL3_USE_SSIF5    (1<<30)
+#define SSIRSEL_SISEL2_USE_SSIF1    (0<<28)
+#define SSIRSEL_SISEL2_USE_SSIF4    (1<<28)
+#define SSIRSEL_SISEL1_USE_SSIF3    (0<<26)
+#define SSIRSEL_SISEL1_USE_SSIF345  (1<<26)
+#define SSIRSEL_SISEL0_USE_SSIF0    (0<<24)
+#define SSIRSEL_SISEL0_USE_SSIF012  (1<<24)
+#define SSIRSEL_SOSEL5_USE_SRC3     (0<<20)
+#define SSIRSEL_SOSEL5_USE_SRC1     (1<<20)
+#define SSIRSEL_SOSEL5_USE_SRC0     (2<<20)
+#define SSIRSEL_SOSEL4_USE_SRC2     (0<<16)
+#define SSIRSEL_SOSEL4_USE_SRC1     (1<<16)
+#define SSIRSEL_SOSEL4_USE_SRC0     (2<<16)
+#define SSIRSEL_SOSEL3_USE_SRC1     (0<<12)
+#define SSIRSEL_SOSEL3_USE_SRC0     (1<<12)
+#define SSIRSEL_SOSEL2_USE_SRC3     (0<<8)
+#define SSIRSEL_SOSEL2_USE_SRC0     (1<<8)
+#define SSIRSEL_SOSEL2_USE_SRC1     (2<<8)
+#define SSIRSEL_SOSEL1_USE_SRC2     (0<<4)
+#define SSIRSEL_SOSEL1_USE_SRC0     (1<<4)
+#define SSIRSEL_SOSEL1_USE_SRC1     (2<<4)
+#define SSIRSEL_SOSEL0_USE_SRC0     (0)
+#define SSIRSEL_SOSEL0_USE_SRC1     (1)
+
+/* FDTSEL Register Value */
+/* Configure SCUX
+FDTSELn_CIM - FFD0_n Timing Select Register(n=0,1,2,3)
+b26:16 SCKDIV - Division Ratio
+b8     DIVEN - Division Enable - Division disabled
+b3:0   SCKSEL - Clock Select
+Other Reserved - The write value should always be 0 */
+
+#define FDTSEL_SCKSEL_AUDIO_CLK        (0x0uL)
+#define FDTSEL_SCKSEL_AUIDIO_X1        (0x1uL)
+#define FDTSEL_SCKSEL_MLB_CLK          (0x2uL)
+#define FDTSEL_SCKSEL_USB_X1           (0x3uL)
+#define FDTSEL_SCKSEL_CLKP1_PHY_DIV2   (0x4uL)
+#define FDTSEL_SCKSEL_SSIF0_WS         (0x8uL)
+#define FDTSEL_SCKSEL_SSIF1_WS         (0x9uL)
+#define FDTSEL_SCKSEL_SSIF2_WS         (0xAuL)
+#define FDTSEL_SCKSEL_SSIF3_WS         (0xBuL)
+#define FDTSEL_SCKSEL_SSIF4_WS         (0xCuL)
+#define FDTSEL_SCKSEL_SSIF5_WS         (0xDuL)
+
+#define SCUX_FDTSEL_BIT_DIVEN  (0x00000100uL)
+
+#define FDTSEL_CH_0_SCKDIV  (0<<16)
+#define FDTSEL_CH_1_SCKDIV  (694uL)     /* P1PHY(66.67MHz)/2/48KHz */
+#define FDTSEL_CH_2_SCKDIV  (694uL)     /* P1PHY(66.67MHz)/2/48KHz */
+#define FDTSEL_CH_3_SCKDIV  (694uL)     /* P1PHY(66.67MHz)/2/48KHz */
+
+/* FUTSEL Register Value */
+#define FUTSEL_SCKSEL_AUDIO_CLK        (0x0uL)
+#define FUTSEL_SCKSEL_AUIDIO_X1        (0x1uL)
+#define FUTSEL_SCKSEL_MLB_CLK          (0x2uL)
+#define FUTSEL_SCKSEL_USB_X1           (0x3uL)
+#define FUTSEL_SCKSEL_CLKP1_PHY_DIV2   (0x4uL)
+#define FUTSEL_SCKSEL_SSIF0_WS         (0x8uL)
+#define FUTSEL_SCKSEL_SSIF1_WS         (0x9uL)
+#define FUTSEL_SCKSEL_SSIF2_WS         (0xAuL)
+#define FUTSEL_SCKSEL_SSIF3_WS         (0xBuL)
+#define FUTSEL_SCKSEL_SSIF4_WS         (0xCuL)
+#define FUTSEL_SCKSEL_SSIF5_WS         (0xDuL)
+
+#define FUTSEL_DIVEN_START  (0x00000100uL)
+
+#define FUTSEL_CH_0_SCKDIV  (0<<16)
+#define FUTSEL_CH_1_SCKDIV  (0<<16)
+#define FUTSEL_CH_2_SCKDIV  (0<<16)
+#define FUTSEL_CH_3_SCKDIV  (0<<16)
+
+/* ==== SCUX SSIPMD_CIM register setting ==== */
+#define THIS_CH_NOT_USED        (0uL)
+
+#define SSIPMD_VALUE    ((SSIPMD_SSI5CKS << 21) | (SSIPMD_SSI4CKS << 20) | (SSIPMD_SSI3CKS << 19) | \
+                         (SSIPMD_SSI2CKS << 18) | (SSIPMD_SSI1CKS << 17) | (SSIPMD_SSI0CKS << 16) | \
+                         (SSIPMD_SSI3PMD << 14) | (SSIPMD_SSI4PMD << 10) | (SSIPMD_SSI5PMD << 9)  | \
+                         (SSIPMD_SSI2PMD << 1)  | SSIPMD_SSI1PMD)
+
+/* SSIPMD Register Value */
+#define SSIPMD_SSI5CKS  (0<<21)
+#define SSIPMD_SSI4CKS  (0<<20)
+#define SSIPMD_SSI3CKS  (0<<19)
+#define SSIPMD_SSI2CKS  (0<<18)
+#define SSIPMD_SSI1CKS  (0<<17)
+#define SSIPMD_SSI0CKS  (0<<16)
+#define SSIPMD_SSI5PMD  (0<<8)
+#define SSIPMD_SSI4PMD  (0<<10)
+#define SSIPMD_SSI3PMD  (0<<14)
+#define SSIPMD_SSI2PMD  (0<<2)
+#define SSIPMD_SSI1PMD  (0)
+
+#define SSIPMD_INDEPENDENCE         (0x0uL)
+#define SSIPMD_COMMON_SLAVE         (0x1uL)
+#define SSIPMD_COMMON_MASTER_SLAVE  (0x2uL)
+/* Case of SSIPMD_COMMON_SLAVE
+    SSI5PMD:The SSIF3 pins are used in common. Both SSIF3 and SSIF5 are slaves.
+    SSI4PMD:The SSIF3 pins are used in common. Both SSIF3 and SSIF4 are slaves.
+    SSI3PMD:The SSIF0 pins are used in common. Both SSIF0 and SSIF3 are slaves.
+    SSI2PMD:The SSIF0 pins are used in common. Both SSIF0 and SSIF2 are slaves.
+    SSI1PMD:The SSIF0 pins are used in common. Both SSIF0 and SSIF1 are slaves.
+   Case of SSIPMD_COMMON_MASTER_SLAVE
+    SSI5PMD:The SSIF3 pins are used in common. SSIF3 is the master and SSIF5 is the slave.
+    SSI4PMD:The SSIF3 pins are used in common. SSIF3 is the master and SSIF4 is the slave.
+    SSI3PMD:The SSIF0 pins are used in common. SSIF0 is the master and SSIF3 is the slave.
+    SSI2PMD:The SSIF0 pins are used in common. SSIF0 is the master and SSIF2 is the slave.
+    SSI1PMD:The SSIF0 pins are used in common. SSIF0 is the master and SSIF1 is the slave. */
+
+/* SSICTRL Register Value */
+/* SSICTRL_CIM - SSI Control Register
+b30:28 SSI3TX,SSI4TX,SSI5TX - SSIF3,4,5 Direct Transmission - Set parameter
+b26:24 SSI3RX,SSI4RX,SSI5RX - SSIF3,4,5 Direct Reception - Set parameter
+b17    SSI345TEN - SSIF345 Transmission Enable - Transmission disabled
+b16    SSI345REN - SSIF345 Reception Enable - Reception disabled
+b14:12 SSI0TX,SSI1TX,SSI2TX - SSIF0,1,2 Direct Transmission - Set parameter
+b11:9  SSI0RX,SSI1RX,SSI2RX - SSIF0,1,2 Direct Reception - Set parameter
+b1     SSI012TEN - SSIF012 Transmission Enable - Transmission disabled
+b0     SSI012REN - SSIF012 Reception Enable - Reception disabled
+Other Reserved - The write value should always be 0 */
+#define SSICTRL_SSI3TX_EN  (1<<30)
+#define SSICTRL_SSI4TX_EN  (1<<29)
+#define SSICTRL_SSI5TX_EN  (1<<28)
+#define SSICTRL_SSI3RX_EN  (1<<26)
+#define SSICTRL_SSI4RX_EN  (1<<25)
+#define SSICTRL_SSI5RX_EN  (1<<24)
+#define SSICTRL_SSI345TEN  (1<<17)
+#define SSICTRL_SSI345REN  (1<<16)
+#define SSICTRL_SSI0TX_EN  (1<<14)
+#define SSICTRL_SSI1TX_EN  (1<<13)
+#define SSICTRL_SSI2TX_EN  (1<<12)
+#define SSICTRL_SSI0RX_EN  (1<<10)
+#define SSICTRL_SSI1RX_EN  (1<<9)
+#define SSICTRL_SSI2RX_EN  (1<<8)
+#define SSICTRL_SSI012TEN  (1<<1)
+#define SSICTRL_SSI012REN  (1)
+
+/* SRCRSEL Register Value */
+#define RSEL_INIT_VALUE    (0x76543210uL) /* Initial value of SRCRSELn_CIM and MIXRSEL_CIM Register */
+#define SRCRSEL_PLACE0     (7)
+#define SRCRSEL_PLACE1     (7<<4)
+#define SRCRSEL_PLACE2     (7<<8)
+#define SRCRSEL_PLACE3     (7<<12)
+#define SRCRSEL_PLACE4     (7<<16)
+#define SRCRSEL_PLACE5     (7<<20)
+#define SRCRSEL_PLACE6     (7<<24)
+#define SRCRSEL_PLACE7     (7<<28)
+
+/* MIXRSEL Register Value */
+#define MIXRSEL_INIT_VALUE (0x76543210uL)
+#define MIXRSEL_PLACE0     (7)
+#define MIXRSEL_PLACE1     (7<<4)
+#define MIXRSEL_PLACE2     (7<<8)
+#define MIXRSEL_PLACE3     (7<<12)
+#define MIXRSEL_PLACE4     (7<<16)
+#define MIXRSEL_PLACE5     (7<<20)
+#define MIXRSEL_PLACE6     (7<<24)
+#define MIXRSEL_PLACE7     (7<<28)
+
+/* MIXBR Register Value */
+#define MIXBR_BYPASS_OFF    (0uL)
+#define MIXBR_BYPASS_ON     (1uL)
+#define MIXBR_BPSYS_B       (1<<16)
+
+/* CHCTRL Register */
+#define DMA_CHCTRL_SWRST_BIT                (0x00000008uL)
+#define DMA_CHCTRL_SETEN_BIT                (0x00000001uL)
+
+/************************************************************************
+	SCUX Register Structure
+************************************************************************/
+struct scux_ipc_regs {
+	u32	ipcir;
+	u32	ipslr;
+	unsigned char  dummy_ipc[248];
+};
+
+struct scux_opc_regs {
+	u32	opcir;
+	u32	opslr;
+	unsigned char  dummy_opc[248];
+};
+
+struct scux_ffd_regs {
+	u32	ffdir;
+	u32	fdair;
+	u32	drqsr;
+	u32	ffdpr;
+	u32	ffdbr;
+	u32	devmr;
+	unsigned char  dummy_ffd[4];
+	u32	devcr;
+	unsigned char  dummy2_ffd[224];
+};
+
+struct scux_ffu_regs {
+	u32	ffuir;
+	u32	fuair;
+	u32	urqsr;
+	u32	ffupr;
+	u32	uevmr;
+	unsigned char  dummy_ffu[4];
+	u32	uevcr;
+	unsigned char  dummy2_ffu[228];
+};
+
+struct scux_src_regs {
+	u32	srcir0;
+	u32	sadir0;
+	u32	srcbr0;
+	u32	ifscr0;
+	u32	ifsvr0;
+	u32	srccr0;
+	u32	mnfsr0;
+	u32	bfssr0;
+	u32	sc2sr0;
+	u32	watsr0;
+	u32	sevmr0;
+	unsigned char  dummy_src0[4];
+	u32	sevcr0;
+	u32	srcir1;
+	u32	sadir1;
+	u32	srcbr1;
+	u32	ifscr1;
+	u32	ifsvr1;
+	u32	srccr1;
+	u32	mnfsr1;
+	u32	bfssr1;
+	u32	sc2sr1;
+	u32	watsr1;
+	u32	sevmr1;
+	unsigned char  dummy_src1[4];
+	u32	sevcr1;
+	u32	srcirr1;
+	unsigned char  dummy_src[148];
+};
+
+struct scux_dvu_regs {
+	u32	dvuir;
+	u32	vadir;
+	u32	dvubr;
+	u32	dvucr;
+	u32	zcmcr;
+	u32	vrctr;
+	u32	vrpdr;
+	u32	vrdbr;
+	u32	vrwtr;
+	u32	vol0r;
+	u32	vol1r;
+	u32	vol2r;
+	u32	vol3r;
+	u32	vol4r;
+	u32	vol5r;
+	u32	vol6r;
+	u32	vol7r;
+	u32	dvuer;
+	u32	dvusr;
+	u32	vevmr;
+	unsigned char  dummy_dvu[4];
+	u32	vevcr;
+	unsigned char  dummy2_dvu[168];
+};
+
+struct scux_mix_regs {
+	u32	mixir;
+	u32	madir;
+	u32	mixbr;
+	u32	mixmr;
+	u32	mvpdr;
+	u32	mdbar;
+	u32	mdbbr;
+	u32	mdbcr;
+	u32	mdbdr;
+	u32	mdber;
+	u32	mixsr;
+	unsigned char  dummy_mix[212];
+};
+struct scux_cim_regs{
+    u32 swrsr;                              /*  SWRSR_CIM       */
+    u32 dmacr_cim;                              /*  DMACR_CIM       */
+    union                                                  /*                  */
+    {                                                      /* DMATD0_CIM       */
+        u32 UINT32;                             /*  32-bit Access   */
+        u16 UINT16[2];                          /*  16-bit Access   */
+    } dmatd0_cim;                                          /*                  */
+    
+    union                                                  /*                  */
+    {                                                      /* DMATD1_CIM       */
+        u32 UINT32;                             /*  32-bit Access   */
+        u16 UINT16[2];                          /*  16-bit Access   */
+    } dmatd1_cim;                                          /*                  */
+    
+    union                                                  /*                  */
+    {                                                      /* DMATD2_CIM       */
+        u32 UINT32;                             /*  32-bit Access   */
+        u16 UINT16[2];                          /*  16-bit Access   */
+    } dmatd2_cim;                                          /*                  */
+    
+    union                                                  /*                  */
+    {                                                      /* DMATD3_CIM       */
+        u32 UINT32;                             /*  32-bit Access   */
+        u16 UINT16[2];                          /*  16-bit Access   */
+    } dmatd3_cim;                                          /*                  */
+    
+    union                                                  /*                  */
+    {                                                      /* DMATU0_CIM       */
+        u32 UINT32;                             /*  32-bit Access   */
+        u16 UINT16[2];                          /*  16-bit Access   */
+    } dmatu0_cim;                                          /*                  */
+    
+    union                                                  /*                  */
+    {                                                      /* DMATU1_CIM       */
+        u32 UINT32;                             /*  32-bit Access   */
+        u16 UINT16[2];                          /*  16-bit Access   */
+    } dmatu1_cim;                                          /*                  */
+    
+    union                                                  /*                  */
+    {                                                      /* DMATU2_CIM       */
+        u32 UINT32;                             /*  32-bit Access   */
+        u16 UINT16[2];                          /*  16-bit Access   */
+    } dmatu2_cim;                                          /*                  */
+    
+    union                                                  /*                  */
+    {                                                      /* DMATU3_CIM       */
+        u32 UINT32;                             /*  32-bit Access   */
+        u16 UINT16[2];                          /*  16-bit Access   */
+    } dmatu3_cim;                                          /*                  */
+    unsigned char  dummy_cim[16];                           /*                  */
+    u32 ssirsel_cim;                            /*  SSIRSEL_CIM     */
+    u32 fdtsel0_cim;                            /*  FDTSEL0_CIM     */
+    u32 fdtsel1_cim;                            /*  FDTSEL1_CIM     */
+    u32 fdtsel2_cim;                            /*  FDTSEL2_CIM     */
+    u32 fdtsel3_cim;                            /*  FDTSEL3_CIM     */
+    u32 futsel0_cim;                            /*  FUTSEL0_CIM     */
+    u32 futsel1_cim;                            /*  FUTSEL1_CIM     */
+    u32 futsel2_cim;                            /*  FUTSEL2_CIM     */
+    u32 futsel3_cim;                            /*  FUTSEL3_CIM     */
+    u32 ssipmd_cim;                             /*  SSIPMD_CIM      */
+    u32 ssictrl_cim;                            /*  SSICTRL_CIM     */
+    u32 srcrsel0_cim;                           /*  SRCRSEL0_CIM    */
+    u32 srcrsel1_cim;                           /*  SRCRSEL1_CIM    */
+    u32 srcrsel2_cim;                           /*  SRCRSEL2_CIM    */
+    u32 srcrsel3_cim;                           /*  SRCRSEL3_CIM    */
+    u32 mixrsel_cim;                            /*  MIXRSEL_CIM     */
+};
+
+struct ssif_regs {
+	u32	ssicr;
+	u32	ssisr;
+	unsigned char dummy_ssifreg1[8];
+	u32	ssifcr;
+	u32	ssifsr;
+	u32	ssiftdr;
+	u32	ssifrdr;
+	u32	ssitdmr;
+	u32	ssifccr;
+	u32	ssifcmr;
+	u32	ssifcsr;
+	unsigned char dummy_ssifreg2[2000];
+};
+
+struct dmac_regs {
+	u32	chctrl;
+};
+
+struct scux_reg_info {
+	void __iomem				*scuxreg;
+	struct scux_ipc_regs		*ipcreg[NUM_SCUX_CH];
+	struct scux_opc_regs		*opcreg[NUM_SCUX_CH];
+	struct scux_ffd_regs		*ffdreg[NUM_SCUX_CH];
+	struct scux_ffu_regs		*ffureg[NUM_SCUX_CH];
+	struct scux_src_regs		*srcreg[MAXCH_SRC];
+	struct scux_dvu_regs		*dvureg[MAXCH_DVU];
+	struct scux_mix_regs		*mixreg;
+	struct scux_cim_regs		*cimreg;
+	void __iomem				*ssireg;
+	struct ssif_regs			*ssifreg[MAXCH_SSIF];
+};
+
+struct scu_audio_info {
+	struct scux_reg_info reginfo;
+	struct scu_route_info routeinfo;
+	struct scu_clock_info clockinfo;
+	spinlock_t scu_lock;		/* for common register */
+	unsigned int rate[2];
+	unsigned int volume[2][2];
+	unsigned int mute[2];
+};
+
+/******************************************************************************
+ ==== SSIF ==== 
+******************************************************************************/
+/* SSICRn bit */
+#define	SSICR_REN_DIS	(0<<0)
+#define	SSICR_REN_EN	(1<<0)
+#define	SSICR_TEN_DIS	(0<<1)
+#define	SSICR_TEN_EN	(1<<1)
+#define	SSICR_MUEN	(1<<3)
+#define	SSICR_CKDV_1	(0<<4)
+#define	SSICR_CKDV_2	(1<<4)
+#define	SSICR_CKDV_4	(2<<4)
+#define	SSICR_CKDV_8	(3<<4)
+#define	SSICR_CKDV_16	(4<<4)
+#define	SSICR_CKDV_32	(5<<4)
+#define	SSICR_CKDV_64	(6<<4)
+#define	SSICR_CKDV_128	(7<<4)
+#define	SSICR_CKDV_6	(8<<4)
+#define	SSICR_CKDV_12	(9<<4)
+#define	SSICR_CKDV_24	(10<<4)
+#define	SSICR_CKDV_48	(11<<4)
+#define	SSICR_CKDV_96	(12<<4)
+#define	SSICR_DEL_1CLKDEL (0<<8)
+#define	SSICR_DEL_NODEL (1<<8)
+#define	SSICR_PDTA	(1<<9)
+#define	SSICR_SDTA	(1<<10)
+#define	SSICR_SPDP	(1<<11)
+#define	SSICR_SWSP	(1<<12)
+#define	SSICR_SCKP	(1<<13)
+#define	SSICR_SWSD_SLAVE (0<<14)
+#define	SSICR_SWSD_MASTER (1<<14)
+#define	SSICR_M_MASTER	(3<<14)
+#define	SSICR_SCKD_SLAVE (0<<15)
+#define	SSICR_SCKD_MASTER (1<<15)
+#define	SSICR_SWL_ST8	(0<<16)
+#define	SSICR_SWL_ST16	(1<<16)
+#define	SSICR_SWL_ST24	(2<<16)
+#define	SSICR_SWL_ST32	(3<<16)
+#define	SSICR_SWL_ST48	(4<<16)
+#define	SSICR_SWL_ST64	(5<<16)
+#define	SSICR_SWL_ST128	(6<<16)
+#define	SSICR_SWL_ST256	(7<<16)
+#define	SSICR_DWL_ST8	(0<<19)
+#define	SSICR_DWL_ST16	(1<<19)
+#define	SSICR_DWL_ST18	(2<<19)
+#define	SSICR_DWL_ST20	(3<<19)
+#define	SSICR_DWL_ST22	(4<<19)
+#define	SSICR_DWL_ST24	(5<<19)
+#define	SSICR_DWL_ST32	(6<<19)
+#define	SSICR_CHNL_ST1	(0<<22)
+#define	SSICR_CHNL_ST2	(1<<22)
+#define	SSICR_CHNL_ST3	(2<<22)
+#define	SSICR_CHNL_ST4	(3<<22)
+#define	SSICR_IIEN	(1<<25)
+#define	SSICR_ROIEN	(1<<26)
+#define	SSICR_RUIEN	(1<<27)
+#define	SSICR_TOIEN	(1<<28)
+#define	SSICR_TUIEN	(1<<29)
+#define	SSICR_CKS	(1<<30)
+
+
+/* for SSI start */
+#define	SSICR_ENABLE	(SSICR_REN_EN	| \
+			 SSICR_ROIEN	| \
+			 SSICR_RUIEN	| \
+			 SSICR_TOIEN)
+
+/* SSISRn bit */
+#define	SSISR_IDST	(1<<0)
+#define	SSISR_SWNO	(1<<1)
+#define	SSISR_CHNO0	(1<<2)
+#define	SSISR_CHNO1	(1<<3)
+#define	SSISR_DIRQ	(1<<24)
+#define	SSISR_IIRQ	(1<<25)
+#define	SSISR_OIRQ	(1<<26)
+#define	SSISR_UIRQ	(1<<27)
+#define	SSISR_DMRQ	(1<<28)
+#define	SSISR_ROIRQ	(0<<26)
+#define	SSISR_RUIRQ	(0<<27)
+#define	SSISR_TOIRQ	(0<<28)
+#define	SSISR_TUIRQ	(0<<29)
+
+/* SSIFCRn bit */
+#define SSIFCR_RFRST	(1<<0)
+#define SSIFCR_TFRST	(1<<1)
+#define SSIFCR_RIE	(1<<2)
+#define SSIFCR_TIE	(1<<3)
+
+/* SSI TDM Mode Register Setting */
+/*  [17] RXDMUTE  : B'0 : Rx Direct Data MUTE : Rx Direct Data                     */
+/*  [8] CONT  : B'1 : WS Continue Mode:Enables WS continue mode                    */
+/*  [0] TDM      : B'0 : TDM Mode : Disables TDM mode                              */
+#define	SSITDMR_TDM_DIS	        (0<<0)
+#define	SSITDMR_TDM_EN	        (1<<0)
+#define	SSITDMR_CONT_DIS        (0<<8)
+#define	SSITDMR_CONT_EN	        (1<<8)
+#define	SSITDMR_RXDMUTE_RCVDATA (0<<17)
+#define	SSITDMR_RXDMUTE_0DATA	(1<<17)
+#define SSI_SSITDMR_BASE_INIT_VALUE         (SSITDMR_RXDMUTE_RCVDATA | \
+                                             SSITDMR_CONT_EN | \
+                                             SSITDMR_TDM_DIS)
+
+/* ==== SSI Channel0 ==== */
+/* SSI0 Control Register Setting */
+#define SSI_SSICR0_CKS_VALUE        (0x00000000uL)
+#define SSI_SSICR0_CHNL_VALUE       (0x00000000uL)
+#define SSI_SSICR0_DWL_VALUE        (0x00080000uL)
+#define SSI_SSICR0_SWL_VALUE        (0x00030000uL)
+#define SSI_SSICR0_SCKD_VALUE       (0x00008000uL)
+#define SSI_SSICR0_SWSD_VALUE       (0x00004000uL)
+#define SSI_SSICR0_SCKP_VALUE       (0x00000000uL)
+#define SSI_SSICR0_SWSP_VALUE       (0x00000000uL)
+#define SSI_SSICR0_SPDP_VALUE       (0x00000000uL)
+#define SSI_SSICR0_SDTA_VALUE       (0x00000000uL)
+#define SSI_SSICR0_PDTA_VALUE       (0x00000000uL)
+#define SSI_SSICR0_DEL_VALUE        (0x00000000uL)
+#define SSI_SSICR0_CKDV_VALUE       (0x00000030uL)
+
+/*  [30]    CKS     : B'0    : AUDIO_X1 input                                                   */
+/*  [23:22] CHNL    : B'00   : 1 channel / system word                                          */
+/*  [21:19] DWL     : B'001  : 16 bit / data word                                               */
+/*  [18:16] SWL     : B'011  : 32 bit / system word                                             */
+/*  [15]    SCKD    : B'1    : Serial Bit Clock Direction:master mode                           */
+/*  [14]    SWSD    : B'1    : Serial WS Direction:master mode                                  */
+/*  [13]    SCKP    : B'0    : SSIWS and SSIDATA change at the SSISCK falling edge              */
+/*  [12]    SWSP    : B'0    : SSIWS is low for 1st channel, high for 2nd channel               */
+/*  [11]    SPDP    : B'0    : Padding bits are low                                             */
+/*  [10]    SDTA    : B'0    : Tx and Rx in the order of serial data and padding bits           */
+/*  [9]     PDTA    : B'0    : The lower bits of parallel data(SSITDR, SSIRDR) are transferred prior to the upper bits                  */
+/*  [8]     DEL     : B'0    : 1 clock cycle delay between SSIWS and SSIDATA                    */
+/*  [7:4]   CKDV    : B'0011 : AUDIO dia / 8 (64FS,AUDIO_X1@22.5792MHz/32bit system word)         */
+#define SSI_SSICR0_USER_INIT_VALUE  (SSI_SSICR0_CKS_VALUE  | \
+                                     SSI_SSICR0_CHNL_VALUE | \
+                                     SSI_SSICR0_DWL_VALUE  | \
+                                     SSI_SSICR0_SWL_VALUE  | \
+                                     SSI_SSICR0_SCKD_VALUE | \
+                                     SSI_SSICR0_SWSD_VALUE | \
+                                     SSI_SSICR0_SCKP_VALUE | \
+                                     SSI_SSICR0_SWSP_VALUE | \
+                                     SSI_SSICR0_SPDP_VALUE | \
+                                     SSI_SSICR0_SDTA_VALUE | \
+                                     SSI_SSICR0_PDTA_VALUE | \
+                                     SSI_SSICR0_DEL_VALUE  | \
+                                     SSI_SSICR0_CKDV_VALUE)
+
+/* SSI SSICR0 Register INIT Setting */
+/*  [29]    TUIEN   : B'0    : Disables an underflow interrupt              */
+/*  [28]    TOIEN   : B'0    : Disables an overflow interrupt               */
+/*  [27]    RUIEN   : B'0    : Disables an underflow interrupt              */
+/*  [26]    ROIEN   : B'0    : Receive Overflow Interrupt Enable            */
+/*  [25]    IIEN    : B'0    : Disables an idle mode interrupt              */
+/*  [3]     MUEN    : B'0    : This module is not muted                     */
+/*  [1]     TEN     : B'0    : Disables the transmit operation              */
+/*  [0]     REN     : B'0    : Disables the receive operation               */
+/*  [30:4] SSI_SSICR0_USER_INIT_VALUE SSICR0 INIT                          */
+#define SSI_SSICR_TUIEN_INIT_VALUE          (0x00000000uL)
+#define SSI_SSICR_TOIEN_INIT_VALUE          (0x00000000uL)
+#define SSI_SSICR_RUIEN_INIT_VALUE          (0x00000000uL)
+#define SSI_SSICR_ROIEN_INIT_VALUE          (0x00000000uL)
+#define SSI_SSICR_IIEN_INIT_VALUE           (0x00000000uL)
+#define SSI_SSICR_MUEN_INIT_VALUE           (0x00000000uL)
+#define SSI_SSICR_TEN_INIT_VALUE            (0x00000000uL)
+#define SSI_SSICR_REN_INIT_VALUE            (0x00000000uL)
+#define SSI_SSICR_BASE_INIT_VALUE           (SSI_SSICR_TUIEN_INIT_VALUE | \
+                                             SSI_SSICR_TOIEN_INIT_VALUE | \
+                                             SSI_SSICR_RUIEN_INIT_VALUE | \
+                                             SSI_SSICR_ROIEN_INIT_VALUE | \
+                                             SSI_SSICR_IIEN_INIT_VALUE  | \
+                                             SSI_SSICR_MUEN_INIT_VALUE  | \
+                                             SSI_SSICR_TEN_INIT_VALUE   | \
+                                             SSI_SSICR_REN_INIT_VALUE   | \
+                                             SSI_SSICR0_USER_INIT_VALUE)
+/*
+ * SSICR setting for WM8978
+ *   playback, master, 16bit, stereo
+ *   SCLK=256fs(MCLK)/8=32fs
+ */
+#define	SSICR_PLAY_WM8978_ST	(SSICR_CHNL_ST1    | \
+			 SSICR_DWL_ST16 | \
+			 SSICR_SWL_ST32 | \
+			 SSICR_M_MASTER | \
+			 SSICR_CKDV_8)
+/*
+ * SSICR setting for WWM8978
+ *   capture, slave, 16bit, stereo
+ *   SCLK=256fs(MCLK)/8=32fs
+ */
+#define	SSICR_CAP_WM8978_ST	(SSICR_CHNL_ST1    | \
+			 SSICR_DWL_ST16 | \
+			 SSICR_SWL_ST16 | \
+			 SSICR_SWSD_SLAVE | \
+			 SSICR_REN_EN)
+
+/* SSI0 FIFO Control Register Setting */
+/*  [7:6] TTRG  : B'00 : Transmit Data Trigger Number:7                                         */
+/*  [5:4] RTRG  : B'00 : Receive Data Trigger Number:1                                          */
+/*  [3]   TIE   : B'0  : Transmit data empty interrupt (TXI) request is disabled    */
+/*  [2]   RIE   : B'0  : Receive data full interrupt (RXI) request is disabled      */
+/*  [1]   TFRST : B'1  : Reset is enabled                                           */
+/*  [0]   RFRST : B'1  : Reset is enabled                                           */
+#define SSI_SSIFCR0_TTRG_VALUE              (0x00000000uL)
+#define SSI_SSIFCR0_RTRG_VALUE              (0x00000000uL)
+#define SSI_SSIFCR_TIE_INIT_VALUE           (0x00000000uL)
+#define SSI_SSIFCR_RIE_INIT_VALUE           (0x00000000uL)
+#define SSI_SSIFCR_TFRST_INIT_VALUE         (0x00000002uL)
+#define SSI_SSIFCR_RFRST_INIT_VALUE         (0x00000001uL)
+
+#define SSI_SSIFCR_BASE_INIT_VALUE          (SSI_SSIFCR0_TTRG_VALUE      | \
+                                             SSI_SSIFCR0_RTRG_VALUE      | \
+                                             SSI_SSIFCR_TIE_INIT_VALUE   | \
+                                             SSI_SSIFCR_RIE_INIT_VALUE   | \
+                                             SSI_SSIFCR_TFRST_INIT_VALUE | \
+                                             SSI_SSIFCR_RFRST_INIT_VALUE)
+
+/******************************************************************************
+ ==== SWRSTCR1 ====
+******************************************************************************/
+#define	SWRSTCR1	0xFCFE0460	/* SWRSTCR1 Address */
+
+#define	SWRSTCR1_SRST11	(1<<1)		/* SSIF5SRST */
+#define	SWRSTCR1_SRST12 (1<<2)		/* SSIF4SRST */
+#define	SWRSTCR1_SRST13 (1<<3)		/* SSIF3SRST */
+#define	SWRSTCR1_SRST14 (1<<4)		/* SSIF2SRST */
+#define	SWRSTCR1_SRST15 (1<<5)		/* SSIF1SRST */
+#define	SWRSTCR1_SRST16 (1<<6)		/* SSIF0SRST */
+#define	SWRSTCR1_AXTALE (1<<7)		/* AXTALE    */
+
+/************************************************************************
+	external prototype declaration
+************************************************************************/
+extern struct snd_soc_platform_driver scu_platform;
+extern struct scu_route_info *scu_get_route_info(void);
+extern struct scu_platform_data *scu_get_platform_data(void);
+extern void scu_init_ssi(int, int, int, int, int);
+extern void scu_init_src(int, unsigned int, unsigned int);
+extern void scu_init_dvc(int);
+extern void scu_deinit_ssi(int, int, int, int);
+extern void scu_deinit_src(int);
+extern void scu_deinit_dvc(int);
+extern int scu_check_route(int dir, struct scu_route_info *routeinfo);
+extern int scu_dai_add_control(struct snd_card *card);
+
+#endif /* SH_SCUX_H */
diff --git a/include/uapi/Kbuild b/include/uapi/Kbuild
index 81d2106..bb20fb2 100644
--- a/include/uapi/Kbuild
+++ b/include/uapi/Kbuild
@@ -7,6 +7,7 @@ header-y += asm-generic/
 header-y += linux/
 header-y += sound/
 header-y += mtd/
+header-y += mfd/
 header-y += rdma/
 header-y += video/
 header-y += drm/
diff --git a/include/uapi/mfd/Kbuild b/include/uapi/mfd/Kbuild
new file mode 100644
index 0000000..8e5663e
--- /dev/null
+++ b/include/uapi/mfd/Kbuild
@@ -0,0 +1,2 @@
+# UAPI Header export list
+header-y += raa730300.h
diff --git a/include/uapi/mfd/raa730300.h b/include/uapi/mfd/raa730300.h
new file mode 100644
index 0000000..5d9996e
--- /dev/null
+++ b/include/uapi/mfd/raa730300.h
@@ -0,0 +1,28 @@
+/*
+ * raa730300.h
+ *
+ * Copyright (C) 2013 Renesas Solutions Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _UAPI_RAA730300_H
+#define _UAPI_RAA730300_H
+
+struct sa_reg {
+	unsigned char	addr;
+	unsigned char	value;
+};
+
+#define RAA730300_NUM_OF_REGS 0x17
+struct sa_regs {
+	int		num;
+	struct sa_reg	regs[RAA730300_NUM_OF_REGS];
+};
+
+#define	RAA730300_IOCTL_REG_READ	0
+#define	RAA730300_IOCTL_REG_WRITE	1
+
+#endif		/* _UAPI_RAA730300_H */
diff --git a/include/video/vdc5fb.h b/include/video/vdc5fb.h
new file mode 100644
index 0000000..6e78df8
--- /dev/null
+++ b/include/video/vdc5fb.h
@@ -0,0 +1,126 @@
+/*
+ * Copyright (C) 2013 Renesas Solutions Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef _VDC5FB_H_
+#define _VDC5FB_H_
+
+#ifdef __KERNEL__
+
+#include <linux/fb.h>
+
+/* NUMBER OF CHANNELS */
+#define	VDC5FB_NUM_CH		2
+
+/* NUMBER OF RESOURCES */
+#define	VDC5FB_NUM_RES		3
+/* MEM resource 0 is used for registers */
+/* MEM resource 1 is used for framebuffer(s) */
+/* IRQ resource 0 is used for irq numbers */
+
+/* BASE ADDRESS AND SIZE OF REGISTERS */
+#define	VDC5FB_REG_BASE(x)	(0xFCFF6000 + (0x2000 * (x)))
+#define	VDC5FB_REG_SIZE		0x2000
+
+/* START AND TOTAL NUMBER OF IRQS */
+#define	VDC5FB_IRQ_BASE(x)	(75 + (24 * (x)))
+#define	VDC5FB_IRQ_SIZE		23
+
+/* clock_source */
+enum {
+	ICKSEL_INPSEL = 0,
+	ICKSEL_EXTCLK0,
+	ICKSEL_EXTCLK1,
+	ICKSEL_P1CLK,
+};
+
+/* tcon_sel */
+enum {				/* index */
+	LCD_TCON0 = 0,
+	LCD_TCON1,
+	LCD_TCON2,
+	LCD_TCON3,
+	LCD_TCON4,
+	LCD_TCON5,
+	LCD_TCON6,
+	LCD_MAX_TCON,
+};
+#define	TCON_SEL_STVA		0	/* STVA/VS */
+#define	TCON_SEL_STVB		1	/* STVB/VE */
+#define	TCON_SEL_STH		2	/* STH/SP/HS */
+#define	TCON_SEL_STB		3	/* STB/LP/HE */
+#define	TCON_SEL_CPV		4	/* CPV/GCK */
+#define	TCON_SEL_POLA		5	/* POLA */
+#define	TCON_SEL_POLB		6	/* POLB */
+#define	TCON_SEL_DE		7	/* DE */
+#define	TCON_SEL_UNUSED		0xff
+
+/* out_format */
+enum {
+	OUT_FORMAT_RGB888 = 0,
+	OUT_FORMAT_RGB666,
+	OUT_FORMAT_RGB565,
+};
+
+/* board-specific data */
+struct vdc5fb_pdata {
+	const char *name;
+	struct fb_videomode *videomode;
+	int bpp;		/* should be 16 or 32 */
+	int panel_icksel;	/* should be ICKSEL_P1CLK */
+	unsigned long panel_width;
+	unsigned long panel_height;
+	unsigned long flm_max;
+	int out_format;
+	int use_lvds;
+	unsigned char tcon_sel[LCD_MAX_TCON];
+/* board specific setting function */
+	int (*pinmux)(struct platform_device *pdev);
+	int (*reset)(struct platform_device *pdev);
+	int (*tcon)(struct platform_device *pdev);
+};
+#endif /* __KERNEL__ */
+
+/*****************/
+/* VDC5FB IOCTLs */
+/*****************/
+
+#define	FBIOGET_CONTRAST	_IOR('F', 0x21, int)
+#define	FBIOPUT_CONTRAST	_IOW('F', 0x22, int)
+#define	FBIOGET_BRIGHT		_IOR('F', 0x23, int)
+#define	FBIOPUT_BRIGHT		_IOW('F', 0x24, int)
+#define	FBIOGET_FRAME		_IOW('F', 0x25, int)
+#define	FBIOPUT_FRAME		_IOW('F', 0x26, int)
+
+struct fbio_bright {
+	unsigned short pbrt_r;	/* 0-1023, inclusive */
+	unsigned short pbrt_g;
+	unsigned short pbrt_b;
+};
+
+struct fbio_contrast {
+	unsigned short cont_r;	/* 0-255, inclusive */
+	unsigned short cont_g;
+	unsigned short cont_b;
+};
+
+struct fbio_frame {
+	unsigned short fr_num;	/* 0-(frame_max-1), inclusive */
+	unsigned short fr_max;
+};
+
+#endif /* _VDC5FB_H_ */
diff --git a/sound/soc/codecs/wm8978.c b/sound/soc/codecs/wm8978.c
index f347af3..518b2b1 100644
--- a/sound/soc/codecs/wm8978.c
+++ b/sound/soc/codecs/wm8978.c
@@ -1,6 +1,7 @@
 /*
  * wm8978.c  --  WM8978 ALSA SoC Audio Codec driver
  *
+ * Copyright (C) 2013  Renesas Solutions Corp.
  * Copyright (C) 2009-2010 Guennadi Liakhovetski <g.liakhovetski@gmx.de>
  * Copyright (C) 2007 Carlos Munoz <carlos@kenati.com>
  * Copyright 2006-2009 Wolfson Microelectronics PLC.
@@ -27,7 +28,7 @@
 #include <sound/initval.h>
 #include <sound/tlv.h>
 #include <asm/div64.h>
-
+#include <linux/spi/spi.h>
 #include "wm8978.h"
 
 static const struct reg_default wm8978_reg_defaults[] = {
@@ -150,10 +151,11 @@ static const struct snd_kcontrol_new wm8978_snd_controls[] = {
 
 	SOC_DOUBLE("DAC Inversion Switch", WM8978_DAC_CONTROL, 0, 1, 1, 0),
 
+#if !defined(CONFIG_MACH_RSKRZA1) /* The volume of a codec is not changed, either, when the volume of DVU is changed.  */
 	SOC_DOUBLE_R_TLV("PCM Volume",
 		WM8978_LEFT_DAC_DIGITAL_VOLUME, WM8978_RIGHT_DAC_DIGITAL_VOLUME,
 		0, 255, 0, digital_tlv),
-
+#endif
 	SOC_SINGLE("High Pass Filter Switch", WM8978_ADC_CONTROL, 8, 1, 0),
 	SOC_SINGLE("High Pass Cut Off", WM8978_ADC_CONTROL, 4, 7, 0),
 	SOC_DOUBLE("ADC Inversion Switch", WM8978_ADC_CONTROL, 0, 1, 1, 0),
@@ -751,6 +753,7 @@ static int wm8978_hw_params(struct snd_pcm_substream *substream,
 	}
 
 	/* filter coefficient */
+#if !defined(CONFIG_MACH_RSKRZA1) /* codec setup is fixed to 44100Hz */
 	switch (params_rate(params)) {
 	case 8000:
 		add_ctl |= 0x5 << 1;
@@ -771,9 +774,14 @@ static int wm8978_hw_params(struct snd_pcm_substream *substream,
 	case 48000:
 		break;
 	}
+#endif
 
 	/* Sampling rate is known now, can configure the MCLK divider */
+#if defined(CONFIG_MACH_RSKRZA1) /* codec setup is fixed to 44100Hz */
+	wm8978->f_256fs = 44100 * 256;
+#else
 	wm8978->f_256fs = params_rate(params) * 256;
+#endif
 
 	if (wm8978->sysclk == WM8978_MCLK) {
 		wm8978->mclk_idx = -1;
@@ -975,7 +983,6 @@ static int wm8978_probe(struct snd_soc_codec *codec)
 {
 	struct wm8978_priv *wm8978 = snd_soc_codec_get_drvdata(codec);
 	int ret = 0, i;
-
 	/*
 	 * Set default system clock to PLL, it is more precise, this is also the
 	 * default hardware setting
@@ -1034,9 +1041,8 @@ static const struct regmap_config wm8978_regmap_config = {
 	.reg_defaults = wm8978_reg_defaults,
 	.num_reg_defaults = ARRAY_SIZE(wm8978_reg_defaults),
 };
-
-static int wm8978_i2c_probe(struct i2c_client *i2c,
-			    const struct i2c_device_id *id)
+#if !(defined(CONFIG_SPI_MASTER) && defined(CONFIG_MACH_RSKRZA1))
+static int wm8978_i2c_probe(struct i2c_client *i2c, const struct i2c_device_id *id)
 {
 	struct wm8978_priv *wm8978;
 	int ret;
@@ -1061,7 +1067,7 @@ static int wm8978_i2c_probe(struct i2c_client *i2c,
 		dev_err(&i2c->dev, "Failed to issue reset: %d\n", ret);
 		return ret;
 	}
-
+	
 	ret = snd_soc_register_codec(&i2c->dev,
 			&soc_codec_dev_wm8978, &wm8978_dai, 1);
 	if (ret != 0) {
@@ -1094,8 +1100,97 @@ static struct i2c_driver wm8978_i2c_driver = {
 	.remove =   wm8978_i2c_remove,
 	.id_table = wm8978_i2c_id,
 };
+#else /* !(defined(CONFIG_SPI_MASTER) && defined(CONFIG_MACH_RSKRZA1)) */
+/* RSPI4 is Registration */
+static int wm8978_rspi_probe(struct spi_device *rspi)
+{
+	struct wm8978_priv *wm8978;
+	int ret;
+
+	wm8978 = devm_kzalloc(&rspi->dev, sizeof(struct wm8978_priv), GFP_KERNEL);
+	if (wm8978 == NULL){
+		pr_warn(KERN_WARNING "error:wm8978_rspi_probe():NULL.\n");
+		return -ENOMEM;
+	}
+
+	wm8978->regmap = devm_regmap_init_spi(rspi, &wm8978_regmap_config);
+	if (IS_ERR(wm8978->regmap)) {
+		ret = PTR_ERR(wm8978->regmap);
+		dev_err(&rspi->dev, "Failed to allocate regmap: %d\n", ret);
+		return ret;
+	}
+
+	spi_set_drvdata(rspi, wm8978);
+	
+	/* Reset the codec */
+	ret = regmap_write(wm8978->regmap, WM8978_RESET, 0);
+	if (ret != 0) {
+		dev_err(&rspi->dev, "Failed to issue reset: %d\n", ret);
+		return ret;
+	}
+
+	ret = snd_soc_register_codec(&rspi->dev,&soc_codec_dev_wm8978, &wm8978_dai, 1);
+
+	if (ret != 0) {
+		dev_err(&rspi->dev, "Failed to register CODEC: %d\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+static int wm8978_rspi_remove(struct spi_device *rspi)
+{
+	snd_soc_unregister_codec(&rspi->dev);
+	return 0;
+}
+
+static struct spi_driver wm8978_rspi_driver = {
+	.driver = {
+		.name	= "wm8978",
+		.owner	= THIS_MODULE,
+	},
+	.probe		= wm8978_rspi_probe,
+	.remove		= wm8978_rspi_remove,
+};
+#endif /* !(defined(CONFIG_SPI_MASTER) && defined(CONFIG_MACH_RSKRZA1)) */
+
+static int __init wm8978_modinit(void)
+{
+	int ret = 0;
+	
+#if (defined(CONFIG_SPI_MASTER) && defined(CONFIG_MACH_RSKRZA1))
+	ret = spi_register_driver(&wm8978_rspi_driver);
+	if (ret != 0) {
+		printk(KERN_ERR "Failed to register wm8978 RSPI driver: %d\n",
+		       ret);
+	}else{
+		printk(KERN_WARNING "wm8978_modinit(). OK \n");
+	}
+#else
+	ret = i2c_add_driver(&wm8978_i2c_driver);
+	if (ret != 0) {
+		printk(KERN_ERR "Failed to register wm8978 I2C driver: %d\n",
+		       ret);
+	}
+#endif
+
+	return ret;
+}
+
+module_init(wm8978_modinit);
+
+static void __exit wm8978_exit(void)
+{
+#if (defined(CONFIG_SPI_MASTER) && defined(CONFIG_MACH_RSKRZA1))
+	spi_unregister_driver(&wm8978_rspi_driver);
+#else
+	i2c_del_driver(&wm8978_i2c_driver);
+#endif
+
+}
 
-module_i2c_driver(wm8978_i2c_driver);
+module_exit(wm8978_exit);
 
 MODULE_DESCRIPTION("ASoC WM8978 codec driver");
 MODULE_AUTHOR("Guennadi Liakhovetski <g.liakhovetski@gmx.de>");
diff --git a/sound/soc/sh/Kconfig b/sound/soc/sh/Kconfig
index 6bcb116..ed93793 100644
--- a/sound/soc/sh/Kconfig
+++ b/sound/soc/sh/Kconfig
@@ -34,6 +34,12 @@ config SND_SOC_SH4_SIU
 	select SH_DMAE
 	select FW_LOADER
 
+config SND_SOC_SCUX
+	tristate
+	depends on ARCH_RZA1
+	select DMA_ENGINE
+	select DMADEVICES
+
 ##
 ## Boards
 ##
@@ -55,4 +61,21 @@ config SND_SIU_MIGOR
 	help
 	  This option enables sound support for the SH7722 Migo-R board
 
+config SND_SCUX_GENMAI
+	tristate "SCUX sound support on GENMAI"
+	depends on ARCH_RZA1
+	select SND_SOC_SCUX
+	select SND_SCUX_WM8978
+
+	help
+	  Enable sound support for the RZA1 GENMAI board.
+	  This is supported to the Renesas SCUX peripheral.
+	  Say Y here if you have enabled, otherwise say N.
+	  To compile this driver as a module, say M.
+
+config SND_SCUX_WM8978
+        tristate "GENMAI WM8978 sound support"
+        depends on SND_SCUX_GENMAI
+        select SND_SOC_WM8978
+
 endmenu
diff --git a/sound/soc/sh/Makefile b/sound/soc/sh/Makefile
index 849b387..0600fae 100644
--- a/sound/soc/sh/Makefile
+++ b/sound/soc/sh/Makefile
@@ -7,14 +7,18 @@ snd-soc-hac-objs	:= hac.o
 snd-soc-ssi-objs	:= ssi.o
 snd-soc-fsi-objs	:= fsi.o
 snd-soc-siu-objs	:= siu_pcm.o siu_dai.o
+snd-soc-scux-objs	:= scux_pcm.o scux_dai.o
 obj-$(CONFIG_SND_SOC_SH4_HAC)	+= snd-soc-hac.o
 obj-$(CONFIG_SND_SOC_SH4_SSI)	+= snd-soc-ssi.o
 obj-$(CONFIG_SND_SOC_SH4_FSI)	+= snd-soc-fsi.o
 obj-$(CONFIG_SND_SOC_SH4_SIU)	+= snd-soc-siu.o
+obj-$(CONFIG_SND_SOC_SCUX)	+= snd-soc-scux.o
 
 ## boards
 snd-soc-sh7760-ac97-objs	:= sh7760-ac97.o
 snd-soc-migor-objs		:= migor.o
+snd-soc-genmai-objs		:= genmai.o
 
 obj-$(CONFIG_SND_SH7760_AC97)	+= snd-soc-sh7760-ac97.o
 obj-$(CONFIG_SND_SIU_MIGOR)	+= snd-soc-migor.o
+obj-$(CONFIG_SND_SCUX_GENMAI)	+= snd-soc-genmai.o
diff --git a/sound/soc/sh/genmai.c b/sound/soc/sh/genmai.c
new file mode 100644
index 0000000..266f8ec
--- /dev/null
+++ b/sound/soc/sh/genmai.c
@@ -0,0 +1,585 @@
+/*
+ * sound/soc/sh/genmai.c
+ *     This file is ALSA SoC driver for genmai.
+ *
+ * Copyright (C) 2013 Renesas Solutions Corp.
+ * Copyright (C) 2013 Renesas Electronics Corporation
+ *
+ * This file is based on the sound/soc/sh/migor.c
+ *
+ * ALSA SoC driver for Migo-R
+ *
+ * Copyright (C) 2009-2010 Guennadi Liakhovetski <g.liakhovetski@gmx.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/device.h>
+#include <linux/module.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/sh_scux.h>
+
+#undef DEBUG
+#ifdef DEBUG
+#define FNC_ENTRY	pr_info("entry:%s:%d\n", __func__, __LINE__);
+#define FNC_EXIT	pr_info("exit:%s:%d\n", __func__, __LINE__);
+#define DBG_POINT()	pr_info("check:%s:%d\n", __func__, __LINE__);
+#define DBG_MSG(args...)	pr_info(args)
+#else  /* DEBUG */
+#define FNC_ENTRY
+#define FNC_EXIT
+#define DBG_POINT()
+#define DBG_MSG(args...)
+#endif /* DEBUG */
+static struct scu_route_info *routeinfo;
+
+int scu_check_route(int dir, struct scu_route_info *routeinfo)
+{
+	if (!dir) { /* playback */
+		if (routeinfo->p_route != RP_MEM_SSI0 &&
+		    routeinfo->p_route != RP_MEM_SRC1_SSI0 &&
+		    routeinfo->p_route != RP_MEM_SRC1_DVC1_SSI0) {
+			pr_info("scu playback route is invalid.\n");
+			return -EPERM;
+		}
+	} else { /* capture */
+		if (routeinfo->c_route != RC_SSI0_MEM &&
+		    routeinfo->c_route != RC_SSI0_SRC0_MEM) {
+			pr_info("scu capture route is invalid.\n");
+			return -EPERM;
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(scu_check_route);
+
+/************************************************************************
+
+	DAPM
+
+************************************************************************/
+#undef EV_PRINT
+#ifdef EV_PRINT
+static void event_print(int event, char *evt_str)
+{
+
+	switch (event) {
+	case SND_SOC_DAPM_PRE_PMU:
+		printk(KERN_INFO "%s SND_SOC_DAPM_PRE_PMU\n", evt_str);
+		break;
+	case SND_SOC_DAPM_POST_PMU:
+		printk(KERN_INFO "%s SND_SOC_DAPM_POST_PMU\n", evt_str);
+		break;
+	case SND_SOC_DAPM_PRE_PMD:
+		printk(KERN_INFO "%s SND_SOC_DAPM_PRE_PMD\n", evt_str);
+		break;
+	case SND_SOC_DAPM_POST_PMD:
+		printk(KERN_INFO "%s SND_SOC_DAPM_POST_PMD\n", evt_str);
+		break;
+	default:
+		printk(KERN_INFO "%s unknown event\n", evt_str);
+	}
+}
+#else
+#define event_print(a, b)
+#endif
+
+static int event_ssi0(struct snd_soc_dapm_widget *w,
+		      struct snd_kcontrol *kcontrol, int event)
+{
+	event_print(event, "ssi0");
+	if (event == SND_SOC_DAPM_POST_PMU) {
+		/* playback */
+		routeinfo->pcb.init_ssi = scu_init_ssi;
+		routeinfo->pcb.deinit_ssi = scu_deinit_ssi;
+		/* add capture */
+		routeinfo->ccb.init_ssi = scu_init_ssi;
+		routeinfo->ccb.deinit_ssi = scu_deinit_ssi;
+	} else if (event == SND_SOC_DAPM_PRE_PMD) {
+		/* playback */
+		routeinfo->pcb.init_ssi = NULL;
+		routeinfo->pcb.deinit_ssi = NULL;
+		/* add capture */
+		routeinfo->ccb.init_ssi = NULL;
+		routeinfo->ccb.deinit_ssi = NULL;
+	}
+	return 0;
+}
+
+static int event_ssi0_src0(struct snd_soc_dapm_widget *w,
+			   struct snd_kcontrol *kcontrol, int event)
+{
+	event_print(event, "ssi0_src0");
+	if (event == SND_SOC_DAPM_POST_PMU) {
+		routeinfo->ccb.init_ssi = scu_init_ssi;
+		routeinfo->ccb.deinit_ssi = scu_deinit_ssi;
+	} else if (event == SND_SOC_DAPM_PRE_PMD) {
+		routeinfo->ccb.init_ssi = NULL;
+		routeinfo->ccb.deinit_ssi = NULL;
+	}
+	return 0;
+}
+
+static int event_ssi0_src1(struct snd_soc_dapm_widget *w,
+			   struct snd_kcontrol *kcontrol, int event)
+{
+	event_print(event, "ssi0_src1");
+	if (event == SND_SOC_DAPM_POST_PMU) {
+		routeinfo->pcb.init_ssi = scu_init_ssi;
+		routeinfo->pcb.deinit_ssi = scu_deinit_ssi;
+	} else if (event == SND_SOC_DAPM_PRE_PMD) {
+		routeinfo->pcb.init_ssi = NULL;
+		routeinfo->pcb.deinit_ssi = NULL;
+	}
+	return 0;
+}
+
+static int event_ssi0_dvc1(struct snd_soc_dapm_widget *w,
+			   struct snd_kcontrol *kcontrol, int event)
+{
+	event_print(event, "ssi0_dvc1");
+	if (event == SND_SOC_DAPM_POST_PMU) {
+		routeinfo->pcb.init_ssi = scu_init_ssi;
+		routeinfo->pcb.deinit_ssi = scu_deinit_ssi;
+	} else if (event == SND_SOC_DAPM_PRE_PMD) {
+		routeinfo->pcb.init_ssi = NULL;
+		routeinfo->pcb.deinit_ssi = NULL;
+	}
+	return 0;
+}
+
+
+static int event_src0(struct snd_soc_dapm_widget *w,
+		      struct snd_kcontrol *kcontrol, int event)
+{
+	event_print(event, "src0");
+	if (event == SND_SOC_DAPM_POST_PMU) {
+		routeinfo->ccb.init_src = scu_init_src;
+		routeinfo->ccb.deinit_src = scu_deinit_src;
+	} else if (event == SND_SOC_DAPM_PRE_PMD) {
+		routeinfo->ccb.init_src = NULL;
+		routeinfo->ccb.deinit_src = NULL;
+	}
+	return 0;
+}
+
+static int event_src1(struct snd_soc_dapm_widget *w,
+		      struct snd_kcontrol *kcontrol, int event)
+{
+	event_print(event, "src1");
+	if (event == SND_SOC_DAPM_POST_PMU) {
+		routeinfo->pcb.init_src = scu_init_src;
+		routeinfo->pcb.deinit_src = scu_deinit_src;
+	} else if (event == SND_SOC_DAPM_PRE_PMD) {
+		routeinfo->pcb.init_src = NULL;
+		routeinfo->pcb.deinit_src = NULL;
+	}
+	return 0;
+}
+
+static int event_src1_dvc1(struct snd_soc_dapm_widget *w,
+			   struct snd_kcontrol *kcontrol, int event)
+{
+	event_print(event, "src1_dvc1");
+	if (event == SND_SOC_DAPM_POST_PMU) {
+		routeinfo->pcb.init_src = scu_init_src;
+		routeinfo->pcb.deinit_src = scu_deinit_src;
+	} else if (event == SND_SOC_DAPM_PRE_PMD) {
+		routeinfo->pcb.init_src = NULL;
+		routeinfo->pcb.deinit_src = NULL;
+	}
+	return 0;
+}
+
+static int event_dvc1(struct snd_soc_dapm_widget *w,
+		      struct snd_kcontrol *kcontrol, int event)
+{
+	event_print(event, "dvc1");
+	if (event == SND_SOC_DAPM_POST_PMU) {
+		routeinfo->pcb.init_dvc = scu_init_dvc;
+		routeinfo->pcb.deinit_dvc = scu_deinit_dvc;
+	} else if (event == SND_SOC_DAPM_PRE_PMD) {
+		routeinfo->pcb.init_dvc = NULL;
+		routeinfo->pcb.deinit_dvc = NULL;
+	}
+	return 0;
+}
+
+static void scu_playback_route_control(struct snd_soc_dapm_context *dapm)
+{
+	snd_soc_dapm_disable_pin(dapm, "SSI0_OUT0");
+	snd_soc_dapm_disable_pin(dapm, "SSI0_OUT1");
+	snd_soc_dapm_disable_pin(dapm, "SSI0_OUT2");
+
+	switch (routeinfo->p_route) {
+	case RP_MEM_SSI0:
+		snd_soc_dapm_enable_pin(dapm, "SSI0_OUT0");
+		break;
+	case RP_MEM_SRC1_SSI0:
+		snd_soc_dapm_enable_pin(dapm, "SSI0_OUT1");
+		break;
+	case RP_MEM_SRC1_DVC1_SSI0:
+		snd_soc_dapm_enable_pin(dapm, "SSI0_OUT2");
+		break;
+	default:
+		break;
+	};
+}
+
+static void scu_capture_route_control(struct snd_soc_dapm_context *dapm)
+{
+	snd_soc_dapm_disable_pin(dapm, "SSI0_IN0");
+	snd_soc_dapm_disable_pin(dapm, "SSI0_IN1");
+
+	switch (routeinfo->c_route) {
+	case RC_SSI0_MEM:
+		snd_soc_dapm_enable_pin(dapm, "SSI0_IN0");
+		break;
+	case RC_SSI0_SRC0_MEM:
+		snd_soc_dapm_enable_pin(dapm, "SSI0_IN1");
+		break;
+	default:
+		break;
+	};
+}
+
+static int scu_get_ssi0_route(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = routeinfo->route_ssi[0];
+
+	return 0;
+}
+
+static int scu_set_ssi0_route(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+
+	if (routeinfo->route_ssi[0] == ucontrol->value.integer.value[0])
+		return 0;
+
+	routeinfo->route_ssi[0] = ucontrol->value.integer.value[0];
+	if (routeinfo->route_ssi[0])
+		routeinfo->p_route |= W_SSI0;
+	else
+		routeinfo->p_route &= ~W_SSI0;
+	scu_playback_route_control(&card->dapm);
+
+	return 1;
+}
+
+static int scu_get_src0_route(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = routeinfo->route_src[SRC0];
+
+	return 0;
+}
+
+static int scu_set_src0_route(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+
+	if (routeinfo->route_src[SRC0] == ucontrol->value.integer.value[0])
+		return 0;
+
+	routeinfo->route_src[SRC0] = ucontrol->value.integer.value[0];
+	if (routeinfo->route_src[SRC0])
+		routeinfo->c_route |= W_SRC0;
+	else
+		routeinfo->c_route &= ~W_SRC0;
+
+	scu_capture_route_control(&card->dapm);
+
+	return 1;
+}
+
+static int scu_get_src1_route(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = routeinfo->route_src[SRC1];
+
+	return 0;
+}
+static int scu_set_src1_route(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+
+	if (routeinfo->route_src[SRC1] == ucontrol->value.integer.value[0]) {
+		return 0;
+	}
+
+	routeinfo->route_src[SRC1] = ucontrol->value.integer.value[0];
+	if (routeinfo->route_src[SRC1])
+		routeinfo->p_route |= W_SRC1;
+	else
+		routeinfo->p_route &= ~W_SRC1;
+
+	scu_playback_route_control(&card->dapm);
+
+	return 1;
+}
+
+static int scu_get_dvc1_route(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = routeinfo->route_dvc[DVC1];
+
+	return 0;
+}
+
+static int scu_set_dvc1_route(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+
+	if (routeinfo->route_dvc[DVC1] == ucontrol->value.integer.value[0])
+		return 0;
+
+	routeinfo->route_dvc[DVC1] = ucontrol->value.integer.value[0];
+	if (routeinfo->route_dvc[DVC1])
+		routeinfo->p_route |= W_DVC1;
+	else
+		routeinfo->p_route &= ~W_DVC1;
+
+	scu_playback_route_control(&card->dapm);
+
+	return 1;
+}
+
+static const char * const widget_switch[] = {"Off", "On"};
+
+static const struct soc_enum widget_switch_enum =
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(widget_switch), widget_switch);
+
+static const struct snd_kcontrol_new playback_controls[] = {
+	SOC_ENUM_EXT("SSI0 Control", widget_switch_enum,
+	scu_get_ssi0_route, scu_set_ssi0_route),
+	SOC_ENUM_EXT("SRC1 Control", widget_switch_enum,
+	scu_get_src1_route, scu_set_src1_route),
+	SOC_ENUM_EXT("DVC1 Control", widget_switch_enum,
+	scu_get_dvc1_route, scu_set_dvc1_route),
+};
+
+static const struct snd_kcontrol_new capture_controls[] = {
+	SOC_ENUM_EXT("SSI0 CapControl", widget_switch_enum,
+	scu_get_ssi0_route, scu_set_ssi0_route),
+	SOC_ENUM_EXT("SRC0 Control", widget_switch_enum,
+	scu_get_src0_route, scu_set_src0_route),
+};
+
+static const struct snd_soc_dapm_widget genmai_dapm_widgets[] = {
+	/* Playback */
+	SND_SOC_DAPM_OUTPUT("SSI0_OUT0"),
+	SND_SOC_DAPM_OUTPUT("SSI0_OUT1"),
+	SND_SOC_DAPM_OUTPUT("SSI0_OUT2"),
+	SND_SOC_DAPM_DAC("MEM_OUT", "HiFi Playback", SND_SOC_NOPM, 0, 0),
+
+	SND_SOC_DAPM_MIXER_E("SSI0", SND_SOC_NOPM, 0, 0, NULL, 0,
+	event_ssi0,
+	SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+	SND_SOC_DAPM_MIXER_E("SSI0_SRC1", SND_SOC_NOPM, 0, 0, NULL, 0,
+	event_ssi0_src1,
+	SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+	SND_SOC_DAPM_MIXER_E("SSI0_DVC1", SND_SOC_NOPM, 0, 0, NULL, 0,
+	event_ssi0_dvc1,
+	SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+	SND_SOC_DAPM_MIXER_E("SRC1", SND_SOC_NOPM, 0, 0, NULL, 0,
+	event_src1,
+	SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+	SND_SOC_DAPM_MIXER_E("DVC1", SND_SOC_NOPM, 0, 0, NULL, 0,
+	event_dvc1,
+	SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+	SND_SOC_DAPM_MIXER_E("src1_dvc1", SND_SOC_NOPM, 0, 0, NULL, 0,
+	event_src1_dvc1,
+	SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+
+	/* Capture */
+	SND_SOC_DAPM_ADC("MEM_IN", "HiFi Capture", SND_SOC_NOPM, 0, 0),
+
+	SND_SOC_DAPM_INPUT("SSI0_IN0"),
+	SND_SOC_DAPM_INPUT("SSI0_IN1"),
+	SND_SOC_DAPM_INPUT("SSI0_IN2"),
+
+	SND_SOC_DAPM_MIXER_E("SSI0", SND_SOC_NOPM, 0, 0, NULL, 0,
+	event_ssi0,
+	SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+	SND_SOC_DAPM_MIXER_E("SSI0_SRC0", SND_SOC_NOPM, 0, 0, NULL, 0,
+	event_ssi0_src0,
+	SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+	SND_SOC_DAPM_MIXER_E("SRC0", SND_SOC_NOPM, 0, 0, NULL, 0,
+	event_src0,
+	SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+};
+
+static const struct snd_soc_dapm_route audio_map[] = {
+	/* Playback route */
+	/* SSI<-MEM */
+	{"SSI0", NULL, "MEM_OUT"},
+	{"SSI0_OUT0", NULL, "SSI0"},
+	/* SSI<-SRC<-MEM */
+	{"SRC1", NULL, "MEM_OUT"},
+	{"SSI0_SRC1", NULL, "SRC1"},
+	{"SSI0_OUT1", NULL, "SSI0_SRC1"},
+	/* SSI<-DVC<-SRC<-MEM */
+	{"DVC1", NULL, "SRC1"},
+	{"SSI0_DVC1", NULL, "DVC1"},
+	{"SSI0_OUT2", NULL, "SSI0_DVC1"},
+
+	/* Capture route */
+	/* MEM<-SSI */
+	{"SSI0", NULL, "SSI0_IN0"},
+	{"MEM_IN", NULL, "SSI0"},
+	/* MEM<-SRC<-SSI */
+	{"SSI0_SRC0", NULL, "SSI0_IN1"},
+	{"SRC0", NULL, "SSI0_SRC0"},
+	{"MEM_IN", NULL, "SRC0"},
+};
+
+/************************************************************************
+
+	ALSA SoC
+
+************************************************************************/
+static int genmai_hw_params(struct snd_pcm_substream *substream,
+			    struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	int ret;
+
+	/* set PLL clock */
+	ret = snd_soc_dai_set_sysclk(codec_dai, 0, 11289600, SND_SOC_CLOCK_IN);
+	if (ret) {
+		pr_err("snd_soc_dai_set_sysclk err=%d\n", ret);
+		return ret;
+	}
+
+	ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_CBS_CFS |
+				  SND_SOC_DAIFMT_I2S |
+				  SND_SOC_DAIFMT_NB_NF);
+	if (ret) {
+		pr_err("snd_soc_dai_set_fmt err=%d\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+static int genmai_hw_free(struct snd_pcm_substream *substream)
+{
+	return 0;
+}
+
+static struct snd_soc_ops genmai_dai_ops = {
+	.hw_params = genmai_hw_params,
+	.hw_free = genmai_hw_free,
+};
+
+static int genmai_dai_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_codec *codec = rtd->codec;
+	struct snd_soc_dapm_context *dapm = &codec->dapm;
+	int ret;
+
+	FNC_ENTRY
+
+	/* Add controls */
+	ret = snd_soc_add_card_controls(rtd->card, playback_controls,
+					ARRAY_SIZE(playback_controls));
+	if (ret) {
+		pr_err("snd_soc_add_card_controls(playback) err=%d\n", ret);
+		return ret;
+	}
+
+	ret = snd_soc_add_card_controls(rtd->card, capture_controls,
+					ARRAY_SIZE(capture_controls));
+	if (ret) {
+		pr_err("snd_soc_add_card_controls(capture) err=%d\n", ret);
+		return ret;
+	}
+
+	/* Add widget and route for scu */
+	ret = snd_soc_dapm_new_controls(dapm, genmai_dapm_widgets,
+					ARRAY_SIZE(genmai_dapm_widgets));
+	if (ret) {
+		pr_err("snd_soc_dapm_new_controls err=%d\n", ret);
+		return ret;
+	}
+
+	ret = snd_soc_dapm_add_routes(dapm, audio_map, ARRAY_SIZE(audio_map));
+	if (ret) {
+		pr_err("snd_soc_dapm_add_routes err=%d\n", ret);
+		return ret;
+	}
+
+	scu_playback_route_control(dapm);
+	scu_capture_route_control(dapm);
+
+	FNC_EXIT
+	return ret;
+}
+/* genmai digital audio interface glue - connects codec <--> CPU */
+static struct snd_soc_dai_link genmai_dai = {
+	.name		= "wm8978",		/* Codec name */
+	.stream_name	= "WM8978",		/* Stream name */
+	.cpu_dai_name	= "scu-ssi-dai",	/* You MAY specify the DAI name of the CPU DAI. If this information is omitted, the CPU-side DAI is matched using .cpu_name/.cpu_of_node only, which only works well when that device exposes a single DAI.*/
+	.codec_dai_name	= "wm8978-hifi",	/* You MUST specify the DAI name within the codec */
+	.platform_name	= "scux-pcm-audio.0",	/* You MAY specify the link's platform/PCM/DMA driver, either by device name, or by DT/OF node, but not both. Some forms of link do not need a platform.*/
+#if (defined(CONFIG_SPI_MASTER) && defined(CONFIG_MACH_RSKRZA1))
+	.codec_name	= "spi4.0",   /* You MUST specify the link's codec, either by device name, or by DT/OF node, but not both.*/
+#else
+	.codec_name	= "wm8978.0-001a",	/* You MUST specify the link's codec, either by device name, or by DT/OF node, but not both.*/
+#endif
+	.ops		= &genmai_dai_ops,	/* machine stream operations */
+	.init		= genmai_dai_init,	/* codec/machine specific init - e.g. add machine controls */
+};
+
+/* genmai audio machine driver */
+static struct snd_soc_card snd_soc_genmai = {
+	.name = "genmai-wm8978",
+	.owner = THIS_MODULE,
+	.dai_link = &genmai_dai,
+	.num_links = 1,
+};
+
+static int __init genmai_probe(struct platform_device *pdev)
+{
+	int ret = -ENOMEM;
+
+	FNC_ENTRY
+
+	routeinfo = scu_get_route_info();
+
+	snd_soc_genmai.dev = &pdev->dev;
+	ret = snd_soc_register_card(&snd_soc_genmai);
+
+	if (ret)
+		pr_err("Unable to register sourd card\n");
+
+	FNC_EXIT
+	return ret;
+}
+
+static struct platform_driver genmai_alsa_driver = {
+	.driver = {
+		.name = "genmai_alsa_soc_platform",
+		.owner = THIS_MODULE,
+	},
+	.probe = genmai_probe,
+};
+
+module_platform_driver(genmai_alsa_driver);
+
+MODULE_AUTHOR(" Renesas Solutions Corp.");
+MODULE_DESCRIPTION("ALSA SoC GENMAI");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/sh/scux_dai.c b/sound/soc/sh/scux_dai.c
new file mode 100644
index 0000000..b1bba4d
--- /dev/null
+++ b/sound/soc/sh/scux_dai.c
@@ -0,0 +1,1214 @@
+/*
+ * sound/soc/sh/scux_dai.c
+ *     This file is ALSA SoC driver for SCUX peripheral.
+ *
+ * Copyright (C) 2013 Renesas Solutions Corp.
+ * Copyright (C) 2013 Renesas Electronics Corporation
+ *
+ * This file is based on the sound/soc/sh/siu_dai.c
+ *
+ * siu_dai.c - ALSA SoC driver for Renesas SH7343, SH7722 SIU peripheral.
+ *
+ * Copyright (C) 2009-2010 Guennadi Liakhovetski <g.liakhovetski@gmx.de>
+ * Copyright (C) 2006 Carlos Munoz <carlos@kenati.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/firmware.h>
+#include <linux/pm_runtime.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/clk.h>
+
+#include <sound/control.h>
+#include <sound/soc.h>
+#include <sound/sh_scux.h>
+
+#undef DEBUG
+#ifdef DEBUG
+#define FNC_ENTRY	pr_info("entry:%s:%d\n", __func__, __LINE__);
+#define FNC_EXIT	pr_info("exit:%s:%d\n", __func__, __LINE__);
+#define DBG_POINT()	pr_info("check:%s:%d\n", __func__, __LINE__);
+#define DBG_MSG(args...)	pr_info(args)
+#else  /* DEBUG */
+#define FNC_ENTRY
+#define FNC_EXIT
+#define DBG_POINT()
+#define DBG_MSG(args...)
+#endif /* DEBUG */
+
+static struct scux_reg_info *scux_reg;
+static spinlock_t *sculock;
+static struct scu_audio_info *ainfo;
+static struct scu_platform_data *pdata;
+
+int32_t getvolume0;
+int32_t getvolume1;
+
+struct scu_route_info *scu_get_route_info(void)
+{
+	return &ainfo->routeinfo;
+}
+EXPORT_SYMBOL(scu_get_route_info);
+
+struct scu_platform_data *scu_get_platform_data(void)
+{
+	return pdata;
+}
+EXPORT_SYMBOL(scu_get_platform_data);
+
+/************************************************************************
+	peripheral function
+************************************************************************/
+static void scu_ssif_softreset(int ch){
+	 u8 reg;
+
+	switch(ch){
+		case 0:
+			writeb(SWRSTCR1_SRST16, (u32 *)SWRSTCR1); /* Soft Reset SSIF0 */
+			break;
+		case 1:
+			writeb(SWRSTCR1_SRST15, (u32 *)SWRSTCR1); /* Soft Reset SSIF1 */
+			break;
+		case 2:
+			writeb(SWRSTCR1_SRST14, (u32 *)SWRSTCR1); /* Soft Reset SSIF2 */
+			break;
+		case 3:
+			writeb(SWRSTCR1_SRST13, (u32 *)SWRSTCR1); /* Soft Reset SSIF3 */
+			break;
+		case 4:
+			writeb(SWRSTCR1_SRST12, (u32 *)SWRSTCR1); /* Soft Reset SSIF4 */
+			break;
+		case 5:
+			writeb(SWRSTCR1_SRST11, (u32 *)SWRSTCR1); /* Soft Reset SSIF5 */
+			break;
+	}
+	udelay(10);
+	writeb(0x00, (u32 *)SWRSTCR1);
+	udelay(10);
+	reg = readb((u32 *)SWRSTCR1);	/* dummy read */
+}
+
+static void scu_ssif_init(void)
+{
+	FNC_ENTRY
+
+	/* SSI TDM Mode Register Setting */
+	writel(SSI_SSITDMR_BASE_INIT_VALUE, &scux_reg->ssifreg[0]->ssitdmr);
+	/* SSI Control register setting */
+	writel(SSI_SSICR_BASE_INIT_VALUE, &scux_reg->ssifreg[0]->ssicr);
+	/* SSI FIFO Control register setting */
+	writel(SSI_SSIFCR_BASE_INIT_VALUE, &scux_reg->ssifreg[0]->ssifcr);
+	/* SSI Status register clear */
+	writel(0, &scux_reg->ssifreg[0]->ssisr);
+		
+	FNC_EXIT
+	return;
+}
+
+static void scu_ssi_control(int master_ch, int slave_ch, int mode)
+{
+	FNC_ENTRY
+	/* SSI setting */
+	if ((readl(&scux_reg->ssifreg[master_ch]->ssicr) & SSICR_ENABLE) == 0) {
+		writel(SSICR_PLAY_WM8978_ST, &scux_reg->ssifreg[master_ch]->ssicr);
+		writel(SSITDMR_CONT_EN, &scux_reg->ssifreg[master_ch]->ssitdmr);
+	}
+	if ((mode == SSI_SLAVE) &&
+	    ((readl(&scux_reg->ssifreg[slave_ch]->ssicr) & SSICR_ENABLE) == 0))
+		writel(SSICR_CAP_WM8978_ST, &scux_reg->ssifreg[slave_ch]->ssicr);
+		
+	FNC_EXIT
+	return;
+}
+
+static void scu_ssi_start(int ssi_ch, int ssi_dir)
+{
+	u32 val;
+
+	FNC_ENTRY
+	
+	if (ssi_dir == SSI_OUT) {
+		/* SSI enable (figure.39.12 flow) */
+		val = readl(&scux_reg->ssifreg[ssi_ch]->ssicr);
+		val |= (SSICR_TUIEN | SSICR_TOIEN );
+		val &= ~(SSICR_IIEN);
+		writel(val, &scux_reg->ssifreg[ssi_ch]->ssicr);
+
+		val = (SSIFCR_TIE | SSIFCR_RFRST );
+		writel(val, &scux_reg->ssifreg[ssi_ch]->ssifcr);
+
+		val = readl(&scux_reg->ssifreg[ssi_ch]->ssicr);
+		val |= SSICR_TEN_EN;
+		writel(val, &scux_reg->ssifreg[ssi_ch]->ssicr);
+	} else { /* ssi_dir == SSI_IN */
+		/* SSI enable (figure.39.14 flow) */
+		val = readl(&scux_reg->ssifreg[ssi_ch]->ssicr);
+		val |= (SSICR_RUIEN | SSICR_ROIEN );
+		writel(val, &scux_reg->ssifreg[ssi_ch]->ssicr);
+
+		val = (SSIFCR_RIE | SSIFCR_TFRST);
+		writel(val, &scux_reg->ssifreg[ssi_ch]->ssifcr);
+
+		val = readl(&scux_reg->ssifreg[ssi_ch]->ssicr);
+		val |= SSICR_REN_EN;
+		writel(val, &scux_reg->ssifreg[ssi_ch]->ssicr);
+	}
+
+	FNC_EXIT
+	return;
+}
+
+static void scu_ssi_stop(int ssi_ch, int ssi_dir)
+{
+	u32 val;
+	int tmout;
+
+	FNC_ENTRY
+
+	if (ssi_dir == SSI_OUT) {
+		/* SSI disable (figure.39.13 flow) */
+		val = readl(&scux_reg->ssifreg[ssi_ch]->ssicr);
+		val &= ~(SSICR_TUIEN | SSICR_TOIEN | SSICR_TEN_EN);
+		writel(val, &scux_reg->ssifreg[ssi_ch]->ssicr);
+
+		val = SSI_SSIFCR_BASE_INIT_VALUE;
+		writel(val, &scux_reg->ssifreg[ssi_ch]->ssifcr);
+
+		tmout = 1000;
+		while (--tmout &&
+		    !(readl(&scux_reg->ssifreg[ssi_ch]->ssisr) & SSISR_IIRQ))
+			udelay(1);
+		if (!tmout)
+			tmout = 1000;
+		while (--tmout &&
+		    !(readl(&scux_reg->ssifreg[ssi_ch]->ssisr) & SSISR_IDST))
+			udelay(1);
+		if (!tmout)
+			pr_info("timeout waiting for SSI idle\n");
+
+	} else { /* ssi_dir == SSI_IN */
+		/* SSI disable (figure.39.15 flow) */
+		val = readl(&scux_reg->ssifreg[ssi_ch]->ssicr);
+		val &= ~(SSICR_RUIEN | SSICR_ROIEN | SSICR_REN_EN);
+		writel(val, &scux_reg->ssifreg[ssi_ch]->ssicr);
+
+		val = SSI_SSIFCR_BASE_INIT_VALUE;
+		writel(val, &scux_reg->ssifreg[ssi_ch]->ssifcr);
+
+		tmout = 1000;
+		while (--tmout &&
+		    !(readl(&scux_reg->ssifreg[ssi_ch]->ssisr) & SSISR_IDST))
+			udelay(1);
+		if (!tmout)
+			pr_info("timeout waiting for SSI idle\n");
+	}
+	
+	scu_ssif_softreset(ssi_ch);
+
+	FNC_EXIT
+}
+
+static u32 scu_src_calc_bsdsr(u32 ratio)
+{
+	u32 val;
+	
+	/* check FSO/FSI ratio */
+	/*  1/4=25, 1/3=33, 1/2=50, 2/3=66, 1/1=100  */
+	if (ratio < 25)
+		val = SRC_BSD012349_BUFDATA_1_6;
+	else if (ratio >= 25 && ratio < 33)
+		val = SRC_BSD012349_BUFDATA_1_4;
+	else if (ratio >= 33 && ratio < 50)
+		val = SRC_BSD012349_BUFDATA_1_3;
+	else if (ratio >= 50 && ratio < 66)
+		val = SRC_BSD012349_BUFDATA_1_2;
+	else if (ratio >= 66 && ratio < 100)
+		val = SRC_BSD012349_BUFDATA_2_3;
+	else /* ratio >= 100 */
+		val = SRC_BSD012349_BUFDATA_1_1;
+
+	return val;
+}
+
+static u32 scu_src_calc_bsisr(u32 ratio)
+{
+	u32 val;
+	
+	/* check FSO/FSI ratio */
+	/*  1/4=25, 1/3=33, 1/2=50, 2/3=66, 1/1=100  */
+	if (ratio < 25)
+		val = SRC_BSI_IJECSIZE_1_6;
+	else if (ratio >= 25 && ratio < 33)
+		val = SRC_BSI_IJECSIZE_1_4;
+	else if (ratio >= 33 && ratio < 50)
+		val = SRC_BSI_IJECSIZE_1_3;
+	else if (ratio >= 50 && ratio < 66)
+		val = SRC_BSI_IJECSIZE_1_2;
+	else if (ratio >= 66 && ratio < 100)
+		val = SRC_BSI_IJECSIZE_2_3;
+	else /* ratio >= 100 */
+		val = SRC_BSI_IJECSIZE_1_1;
+
+	/* IJECPREC */
+	val |= SRC_BSI_IJECPREC;
+
+	return val;
+}
+
+static void scu_src_control(int src_ch, unsigned int rate, unsigned int sync_sw)
+{
+	u64 val = 0;
+	u32 reg, reg2, reg3;
+
+	FNC_ENTRY
+
+	/* SRC0 is capture,SRC1 is playback */
+	if(src_ch == SRC0){
+		/* SRC Activation (SRC_SWRSR) Figure42.7 */
+		writel(0, (u32 *)&scux_reg->srcreg[0]->sc2sr0);
+		writel(1, (u32 *)&scux_reg->srcreg[0]->sc2sr0);
+		/* SRC_SRCIR */
+		writel(1, (u32 *)&scux_reg->srcreg[0]->srcir0);
+
+	/* SRC_ADINR *//* only stereo now */
+		writel((SRCADIN_OTBL_16BIT | SRCADIN_CHNUM_2),
+			(u32 *)&scux_reg->srcreg[0]->sadir0);
+
+		/* SRC_IFSCR INTIFS enable */
+		writel(1, (u32 *)&scux_reg->srcreg[0]->ifscr0);
+
+		/* SRC_IFSVR INTIFS calculation */
+		if (ainfo->rate[src_ch])
+			val = div_u64(SRC_IFS_FSO * rate, ainfo->rate[src_ch]);
+		else /* not convert */
+			val = SRC_IFS_FSO;
+		writel((u32)val, (u32 *)&scux_reg->srcreg[0]->ifsvr0);
+
+		/* SRC_SRCCR */
+		writel((SRC_CR_BIT16 | SRC_CR_BIT12 | SRC_CR_BIT8 | SRC_CR_BIT4 |
+			sync_sw), (u32 *)&scux_reg->srcreg[0]->srccr0);
+
+		/* SRC_MNFSR MINFS calculation */
+		val = div_u64(val * 98, 100);	/* 98% */
+		writel(val, (u32 *)&scux_reg->srcreg[0]->mnfsr0);
+
+		/* FSO/FSI(*100) */
+		if (ainfo->rate[src_ch])
+			val = (ainfo->rate[src_ch] * 100) / rate;
+		else /* not convert */
+			val = 100;
+
+		/* SRC_BSDSR (FSO/FSI Ratio is 6-1/6) */
+		reg = scu_src_calc_bsdsr((u32)val);
+		writel(reg, (u32 *)&scux_reg->srcreg[0]->bfssr0);
+
+		/* SRC_BSISR (FSO/FSI Ratio is 6-1/6) */
+		reg = scu_src_calc_bsisr((u32)val);
+		writel(reg, (u32 *)&scux_reg->srcreg[0]->bfssr0);
+
+		/* SRC_SRCIR */
+		writel(0, (u32 *)&scux_reg->srcreg[0]->srcir0);
+
+	}else if(src_ch == SRC1){
+		reg = readl(&scux_reg->ssifreg[0]->ssicr);
+		reg &= ~(SSICR_TEN_EN | SSICR_REN_EN) ;
+		writel(reg, &scux_reg->ssifreg[0]->ssicr);
+
+		/* SCUX RESET:when DVU is already reset from scu_init_dvc() */
+		if(ainfo->routeinfo.p_route != RP_MEM_SRC1_DVC1_SSI0){
+			writel(SWRSR_SWRST_RST, &scux_reg->cimreg->swrsr);	/* 0xE8209700:SWRSR_CIM SWRST = 0 */
+			udelay(10);
+			writel(SWRSR_SWRST_OPE, &scux_reg->cimreg->swrsr);	/* 0xE8209700:SWRSR_CIM SWRST = 1 */
+			udelay(10);
+		}
+
+		reg = readl(&scux_reg->cimreg->ssirsel_cim);
+		reg |= 0x00000001;						
+		writel(reg, &scux_reg->cimreg->ssirsel_cim);				/* 0xE8209738:SSIRSEL_CIM  SOSEL0 = 01b */
+		writel(IPSLR_FFD_IPC_ASYNC, &scux_reg->ipcreg[src_ch]->ipslr);		/* 0xE8208104:IPSLR_IPC0_n  IPC_PASS_SEL = 011b */
+		writel(OPSLR_ASYNC_OPC_DVU, &scux_reg->opcreg[src_ch]->opslr);		/* 0xE8208504:OPSLR_OPC0_n  OPC_PASS_SEL = 001b	 */
+		writel(FFDPR_CIM_FFD_IPC_ASYNC, &scux_reg->ffdreg[src_ch]->ffdpr);	/* 0xE820890C:FFDPR_FFD0_n  PASS = 01b */
+		writel(FFUPR_NO_PASS_SELECT, &scux_reg->ffureg[src_ch]->ffupr);		/* 0xE8208D0C:FFUPR_FFU0_n  PASS = 00b */
+		writel(THIS_CH_NOT_USED, &scux_reg->cimreg->ssipmd_cim);		/* 0xE820975C:SSIPMD_CIM    SSI345EN = 0, SSI012EN = 0 */
+		
+		/* SSICTRL_CIM is Direct send setting */
+		reg = readl((u32 *)&scux_reg->cimreg->ssictrl_cim);
+		reg &= ~(SSICTRL_SSI3TX_EN | SSICTRL_SSI3RX_EN);		/* SSICTRL_CIM  SSI3RX = 0, SSI3TX = 0	: value = 0xBBFFFFFF */
+		reg |= SSICTRL_SSI0TX_EN;					/* SSICTRL_CIM  SSI0TX = 1		: value = 0x00004000 */
+		writel(reg, &scux_reg->cimreg->ssictrl_cim);			/* 0xE8209760 : SSI0TX = 1 */
+
+		/* FDTSELn_CIM SCKDIV setting */
+		/* FDTSELn_CIM    SCKDIV = AUDIO_X1(22579200Hz) / Fin  */
+		/* MNFSRp_2SRC0_m MINFS  = (2^22 * Fin / Fout) * 90% */
+		/* IFSVRp_2SRC0_m INTIFS = 2^22 * Fin / Fout  */
+		/* Fin = Input Sampling Rate, Fout = Output Sampling Rate(44100Hz) */
+		
+		switch(rate){
+			case 8000:
+				reg = 2822;			/* FDTSELn_CIM SCKDIV */
+				reg2 = 684783;		/* MNFSRp_2SRC0_m MINFS */
+				reg3 = 0x00b9c27;	/* IFSVRp_2SRC0_m  INTIFS */
+				break;
+			case 11025:
+				reg = 2047;			/* FDTSELn_CIM SCKDIV */
+				reg2 = 943718;		/* MNFSRp_2SRC0_m MINFS */
+				reg3 = 0x0100000;	/* IFSVRp_2SRC0_m  INTIFS */
+				break;
+			case 12000:
+				reg = 1880;			/* FDTSELn_CIM SCKDIV */
+				reg2 = 1027176;		/* MNFSRp_2SRC0_m MINFS */
+				reg3 = 0x0116a3b;	/* IFSVRp_2SRC0_m  INTIFS */
+				break;
+			case 16000:
+				reg = 1411;			/* FDTSELn_CIM SCKDIV */
+				reg2 = 1369568;		/* MNFSRp_2SRC0_m MINFS */
+				reg3 = 0x017384e;	/* IFSVRp_2SRC0_m  INTIFS */
+				break;
+			case 22050:
+				reg = 1024;			/* FDTSELn_CIM SCKDIV */
+				reg2 = 1887436;		/* MNFSRp_2SRC0_m MINFS */
+				reg3 = 0x0200000;	/* IFSVRp_2SRC0_m  INTIFS */
+				break;
+			case 24000:
+				reg = 940;			/* FDTSELn_CIM SCKDIV */
+				reg2 = 2054352;		/* MNFSRp_2SRC0_m MINFS */
+				reg3 = 0x022d476;	/* IFSVRp_2SRC0_m  INTIFS */
+				break;
+			case 32000:
+				reg = 706;			/* FDTSELn_CIM SCKDIV */
+				reg2 = 2739137;		/* MNFSRp_2SRC0_m MINFS */
+				reg3 = 0x02e709d;	/* IFSVRp_2SRC0_m  INTIFS */
+				break;
+			default:
+			case 44100:
+				reg = 512;			/* FDTSELn_CIM SCKDIV */
+				reg2 = 3774873;		/* MNFSRp_2SRC0_m MINFS */
+				reg3 = 0x0400000;	/* IFSVRp_2SRC0_m  INTIFS */
+				break;
+			case 48000:
+				reg = 470;			/* FDTSELn_CIM SCKDIV */
+				reg2 = 4108706;		/* MNFSRp_2SRC0_m MINFS */
+				reg3 = 0x045a8ec;	/* IFSVRp_2SRC0_m  INTIFS */
+				break;
+		}
+		reg = (reg << 16);						/* FDTSELn_CIM SCKDIV */
+		reg |= FDTSEL_SCKSEL_AUIDIO_X1;					/* FDTSELn_CIM SCKSEL = 0001b(AUDIO_X1) */
+		writel(reg, &scux_reg->cimreg->fdtsel1_cim);			/* 0xE8209740:SCKDIV=reg SCKSEL = 1 */
+		writel(reg2, &scux_reg->srcreg[0]->mnfsr1);			/* 0xE820904C:MNFSRp_2SRC0_m FSI * 90%	 */
+		writel(IFSCR_VALUE, &scux_reg->srcreg[0]->ifscr1);		/* 0xE8209040:IFSCRp_2SRC0_m  INTIFSEN = 1 */
+		writel(reg3, &scux_reg->srcreg[0]->ifsvr1);			/* 0xE8209044:IFSVRp_2SRC0_m  INTIFS */
+		/* FUTSELn_CIM NO Setting  */		
+		/* FFD Setting */
+		writel(FDAIR_AUDIO_CH_2, &scux_reg->ffdreg[src_ch]->fdair);	/* 0xE8208904:FDAIR_FFD0_n CHNUM = 0010b(2 channel) */
+		writel(DRQSR_REQ_SIZE_256, &scux_reg->ffdreg[src_ch]->drqsr);	/* 0xE8208908:DRQSR_FFD0_n SIZE = 0001b(256 data) */
+		writel(DEVMR_VALUE, &scux_reg->ffdreg[src_ch]->devmr);		/* 0xE8208914:DEVMR_FFD0_n DEVMUF = 1, DEVMOF = 1, DEVMOL = 1, DEVMIUF = 1, DEVMRQ = 0 */
+		
+		/* SRC Setting */
+		writel(SRCBR_BYPASS_OFF, &scux_reg->srcreg[0]->srcbr1);		/* 0xE820903C:SRCBRp_2SRC0_m  BYPASS = 0 */
+		writel((SADIR_OTBL_16BIT | SADIR_AUDIO_CH_2), &scux_reg->srcreg[0]->sadir1);	/* 0xE8209038:SADIRp_2SRC0_m  OTBL = 01000(16 bit), CHNUM = 0010(2 channel) */
+		writel((SRC_CR_BIT16 | SRC_CR_BIT8 | SRC_CR_BIT4), &scux_reg->srcreg[0]->srccr1);	/* 0xE8209048:SRCCRp_2SRC0_m */
+		/* BFSSRp_2SRC0_m NO Setting*/
+		/* WATSRp_2SRC0_m NO Setting */
+		/* SEVMRp_2SRC0_m NO Setting */
+		
+		/* DVU Setting */
+		writel(( VADIR_OTBL_16BIT | VADIR_CHNUM_CH_2 ), &scux_reg->dvureg[1]->vadir);	/* 0xE8209304:VADIR_DVU0_n  OTBL = 01000b(16 bit), CHNUM = 0010b(2 channel) */
+		/* DVU BYPASS setting */
+		if(ainfo->routeinfo.p_route != RP_MEM_SRC1_DVC1_SSI0){
+			writel(DVUBR_BYPASS_ON, &scux_reg->dvureg[1]->dvubr);	/* 0xE8209308:DVUBR_DVU0_n  BYPASS = 1 */
+		}
+		/* MIX BYPASS setting */
+		writel(0x00000001, &scux_reg->mixreg->mdber);			/* 0xE8209608:MIXBR_MIX0_0  BPSYS 01b(Input Data of system B), BYPASS = 1 */
+
+		/* DMA transfer setting */
+		reg = readl(&scux_reg->cimreg->dmacr_cim);
+		reg |= DMACR_DMAMDFFD1_EN;					/* 0xE8209704:DMACR_CIM  DMAMDFFD1 = 1 */
+		writel(reg, &scux_reg->cimreg->dmacr_cim);
+
+		/* FFD Init off */
+		writel(FFDIR_INIT_OFF, &scux_reg->ffdreg[src_ch]->ffdir);	/* 0xE8208900:FFDIR_FFD0_n  INIT = 0 */
+
+		/* FFD BOOT */
+		writel(FFDBR_BOOT_ON, &scux_reg->ffdreg[src_ch]->ffdbr);	/* 0xE8208910:FFDBR_FFD0_n  BOOT = 1 */
+
+		/* SRC,DVU,MIX,IPC,OPC Init off */
+		writel(INIT_OFF, &scux_reg->ffureg[src_ch]->ffuir);		/* 0xE8208D00:FFUIR_FFU0_n  INIT = 0 */
+		writel(INIT_OFF, &scux_reg->srcreg[0]->srcir1);			/* 0xE8209034:SRCIRp_2SRC0_m  INIT = 0 */
+		writel(INIT_OFF, &scux_reg->srcreg[0]->srcirr1);		/* 0xE8209068:SRCIRR_2SRC0_m  INIT = 0 */
+		writel(INIT_OFF, &scux_reg->dvureg[1]->dvuir);			/* 0xE8209300:DVUIR_DVU0_n  INIT = 0 */
+		writel(INIT_OFF, &scux_reg->mixreg->mixir);			/* 0xE8209600:MIXIR_MIX0_0  INIT = 0 */
+		writel(INIT_OFF, &scux_reg->ipcreg[src_ch]->ipcir);		/* 0xE8208100:IPCIR_IPC0_n  INIT = 0 */
+		writel(INIT_OFF, &scux_reg->opcreg[src_ch]->opcir);		/* 0xE8208500:OPCIR_OPC0_n  INIT = 0 */
+
+		/* Send start setting */
+		reg = readl(&scux_reg->cimreg->fdtsel1_cim);
+		reg |= SCUX_FDTSEL_BIT_DIVEN;				
+		writel(reg, &scux_reg->cimreg->fdtsel1_cim);			/* 0xE8209740:FDTSELn_CIM  DIVEN = 1 */
+
+		reg = readl(&scux_reg->ssifreg[0]->ssicr);
+		reg |= SSICR_TEN_EN;
+		writel(reg, &scux_reg->ssifreg[0]->ssicr);
+
+	}else{
+		pr_info("error SRC CH:%d  \n", src_ch);
+	}
+
+	FNC_EXIT
+	return;
+}
+
+static void scu_dvc_deinit(int dvc_ch)
+{
+	FNC_ENTRY
+	
+	/* DVUIR : DVU init on */
+	writel(DVUIR_INIT_ON, &scux_reg->dvureg[1]->dvuir);		/* 0xE8209300:DVUIR_INIT_ON  */
+
+	FNC_EXIT
+	return;
+}
+
+void scu_dvc_control(int dvc_ch)
+{
+	FNC_ENTRY
+
+	/*  DVU_ADINR */
+	/* only stereo now */
+	writel((VADIR_OTBL_16BIT | VADIR_CHNUM_CH_2), (u32 *)&scux_reg->dvureg[dvc_ch]->vadir);		/* DVU0_1 VADIR :0xE8209304  */
+	
+	/*  DVU_DVUCR  DVU mode select */
+	writel((DVUCR_VVMD_USE | DVUCR_VRMD_USE ),(u32 *)&scux_reg->dvureg[dvc_ch]->dvucr);			/* DVU0_1 DVUCR :0xE820930C  */
+	
+	/*  DVU_VRCTR volume ramp action setting */
+	writel( (VRCTR_VREN0_EN | VRCTR_VREN1_EN ), (u32 *)&scux_reg->dvureg[dvc_ch]->vrctr);		/* DVU0_1 VRCTR : 0xE8209314 */
+	
+	/* VRPDR volume ramp time setting */
+	writel( (VRPDR_VRPDUP_PERIOD_1 | VRPDR_VRPDDW_PERIOD_1 ), (u32 *)&scux_reg->dvureg[dvc_ch]->vrpdr);	/* DVU0_1 VRPDR : 0xE8209318 */	/* SCUX_VRPDR_BIT_VRPDUP   */
+	
+	/* volume ramp gain level setting */
+	writel( VRDBR_VRDB_0DB, (u32 *)&scux_reg->dvureg[dvc_ch]->vrdbr);	/* DVU0_1 VRDBR : 0xE820931C */
+
+	/* Digital Volume Function Parameter */
+	writel(getvolume0, (u32 *)&scux_reg->dvureg[dvc_ch]->vol0r);		/* DVU0_1 VOL0R : 0xE8209324 */
+	writel(getvolume1, (u32 *)&scux_reg->dvureg[dvc_ch]->vol1r);		/* DVU0_1 VOL1R : 0xE8209328 */
+
+	/* Zero Cross Mute Function */
+	writel(0, (u32 *)&scux_reg->dvureg[dvc_ch]->zcmcr);			/* DVU0_1 ZCMCR : 0xE8209310 */
+	
+	/* VRWTR volume ramp wait time setting */
+	writel( 0, (u32 *)&scux_reg->dvureg[dvc_ch]->vrwtr);			/* DVU0_1 VRWTR : 0xE8209320 */
+	
+	/* vevmr SCUDVIn request intrrupt enable/disable setting */
+	writel( 0, (u32 *)&scux_reg->dvureg[dvc_ch]->vevmr);			/* DVU0_1 VERVMR : 0xE820934C */
+	
+	/* DVUER */
+	writel(DVUER_DVUEN_EN, (u32 *)&scux_reg->dvureg[dvc_ch]->dvuer);	/* DVU0_1 DVUER : 0xE8209344 */
+
+	FNC_EXIT
+	return;
+}
+
+static void scu_dvc_stop(int dvc_ch)
+{
+	FNC_ENTRY	
+	/* DVU_DVUER */
+	writel(0, (u32 *)&scux_reg->dvureg[dvc_ch]->dvuer);
+	FNC_EXIT
+	return;
+}
+
+/************************************************************************
+
+	DAPM callback function
+
+************************************************************************/
+void scu_init_ssi(int master_ch, int slave_ch, int mode, int ind, int dir)
+{
+	int ch = (mode == SSI_MASTER) ? master_ch : slave_ch;
+
+	scu_ssif_softreset(ch);
+
+	/* SSI init */
+	scu_ssi_control(master_ch, slave_ch, mode);
+
+	/* SSI start */
+	scu_ssi_start(ch, dir);
+}
+EXPORT_SYMBOL(scu_init_ssi);
+
+void scu_deinit_ssi(int ch, int mode, int ind, int dir)
+{
+	/* SSI stop */
+	scu_ssi_stop(ch, dir);
+
+}
+EXPORT_SYMBOL(scu_deinit_ssi);
+
+void scu_init_src(int src_ch, unsigned int rate, unsigned int sync_sw)
+{
+	scu_src_control(src_ch, rate, sync_sw);
+}
+EXPORT_SYMBOL(scu_init_src);
+
+void scu_deinit_src(int src_ch)
+{
+	/* SCUX reset */
+	writel(SWRSR_SWRST_RST, &scux_reg->cimreg->swrsr);	/* 0xE8209700:SWRSR_CIM SWRST = 0 */
+	udelay(10);
+	writel(SWRSR_SWRST_OPE, &scux_reg->cimreg->swrsr);	/* 0xE8209700:SWRSR_CIM SWRST = 1 */
+	udelay(10);
+}
+EXPORT_SYMBOL(scu_deinit_src);
+
+void scu_init_dvc(int dvc_ch)
+{
+	/* SCUX reset */
+	writel(SWRSR_SWRST_RST, &scux_reg->cimreg->swrsr);	/* 0xE8209700:SWRSR_CIM SWRST = 0 */
+	udelay(10);
+	writel(SWRSR_SWRST_OPE, &scux_reg->cimreg->swrsr);	/* 0xE8209700:SWRSR_CIM SWRST = 1 */
+	udelay(10);
+
+	scu_dvc_control(dvc_ch);
+}
+EXPORT_SYMBOL(scu_init_dvc);
+
+void scu_deinit_dvc(int dvc_ch)
+{
+	/* stop dvu */
+	scu_dvc_stop(dvc_ch);
+	scu_dvc_deinit(dvc_ch);
+}
+EXPORT_SYMBOL(scu_deinit_dvc);
+
+/************************************************************************
+
+	dai ops
+
+************************************************************************/
+/* Playback and capture hardware properties are identical */
+static struct snd_pcm_hardware scu_dai_pcm_hw = {
+	.info			= (SNDRV_PCM_INFO_INTERLEAVED	|
+				   SNDRV_PCM_INFO_MMAP		|
+				   SNDRV_PCM_INFO_MMAP_VALID	|
+				   SNDRV_PCM_INFO_PAUSE),
+	.formats		= SNDRV_PCM_FMTBIT_S16_LE,
+	.rates			= SNDRV_PCM_RATE_8000_48000,
+	.rate_min		= 8000,
+	.rate_max		= 48000,
+	.channels_min		= 2,
+	.channels_max		= 2,
+	.buffer_bytes_max	= SCU_BUFFER_BYTES_MAX,
+	.period_bytes_min	= SCU_PERIOD_BYTES_MIN,
+	.period_bytes_max	= SCU_PERIOD_BYTES_MAX,
+	.periods_min		= SCU_PERIODS_MIN,
+	.periods_max		= SCU_PERIODS_MAX,
+};
+
+static int scu_dai_info_rate(struct snd_kcontrol *kctrl,
+			       struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = RATE_MAX;
+
+	return 0;
+}
+
+static int scu_dai_get_rate(struct snd_kcontrol *kctrl,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	struct scu_audio_info *ainfo = snd_kcontrol_chip(kctrl);
+
+	switch (kctrl->private_value) {
+	case CTRL_PLAYBACK:
+		ucontrol->value.integer.value[0] = ainfo->rate[0];
+		break;
+	case CTRL_CAPTURE:
+		ucontrol->value.integer.value[0] = ainfo->rate[1];
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int scu_dai_put_rate(struct snd_kcontrol *kctrl,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	struct scu_audio_info *ainfo = snd_kcontrol_chip(kctrl);
+	int change = 0;
+
+	switch (kctrl->private_value) {
+	case CTRL_PLAYBACK:
+		change |= (ainfo->rate[0] != ucontrol->value.integer.value[0]);
+		if (change)
+			ainfo->rate[0] = ucontrol->value.integer.value[0];
+		break;
+	case CTRL_CAPTURE:
+		change |= (ainfo->rate[1] != ucontrol->value.integer.value[0]);
+		if (change)
+			ainfo->rate[1] = ucontrol->value.integer.value[0];
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return change;
+}
+
+static struct snd_kcontrol_new playback_rate_controls = {
+	.iface		= SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name		= "PCM Playback Sampling Rate",
+	.index		= 0,
+	.info		= scu_dai_info_rate,
+	.get		= scu_dai_get_rate,
+	.put		= scu_dai_put_rate,
+	.private_value	= CTRL_PLAYBACK,
+};
+
+static struct snd_kcontrol_new capture_rate_controls = {
+	.iface		= SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name		= "PCM Capture Sampling Rate",
+	.index		= 0,
+	.info		= scu_dai_info_rate,
+	.get		= scu_dai_get_rate,
+	.put		= scu_dai_put_rate,
+	.private_value	= CTRL_CAPTURE,
+};
+
+static int scu_dai_info_volume(struct snd_kcontrol *kctrl,
+			       struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = VOLUME_MAX_DVC;
+
+	return 0;
+}
+
+static int scu_dai_get_volume(struct snd_kcontrol *kctrl,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	struct scu_audio_info *ainfo = snd_kcontrol_chip(kctrl);
+
+	switch (kctrl->private_value) {
+	case CTRL_PLAYBACK:
+		ucontrol->value.integer.value[0] = ainfo->volume[0][0];
+		ucontrol->value.integer.value[1] = ainfo->volume[0][1];
+		/* save volume */		
+		getvolume0 = ucontrol->value.integer.value[0];
+		getvolume1 = ucontrol->value.integer.value[1];
+		break;
+	case CTRL_CAPTURE:
+		ucontrol->value.integer.value[0] = ainfo->volume[1][0];
+		ucontrol->value.integer.value[1] = ainfo->volume[1][1];
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int scu_dai_put_volume(struct snd_kcontrol *kctrl,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	struct scu_audio_info *ainfo = snd_kcontrol_chip(kctrl);
+	int change = 0;
+
+	if (ucontrol->value.integer.value[0] < 0 ||
+	    ucontrol->value.integer.value[0] > VOLUME_MAX_DVC ||
+	    ucontrol->value.integer.value[1] < 0 ||
+	    ucontrol->value.integer.value[1] > VOLUME_MAX_DVC)
+		return -EINVAL;
+
+	switch (kctrl->private_value) {
+	case CTRL_PLAYBACK:
+		change |= ((ainfo->volume[0][0] !=
+				ucontrol->value.integer.value[0]) ||
+			   (ainfo->volume[0][1] !=
+				ucontrol->value.integer.value[1]));
+		if (change) {
+			ainfo->volume[0][0] = ucontrol->value.integer.value[0];
+			ainfo->volume[0][1] = ucontrol->value.integer.value[1];
+			/* DVU0_1 L:vol0r R:vol1r */
+			writel(ainfo->volume[0][0],&scux_reg->dvureg[1]->vol0r);	/* DVU0_1 VOL0R : 0xE8209324 */
+			writel(ainfo->volume[0][1],&scux_reg->dvureg[1]->vol1r);	/* DVU0_1 VOL1R : 0xE8209328 */
+		}
+		break;
+	case CTRL_CAPTURE:
+		change |= ((ainfo->volume[1][0] !=
+				ucontrol->value.integer.value[0]) ||
+			   (ainfo->volume[1][1] !=
+				ucontrol->value.integer.value[1]));
+		if (change) {
+			ainfo->volume[1][0] = ucontrol->value.integer.value[0];
+			ainfo->volume[1][1] = ucontrol->value.integer.value[1];
+			/* DVU0_0 L:vol1r R:vol0r */
+			writel(ainfo->volume[1][0],
+				(u32 *)&scux_reg->dvureg[0]->vol1r);
+			writel(ainfo->volume[1][1],
+				(u32 *)&scux_reg->dvureg[0]->vol0r);
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return change;
+}
+
+static struct snd_kcontrol_new playback_volume_controls = {
+	.iface		= SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name		= "PCM Playback Volume",
+	.index		= 0,
+	.info		= scu_dai_info_volume,
+	.get		= scu_dai_get_volume,
+	.put		= scu_dai_put_volume,
+	.private_value	= CTRL_PLAYBACK,
+};
+
+static struct snd_kcontrol_new capture_volume_controls = {
+	.iface		= SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name		= "Capture Volume",
+	.index		= 0,
+	.info		= scu_dai_info_volume,
+	.get		= scu_dai_get_volume,
+	.put		= scu_dai_put_volume,
+	.private_value	= CTRL_CAPTURE,
+};
+
+static int scu_dai_info_mute(struct snd_kcontrol *kctrl,
+			       struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+
+	return 0;
+}
+
+static int scu_dai_get_mute(struct snd_kcontrol *kctrl,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	struct scu_audio_info *ainfo = snd_kcontrol_chip(kctrl);
+	
+	ucontrol->value.integer.value[0] = ainfo->mute[0];
+	ucontrol->value.integer.value[1] = ainfo->mute[1];
+
+	return 0;
+}
+
+static int scu_dai_put_mute(struct snd_kcontrol *kctrl,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	struct scu_audio_info *ainfo = snd_kcontrol_chip(kctrl);
+	int change = 0;
+	u32 mute = 0;
+	
+	if (ucontrol->value.integer.value[0] < 0 ||
+	    ucontrol->value.integer.value[0] > 1 ||
+	    ucontrol->value.integer.value[1] < 0 ||
+	    ucontrol->value.integer.value[1] > 1)
+		return -EINVAL;
+
+	change |= ((ainfo->mute[0] != ucontrol->value.integer.value[0]) ||
+		   (ainfo->mute[1] != ucontrol->value.integer.value[1]));
+	if (change) {
+		ainfo->mute[0] = ucontrol->value.integer.value[0];
+		ainfo->mute[1] = ucontrol->value.integer.value[1];
+		mute = (ainfo->mute[1] << 1) + ainfo->mute[0];
+		mute = ~mute & 0x3;
+		writel(mute, (u32 *)&scux_reg->dvureg[1]->zcmcr);
+	}
+
+	return change;
+}
+
+static struct snd_kcontrol_new playback_mute_controls = {
+	.iface		= SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name		= "PCM Playback Switch",
+	.index		= 0,
+	.info		= scu_dai_info_mute,
+	.get		= scu_dai_get_mute,
+	.put		= scu_dai_put_mute,
+};
+
+int scu_dai_add_control(struct snd_card *card)
+{
+	struct device *dev = card->dev;
+	struct snd_kcontrol *kctrl;
+	int i, j, ret;
+	
+	/* initial value */
+	for (i = 0; i < 2; i++) {
+		ainfo->rate[i] = 0;
+		ainfo->mute[i] = 1;
+		for (j = 0; j < 2; j++)
+			ainfo->volume[i][j] = VOLUME_DEFAULT;
+	}
+
+	getvolume0 = VOLUME_DEFAULT;
+	getvolume1 = VOLUME_DEFAULT;
+	kctrl = snd_ctl_new1(&playback_rate_controls, ainfo);
+	ret = snd_ctl_add(card, kctrl);
+	if (ret < 0) {
+		dev_err(dev, "failed to add playback rate err=%d\n", ret);
+		return ret;
+	}
+
+	kctrl = snd_ctl_new1(&capture_rate_controls, ainfo);
+	ret = snd_ctl_add(card, kctrl);
+	if (ret < 0) {
+		dev_err(dev, "failed to add capture rate err=%d\n", ret);
+		return ret;
+	}
+
+	kctrl = snd_ctl_new1(&playback_volume_controls, ainfo);
+	ret = snd_ctl_add(card, kctrl);
+	if (ret < 0) {
+		dev_err(dev, "failed to add playback volume err=%d\n", ret);
+		return ret;
+	}
+
+	kctrl = snd_ctl_new1(&capture_volume_controls, ainfo);
+	ret = snd_ctl_add(card, kctrl);
+	if (ret < 0) {
+		dev_err(dev, "failed to add capture volume err=%d\n", ret);
+		return ret;
+	}
+
+	kctrl = snd_ctl_new1(&playback_mute_controls, ainfo);
+	ret = snd_ctl_add(card, kctrl);
+	if (ret < 0) {
+		dev_err(dev, "failed to add playback mute err=%d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(scu_dai_add_control);
+
+static int scu_dai_startup(struct snd_pcm_substream *substream,
+			   struct snd_soc_dai *dai)
+{
+	int ret = 0;
+
+	FNC_ENTRY
+	snd_soc_set_runtime_hwparams(substream, &scu_dai_pcm_hw);
+
+	FNC_EXIT
+	return ret;
+}
+
+static void scu_dai_shutdown(struct snd_pcm_substream *substream,
+			     struct snd_soc_dai *dai)
+{
+	FNC_ENTRY
+	FNC_EXIT
+	return;
+}
+
+static int scu_dai_prepare(struct snd_pcm_substream *substream,
+			   struct snd_soc_dai *dai)
+{
+	FNC_ENTRY
+	FNC_EXIT
+	return 0;
+}
+
+static int scu_dai_set_fmt(struct snd_soc_dai *dai,
+			   unsigned int fmt)
+{
+	FNC_ENTRY
+	FNC_EXIT
+	return 0;
+}
+
+static int scu_dai_set_sysclk(struct snd_soc_dai *dai, int clk_id,
+			      unsigned int freq, int dir)
+{
+	FNC_ENTRY
+	FNC_EXIT
+	return 0;
+}
+
+static const struct snd_soc_dai_ops scu_dai_ops = {
+	.startup	= scu_dai_startup,
+	.shutdown	= scu_dai_shutdown,
+	.prepare	= scu_dai_prepare,
+	.set_sysclk	= scu_dai_set_sysclk,
+	.set_fmt	= scu_dai_set_fmt,
+};
+
+static struct snd_soc_dai_driver scu_ssi_dai = {
+	.name	= "scu-ssi-dai",
+	.playback = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.formats = SNDRV_PCM_FMTBIT_S16,
+		.rates = SNDRV_PCM_RATE_8000_48000,
+	},
+	.capture = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.formats = SNDRV_PCM_FMTBIT_S16,
+		.rates = SNDRV_PCM_RATE_8000_48000,
+	 },
+	.ops = &scu_dai_ops,
+};
+
+static void scu_alloc_scureg(void __iomem *mem)
+{
+	int i;
+	void __iomem *offset;
+
+	/* SCUX common */
+	scux_reg->scuxreg = mem;
+
+	/* IPC */
+	offset = mem ;
+	for (i = 0; i < 3; i++) {
+		scux_reg->ipcreg[i] = (struct scux_ipc_regs *)offset;
+		offset += 0x100;
+	}
+
+	/* OPC */
+	offset = mem + 0x0400;	
+	for (i = 0; i < 3; i++) {
+		scux_reg->opcreg[i] = (struct scux_opc_regs *)offset;
+		offset += 0x100;
+	}
+	
+	/* FFD */
+	offset = mem + 0x0800;
+	for (i = 0; i < 3; i++) {
+		scux_reg->ffdreg[i] = (struct scux_ffd_regs *)offset;
+		offset += 0x100;
+	}
+
+	/* FFU */
+	offset = mem + 0x0C00;
+	for (i = 0; i < 3; i++) {
+		scux_reg->ffureg[i] = (struct scux_ffu_regs *)offset;
+		offset += 0x100;
+	}
+
+	/* SRC */
+	offset = mem + 0x1000;
+	scux_reg->srcreg[SCUX_2SRC0_0] = (struct scux_src_regs *)offset;
+	offset = mem + 0x1100;
+	scux_reg->srcreg[SCUX_2SRC0_1] = (struct scux_src_regs *)offset;
+
+	/* DVU */
+	offset = mem + 0x1200;
+	for (i = 0; i < 3; i++) {
+		scux_reg->dvureg[i] = (struct scux_dvu_regs *)offset;
+		offset += 0x100;
+	}
+
+	/* MIX */
+	offset = mem + 0x1600;
+	scux_reg->mixreg = (struct scux_mix_regs *)offset;
+
+	/* CIM */
+	offset = mem + 0x1700;
+	scux_reg->cimreg = (struct scux_cim_regs *)offset;
+
+	return;
+}
+
+static void scu_alloc_ssif0reg(void __iomem *mem)
+{
+	int i;
+	void __iomem *offset;
+
+	offset = mem;
+	for (i = 0; i < 5; i++) {
+		scux_reg->ssifreg[i] = (struct ssif_regs *)offset;
+		offset += 0x800;
+		DBG_MSG("ssireg[%2d]=%08x\n", i, (int)scux_reg->ssireg[i]);
+	}
+
+	return;
+}
+
+static int __init scu_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct scu_clock_info *cinfo;
+	struct resource *scu_res;
+	struct resource *scu_region = NULL;
+	struct resource *ssi_res;
+	struct resource *ssi_region = NULL;
+	void __iomem *mem;
+
+	FNC_ENTRY
+	if (pdev->id != 0) {
+		dev_err(&pdev->dev, "current scu support id 0 only now\n");
+		return -ENODEV;
+	}
+	pdata = pdev->dev.platform_data;
+
+	ainfo = kzalloc(sizeof(struct scu_audio_info), GFP_KERNEL);
+	if (!ainfo) {
+		dev_err(&pdev->dev, "no memory\n");
+		return -ENOMEM;
+	}
+	cinfo = &ainfo->clockinfo;
+	scux_reg = &ainfo->reginfo;
+
+	spin_lock_init(&ainfo->scu_lock);
+	sculock = &ainfo->scu_lock;
+
+	/* resource */
+	scu_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!scu_res) {
+		dev_err(&pdev->dev, "No memory (0) resource\n");
+		ret = -ENODEV;
+		goto error_clk_put;
+	}
+	
+	ssi_res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	
+	if (!ssi_res) {
+		dev_err(&pdev->dev, "No memory (2) resource\n");
+		ret = -ENODEV;
+		goto error_clk_put;
+	}
+
+	scu_region = request_mem_region(scu_res->start,
+			resource_size(scu_res), pdev->name);
+	if (!scu_region) {
+		dev_err(&pdev->dev, "SCUX region already claimed\n");
+		ret = -EBUSY;
+		goto error_release;
+	}
+
+	ssi_region = request_mem_region(ssi_res->start,
+			resource_size(ssi_res), pdev->name);
+	if (!ssi_region) {
+		dev_err(&pdev->dev, "SSI region already claimed\n");
+		ret = -EBUSY;
+		goto error_release;
+	}
+
+	/* mapping scux */
+	mem = ioremap_nocache(scu_res->start, resource_size(scu_res));
+	if (!mem) {
+		dev_err(&pdev->dev, "ioremap failed for scu\n");
+		ret = -ENOMEM;
+		goto error_unmap;
+	}
+	scu_alloc_scureg(mem);
+
+	mem = ioremap_nocache(ssi_res->start, resource_size(ssi_res));
+	if (!mem) {
+		dev_err(&pdev->dev, "ioremap failed for ssi\n");
+		ret = -ENOMEM;
+		goto error_unmap;
+	}
+	scu_alloc_ssif0reg(mem);
+
+	ret = snd_soc_register_platform(&pdev->dev, &scu_platform);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "cannot snd soc register\n");
+		goto error_unmap;
+	}
+
+	ret = snd_soc_register_dais(&pdev->dev, &scu_ssi_dai, 1);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "cannot snd soc dais register\n");
+		goto error_unregister;
+	}
+	
+	scu_ssif_init();
+
+	FNC_EXIT
+	return ret;
+
+error_unregister:
+	snd_soc_unregister_platform(&pdev->dev);
+
+error_unmap:
+	if (scux_reg->scuxreg)
+		iounmap(scux_reg->scuxreg);
+
+	if (scux_reg->ssireg)
+		iounmap(scux_reg->ssireg);
+
+error_release:
+	if (scu_region)
+		release_mem_region(scu_res->start, resource_size(scu_res));
+	if (ssi_region)
+		release_mem_region(ssi_res->start, resource_size(ssi_res));
+
+error_clk_put:
+	FNC_EXIT
+	return ret;
+}
+
+static int scu_remove(struct platform_device *pdev)
+{
+	struct resource *res;
+
+	FNC_ENTRY
+	snd_soc_unregister_dai(&pdev->dev);
+	snd_soc_unregister_platform(&pdev->dev);
+
+	iounmap(scux_reg->scuxreg);
+	iounmap(scux_reg->ssireg);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res)
+		release_mem_region(res->start, resource_size(res));
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (res)
+		release_mem_region(res->start, resource_size(res));
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 2);
+	if (res)
+		release_mem_region(res->start, resource_size(res));
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 3);
+	if (res)
+		release_mem_region(res->start, resource_size(res));
+
+	kfree(ainfo);
+
+	FNC_EXIT
+	return 0;
+}
+
+static struct platform_driver scu_driver = {
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= "scux-pcm-audio",
+	},
+	.probe		= scu_probe,
+	.remove		= scu_remove,
+};
+
+module_platform_driver(scu_driver);
+
+MODULE_AUTHOR(" Renesas Solutions Corp.");
+MODULE_DESCRIPTION("ALSA SoC RZA1H SCUX driver");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/sh/scux_pcm.c b/sound/soc/sh/scux_pcm.c
new file mode 100644
index 0000000..06c195a
--- /dev/null
+++ b/sound/soc/sh/scux_pcm.c
@@ -0,0 +1,687 @@
+/*
+ * sound/soc/sh/scux_pcm.c
+ *     This file is ALSA SoC driver for SCUX peripheral.
+ *
+ * Copyright (C) 2013 Renesas Solutions Corp.
+ * Copyright (C) 2013 Renesas Electronics Corporation
+ *
+ * This file is based on the sound/soc/sh/siu_pcm.c
+ *
+ * siu_pcm.c - ALSA driver for Renesas SH7343, SH7722 SIU peripheral.
+ *
+ * Copyright (C) 2009-2010 Guennadi Liakhovetski <g.liakhovetski@gmx.de>
+ * Copyright (C) 2006 Carlos Munoz <carlos@kenati.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmaengine.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/platform_data/dma-rza1.h>
+#include <linux/slab.h>
+#include <linux/workqueue.h>
+#include <sound/control.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/sh_scux.h>
+
+
+#undef DEBUG
+#ifdef DEBUG
+#define FNC_ENTRY	pr_info("entry:%s:%d\n", __func__, __LINE__);
+#define FNC_EXIT	pr_info("exit:%s:%d\n", __func__, __LINE__);
+#define DBG_POINT()	pr_info("check:%s:%d\n", __func__, __LINE__);
+#define DBG_MSG(args...)	pr_info(args)
+#else  /* DEBUG */
+#define FNC_ENTRY
+#define FNC_EXIT
+#define DBG_POINT()
+#define DBG_MSG(args...)
+#endif /* DEBUG */
+
+static u64 dma_mask = DMA_BIT_MASK(32);
+static unsigned int codec_powerup_wait;
+module_param(codec_powerup_wait, uint, 0644);
+
+static struct snd_soc_dai *scu_get_dai(struct snd_pcm_substream *ss)
+{
+	struct snd_soc_pcm_runtime *rtd = ss->private_data;
+
+	return  rtd->cpu_dai;
+}
+
+static void scu_dma_callback(struct snd_pcm_substream *ss)
+{
+	struct scu_pcm_info *pcminfo = ss->runtime->private_data;
+	struct snd_soc_dai *dai = scu_get_dai(ss);
+	struct snd_pcm_runtime *runtime = ss->runtime;
+	int dir = ss->stream == SNDRV_PCM_STREAM_CAPTURE;
+	int buf_pos;
+	u32 dma_size;
+	u32 dma_paddr;
+
+	FNC_ENTRY
+
+	buf_pos = pcminfo->period % runtime->periods;
+	dma_size = frames_to_bytes(runtime, runtime->period_size);
+	dma_paddr = runtime->dma_addr + (buf_pos * dma_size);
+	dma_sync_single_for_cpu(dai->dev, dma_paddr, dma_size, DMA_DIR(dir));
+
+	pcminfo->tran_period++;
+
+	/* Notify alsa: a period is done */
+	snd_pcm_period_elapsed(ss);
+
+	/* stop dma */
+	if (pcminfo->flag_start == 0)
+		return;
+
+	queue_work(pcminfo->workq, &pcminfo->work);
+
+	FNC_EXIT
+}
+
+static int scu_dmae_req_chan(int sid, struct snd_pcm_substream *ss)
+{
+	struct scu_pcm_info *pcminfo = ss->runtime->private_data;
+	struct rza1_dma_slave *param = &pcminfo->de_param[sid];
+	struct dma_slave_config cfg;
+	dma_cap_mask_t mask;
+	int ret = 0;
+
+	dma_cap_zero(mask);
+	dma_cap_set(DMA_SLAVE, mask);
+
+	FNC_ENTRY
+
+	/* set dma slave id */
+	param->rza1dma_slaveid.slave_id = sid;
+
+	/* request dma channel */
+	if (pcminfo->de_chan[sid] == NULL) {
+		pcminfo->de_chan[sid] = dma_request_channel(mask,
+						rza1dma_chan_filter, (void *)sid);
+		if (!pcminfo->de_chan[sid]) {
+			printk(KERN_ERR "DMA channel request error\n");
+			return -EBUSY;
+		}
+
+		cfg.slave_id = sid;
+		ret = dmaengine_slave_config(pcminfo->de_chan[sid], &cfg);
+		if (ret < 0) {
+			dma_release_channel(pcminfo->de_chan[sid]);
+			return ret;
+		}
+	}
+
+	DBG_MSG("chan=0x%08x\n", (int)pcminfo->de_chan[sid]);
+
+	FNC_EXIT
+	return ret;
+}
+
+static void scu_dmae_rel_chan(int sid, struct snd_pcm_substream *ss)
+{
+	struct scu_pcm_info *pcminfo = ss->runtime->private_data;
+
+	FNC_ENTRY
+	
+	/* release dma channel */
+	if (pcminfo->de_chan[sid]) {
+		dma_release_channel(pcminfo->de_chan[sid]);
+		pcminfo->de_chan[sid] = NULL;
+	}
+
+	FNC_EXIT
+	return;
+}
+
+static int scu_dmae_request(struct snd_pcm_substream *ss)
+{
+	struct scu_pcm_info *pcminfo = ss->runtime->private_data;
+	int dir = ss->stream == SNDRV_PCM_STREAM_CAPTURE;
+	int route = 0;
+	int audma_slave_id = 0;
+	int ret = 0;
+
+	FNC_ENTRY
+
+	if (!dir){ /* playback */
+		route = pcminfo->routeinfo->p_route;
+	}else{ /* capture */
+		route = pcminfo->routeinfo->c_route;
+	}
+		
+	audma_slave_id = scu_find_data(route, pcminfo->pdata->audma_slave,
+					pcminfo->pdata->audma_slave_num);
+	if (audma_slave_id != -1) {
+		ret = scu_dmae_req_chan(audma_slave_id, ss);
+		if (ret < 0)
+			return ret;
+	}
+
+	FNC_EXIT
+	return ret;
+}
+
+static int scu_dmae_release(struct snd_pcm_substream *ss)
+{
+	struct scu_pcm_info *pcminfo = ss->runtime->private_data;
+	int dir = ss->stream == SNDRV_PCM_STREAM_CAPTURE;
+	int route = 0;
+	int audma_slave_id = 0;
+	int ret = 0;
+
+	FNC_ENTRY
+
+	if (!dir) /* playback */
+		route = pcminfo->routeinfo->p_route;
+	else /* capture */
+		route = pcminfo->routeinfo->c_route;
+
+	audma_slave_id = scu_find_data(route, pcminfo->pdata->audma_slave,
+					pcminfo->pdata->audma_slave_num);
+	if (audma_slave_id != -1)
+		scu_dmae_rel_chan(audma_slave_id, ss);
+
+	FNC_EXIT
+	return ret;
+}
+
+static int scu_audma_start(int sid, struct snd_pcm_substream *ss)
+{
+	int dir = ss->stream == SNDRV_PCM_STREAM_CAPTURE;
+	int buf_pos;
+	struct snd_pcm_runtime *runtime = ss->runtime;
+	struct scu_pcm_info *pcminfo = runtime->private_data;
+	struct device *dev = ss->pcm->card->dev;
+	struct dma_async_tx_descriptor *desc;
+	dma_cookie_t cookie;
+	u32 dma_size;
+	u32 dma_paddr;
+	struct snd_soc_dai *dai;
+
+	FNC_ENTRY
+
+	dai = scu_get_dai(ss);
+
+	/* buffer control */
+	buf_pos = pcminfo->period % runtime->periods;
+	DBG_MSG("buf_pos=%d\n", buf_pos);
+
+	/* DMA size */
+	dma_size = frames_to_bytes(runtime, runtime->period_size);
+	DBG_MSG("dma_size=%d\n", dma_size);
+
+	/* DMA physical adddress */
+	dma_paddr = runtime->dma_addr + (buf_pos * dma_size);
+	DBG_MSG("dma_paddr=0x%08x\n", dma_paddr);
+
+	dma_sync_single_for_device(dai->dev, dma_paddr, dma_size, DMA_DIR(dir));
+
+	desc = dmaengine_prep_slave_single(pcminfo->de_chan[sid], dma_paddr,
+		dma_size, DMA_DIR(dir), DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
+	if (!desc) {
+		dev_err(dai->dev, "dmaengine_prep_slave_sg_single() fail\n");
+		return -ENOMEM;
+	}
+
+	desc->callback = (dma_async_tx_callback)scu_dma_callback;
+	desc->callback_param = ss;
+
+	cookie = dmaengine_submit(desc);
+	if (cookie < 0) {
+		dev_err(dev, "Failed to submit a dma transfer\n");
+		FNC_EXIT
+		return cookie;
+	}
+
+	dma_async_issue_pending(pcminfo->de_chan[sid]);
+
+	/* Update period */
+	pcminfo->period++;
+
+	FNC_EXIT
+	return 0;
+}
+
+static int scu_audma_stop(int sid, struct snd_pcm_substream *ss)
+{
+	FNC_ENTRY
+
+	FNC_EXIT
+	return 0;
+}
+
+static void scu_pcm_start(struct snd_pcm_substream *ss, int first_flag)
+{
+	struct scu_pcm_info *pcminfo = ss->runtime->private_data;
+	int dir = ss->stream == SNDRV_PCM_STREAM_CAPTURE;
+	int route = 0;
+	int audma_slave_id = 0;
+	int ssi_depend = 0;
+	int ssi_mode = 0;
+	int src_ch = 0;
+	int src_mode = 0;
+	int dvc_ch = 0;
+	struct scu_pcm_callback callback;
+
+	FNC_ENTRY
+
+	if (!dir) { /* playback */
+		route = pcminfo->routeinfo->p_route;
+		callback = pcminfo->routeinfo->pcb;
+	} else { /* capture */
+		route = pcminfo->routeinfo->c_route;
+		callback = pcminfo->routeinfo->ccb;
+	}
+
+	audma_slave_id = scu_find_data(route, pcminfo->pdata->audma_slave,
+					pcminfo->pdata->audma_slave_num);
+	ssi_depend = scu_find_data(route, pcminfo->pdata->ssi_depend,
+					pcminfo->pdata->ssi_depend_num);
+	ssi_mode = scu_find_data(route, pcminfo->pdata->ssi_mode,
+					pcminfo->pdata->ssi_mode_num);
+	src_ch = scu_find_data(route, pcminfo->pdata->src_ch,
+					pcminfo->pdata->src_ch_num);
+	src_mode = scu_find_data(route, pcminfo->pdata->src_mode,
+					pcminfo->pdata->src_mode_num);
+	dvc_ch = scu_find_data(route, pcminfo->pdata->dvc_ch,
+					pcminfo->pdata->dvc_ch_num);
+
+	/* start dma */
+	scu_audma_start(audma_slave_id, ss);
+
+	if (first_flag) {
+		/* Four Descripters are registered first */
+
+		/* start dma */
+		scu_audma_start(audma_slave_id, ss);
+
+		/* start dma */
+		scu_audma_start(audma_slave_id, ss);
+
+		/* start dma */
+		scu_audma_start(audma_slave_id, ss);
+
+		/* start ssi */
+		if (callback.init_ssi)
+			callback.init_ssi(pcminfo->pdata->ssi_master,
+				pcminfo->pdata->ssi_slave,
+				ssi_mode, ssi_depend, dir);
+
+		/* start dvc */
+		if (callback.init_dvc)
+			callback.init_dvc(dvc_ch);
+
+		/* start src */
+		if (callback.init_src)
+			callback.init_src(src_ch, ss->runtime->rate, src_mode);
+	}
+
+	FNC_EXIT
+	return;
+}
+
+static void scu_pcm_stop(struct snd_pcm_substream *ss)
+{
+	struct scu_pcm_info *pcminfo = ss->runtime->private_data;
+	int dir = ss->stream == SNDRV_PCM_STREAM_CAPTURE;
+	int route = 0;
+	int audma_slave_id = 0;
+	int ssi_ch = 0;
+	int ssi_depend = 0;
+	int ssi_mode = 0;
+	int src_ch = 0;
+	int dvc_ch = 0;
+	struct scu_pcm_callback callback;
+
+	FNC_ENTRY
+
+	if (!dir) { /* playback */
+		route = pcminfo->routeinfo->p_route;
+		callback = pcminfo->routeinfo->pcb;
+	} else { /* capture */
+		route = pcminfo->routeinfo->c_route;
+		callback = pcminfo->routeinfo->ccb;
+	}
+
+	audma_slave_id = scu_find_data(route, pcminfo->pdata->audma_slave,
+					pcminfo->pdata->audma_slave_num);
+	ssi_ch = scu_find_data(route, pcminfo->pdata->ssi_ch,
+					pcminfo->pdata->ssi_ch_num);
+	ssi_depend = scu_find_data(route, pcminfo->pdata->ssi_depend,
+					pcminfo->pdata->ssi_depend_num);
+	ssi_mode = scu_find_data(route, pcminfo->pdata->ssi_mode,
+					pcminfo->pdata->ssi_mode_num);
+	src_ch = scu_find_data(route, pcminfo->pdata->src_ch,
+					pcminfo->pdata->src_ch_num);
+	dvc_ch = scu_find_data(route, pcminfo->pdata->dvc_ch,
+					pcminfo->pdata->dvc_ch_num);
+	/* stop src */
+	if (callback.deinit_src)
+		callback.deinit_src(src_ch);
+
+	/* stop dvc */
+	if (callback.deinit_dvc)
+		callback.deinit_dvc(dvc_ch);
+
+	/* stop ssi */
+	if (callback.deinit_ssi)
+		callback.deinit_ssi(ssi_ch, ssi_mode, ssi_depend, dir);
+
+	/* stop dma */
+	scu_audma_stop(audma_slave_id, ss);
+
+	FNC_EXIT
+	return;
+}
+
+static void scu_dma_do_work(struct work_struct *work)
+{
+	struct scu_pcm_info *pcminfo =
+			container_of(work, struct scu_pcm_info, work);
+	struct snd_pcm_substream *ss = pcminfo->ss;
+
+	FNC_ENTRY
+
+	/* start pcm process */
+	scu_pcm_start(ss, pcminfo->flag_first);
+	if (pcminfo->flag_first == 1)
+		pcminfo->flag_first = 0;
+
+	FNC_EXIT
+	return;
+}
+
+static int scu_audio_start(struct snd_pcm_substream *ss)
+{
+	struct scu_pcm_info *pcminfo = ss->runtime->private_data;
+	int ret = 0;
+
+	FNC_ENTRY
+
+	/* dma channel request */
+	ret = scu_dmae_request(ss);
+	if (ret < 0) {
+		pr_info("scu_dmae_request faild\n");
+		FNC_EXIT
+		return ret;
+	}
+
+	/* DMA control */
+	pcminfo->flag_start = 1;
+	/* PCM 1st process */
+	pcminfo->flag_first = 1;
+
+	mdelay(codec_powerup_wait);
+	queue_work(pcminfo->workq, &pcminfo->work);
+
+	FNC_EXIT
+	return ret;
+}
+
+static int scu_audio_stop(struct snd_pcm_substream *ss)
+{
+	int ret = 0;
+	struct scu_pcm_info *pcminfo = ss->runtime->private_data;
+
+	FNC_ENTRY
+
+	/* stop dma */
+	pcminfo->flag_start = 0;
+
+	/* stop pcm process */
+	scu_pcm_stop(ss);
+
+	/* dma channel release */
+	ret = scu_dmae_release(ss);
+
+	FNC_EXIT
+	return ret;
+}
+
+static struct scu_pcm_info *scu_pcm_new_stream(struct snd_pcm_substream *ss)
+{
+	struct scu_pcm_info *pcminfo;
+
+	FNC_ENTRY
+
+	/* allocate scu_pcm_info structure */
+	pcminfo = kzalloc(sizeof(struct scu_pcm_info), GFP_KERNEL);
+	if (!pcminfo)
+		return pcminfo;
+
+	/* initialize rcar_pcm_info structure */
+	pcminfo->period      = 0;
+	pcminfo->tran_period = 0;
+	pcminfo->routeinfo   = scu_get_route_info();
+	pcminfo->ss          = ss;
+	pcminfo->pdata       = scu_get_platform_data();
+
+	/* allocate dma_chan structure */
+	pcminfo->de_chan = kzalloc((sizeof(struct dma_chan) *
+					pcminfo->pdata->dma_slave_maxnum), GFP_KERNEL);
+	if (!pcminfo->de_chan) {
+		kfree(pcminfo);
+		return NULL;
+	}
+
+	/* allocate sh_dmadesc_slave structure */
+	pcminfo->de_param = kzalloc((sizeof(struct rza1_dma_slave) *
+					pcminfo->pdata->dma_slave_maxnum), GFP_KERNEL);
+	if (!pcminfo->de_param) {
+		kfree(pcminfo->de_chan);
+		kfree(pcminfo);
+		return NULL;
+	}
+	spin_lock_init(&pcminfo->pcm_lock);
+	pcminfo->workq = alloc_ordered_workqueue("sh_scu_pcm", 0);
+	INIT_WORK(&pcminfo->work, scu_dma_do_work);
+
+	FNC_EXIT
+	return pcminfo;
+}
+
+static void scu_pcm_free_stream(struct snd_pcm_runtime *runtime)
+{
+	struct scu_pcm_info *pcminfo = runtime->private_data;
+
+	FNC_ENTRY
+
+	/* post process */
+	cancel_work_sync(&pcminfo->work);
+	destroy_workqueue(pcminfo->workq);
+	kfree(pcminfo->de_param);
+	kfree(pcminfo->de_chan);
+	kfree(runtime->private_data);	/* free pcminfo structure */
+
+	FNC_EXIT
+	return;
+}
+
+static int scu_pcm_open(struct snd_pcm_substream *ss)
+{
+	struct scu_pcm_info *pcminfo;
+	int dir = ss->stream == SNDRV_PCM_STREAM_CAPTURE;
+	int ret = 0;
+
+	FNC_ENTRY
+
+	pcminfo = scu_pcm_new_stream(ss);
+	if (pcminfo == NULL){
+		return -ENOMEM;
+	}	
+
+	ret = scu_check_route(dir, pcminfo->routeinfo);
+	if (ret < 0)
+		return ret;
+
+	ss->runtime->private_data = pcminfo;
+	ss->runtime->private_free = scu_pcm_free_stream;
+
+	FNC_EXIT
+	return 0;
+}
+
+static int scu_pcm_close(struct snd_pcm_substream *ss)
+{
+	FNC_ENTRY
+	
+	FNC_EXIT
+	return 0;
+}
+
+static int scu_pcm_hw_params(struct snd_pcm_substream *ss,
+			     struct snd_pcm_hw_params *hw_params)
+{
+	struct device *dev = ss->pcm->card->dev;
+	int ret;
+
+	FNC_ENTRY
+	
+	ret = snd_pcm_lib_malloc_pages(ss, params_buffer_bytes(hw_params));
+	if (ret < 0)
+		dev_err(dev, "snd_pcm_lib_malloc_pages() failed\n");
+
+	FNC_EXIT
+	return ret;
+}
+
+static int scu_pcm_hw_free(struct snd_pcm_substream *ss)
+{
+	struct device *dev = ss->pcm->card->dev;
+	int ret;
+
+	FNC_ENTRY
+	
+	ret = snd_pcm_lib_free_pages(ss);
+	if (ret < 0)
+		dev_err(dev, "snd_pcm_lib_free_pages() failed\n");
+
+	FNC_EXIT
+	return ret;
+}
+
+static int scu_pcm_prepare(struct snd_pcm_substream *ss)
+{
+	FNC_ENTRY
+	
+	FNC_EXIT
+	return 0;
+}
+
+static int scu_pcm_trigger(struct snd_pcm_substream *ss, int cmd)
+{
+	int ret = 0;
+	struct snd_pcm_runtime *runtime = ss->runtime;
+	struct scu_pcm_info *pcminfo = runtime->private_data;
+
+	spin_lock(&pcminfo->pcm_lock);
+
+	FNC_ENTRY
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		ret = scu_audio_start(ss);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		ret = scu_audio_stop(ss);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	spin_unlock(&pcminfo->pcm_lock);
+
+	FNC_EXIT
+	return ret;
+}
+
+static snd_pcm_uframes_t scu_pcm_pointer_dma(struct snd_pcm_substream *ss)
+{
+	struct snd_pcm_runtime *runtime = ss->runtime;
+	struct scu_pcm_info *pcminfo = runtime->private_data;
+	snd_pcm_uframes_t position = 0;
+
+	position = runtime->period_size *
+			(pcminfo->tran_period % runtime->periods);
+
+	DBG_MSG("\tposition = %d\n", (u32)position);
+
+	return position;
+}
+
+static int scu_pcm_new(struct snd_soc_pcm_runtime *rtd)
+{
+	int ret = 0;
+	struct snd_card *card = rtd->card->snd_card;
+
+	FNC_ENTRY
+
+	ret = scu_dai_add_control(card);
+
+	if (ret){
+		return ret;
+	}
+
+	if (!card->dev->dma_mask)
+		card->dev->dma_mask = &dma_mask;
+
+	if (!card->dev->coherent_dma_mask)
+		card->dev->coherent_dma_mask = DMA_BIT_MASK(32);
+	ret = snd_pcm_lib_preallocate_pages_for_all(
+		rtd->pcm,
+		SNDRV_DMA_TYPE_DEV,
+		rtd->card->snd_card->dev,
+		SCU_BUFFER_BYTES_MAX, SCU_BUFFER_BYTES_MAX);
+
+	FNC_EXIT
+	return ret;
+}
+
+static void scu_pcm_free(struct snd_pcm *pcm)
+{
+	FNC_ENTRY
+
+	/* free dma buffer */
+	snd_pcm_lib_preallocate_free_for_all(pcm);
+
+	FNC_EXIT
+}
+
+static struct snd_pcm_ops scu_pcm_ops = {
+	.open		= scu_pcm_open,
+	.close		= scu_pcm_close,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= scu_pcm_hw_params,
+	.hw_free	= scu_pcm_hw_free,
+	.prepare	= scu_pcm_prepare,
+	.trigger	= scu_pcm_trigger,
+	.pointer	= scu_pcm_pointer_dma,
+};
+
+struct snd_soc_platform_driver scu_platform = {
+	.ops		= &scu_pcm_ops,
+	.pcm_new	= scu_pcm_new,
+	.pcm_free	= scu_pcm_free,
+};
+EXPORT_SYMBOL_GPL(scu_platform);
-- 
1.8.4.1

