From 7438922faaf1c35d6dd82bcf2326b2b1652253a2 Mon Sep 17 00:00:00 2001
From: Carlo Caione <carlo.caione@gmail.com>
Date: Mon, 27 Jan 2014 10:34:32 +0100
Subject: [PATCH 2/2] Add hachiko support

Signed-off-by: Carlo Caione <carlo.caione@gmail.com>
---
 arch/arm/boot/dts/Makefile                 |   3 +-
 arch/arm/boot/dts/rza1-hachiko.dts         |  27 +
 arch/arm/configs/hachiko64_defconfig       | 107 ++++
 arch/arm/configs/hachiko_defconfig         | 123 ++++
 arch/arm/mach-shmobile/Kconfig             |   7 +
 arch/arm/mach-shmobile/Makefile            |   1 +
 arch/arm/mach-shmobile/board-hachiko.c     | 355 ++++++++++++
 arch/arm/mach-shmobile/clock-rza1.c        |   4 +-
 arch/arm/mach-shmobile/include/mach/rza1.h |   3 +
 arch/arm/mach-shmobile/pfc-rza1.c          |  18 +-
 arch/arm/mach-shmobile/rskrza1-vdc5fb.c    | 167 +++++-
 arch/arm/mach-shmobile/setup-rza1.c        |  49 ++
 drivers/net/can/Kconfig                    |   6 +
 drivers/net/can/Makefile                   |   1 +
 drivers/net/can/rza1_can.c                 | 867 +++++++++++++++++++++++++++++
 drivers/video/renesas/vdc5fb-regs.h        |  44 ++
 drivers/video/renesas/vdc5fb.c             | 122 +++-
 include/linux/can/platform/rza1_can.h      |  15 +
 include/video/vdc5fb.h                     |  51 +-
 19 files changed, 1956 insertions(+), 14 deletions(-)
 create mode 100644 arch/arm/boot/dts/rza1-hachiko.dts
 create mode 100644 arch/arm/configs/hachiko64_defconfig
 create mode 100644 arch/arm/configs/hachiko_defconfig
 create mode 100644 arch/arm/mach-shmobile/board-hachiko.c
 create mode 100644 drivers/net/can/rza1_can.c
 create mode 100644 include/linux/can/platform/rza1_can.h

diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile
index 6bdf03d..c1f44c2 100644
--- a/arch/arm/boot/dts/Makefile
+++ b/arch/arm/boot/dts/Makefile
@@ -124,7 +124,8 @@ dtb-$(CONFIG_ARCH_SHMOBILE) += emev2-kzm9d.dtb \
 	r8a7740-armadillo800eva.dtb \
 	sh73a0-kzm9g.dtb \
 	rza1-rskrza1.dtb \
-	sh7372-mackerel.dtb
+	sh7372-mackerel.dtb \
+	rza1-hachiko.dtb
 dtb-$(CONFIG_ARCH_SPEAR13XX) += spear1310-evb.dtb \
 	spear1340-evb.dtb
 dtb-$(CONFIG_ARCH_SPEAR3XX)+= spear300-evb.dtb \
diff --git a/arch/arm/boot/dts/rza1-hachiko.dts b/arch/arm/boot/dts/rza1-hachiko.dts
new file mode 100644
index 0000000..e09b0b5
--- /dev/null
+++ b/arch/arm/boot/dts/rza1-hachiko.dts
@@ -0,0 +1,27 @@
+/*
+ * Device Tree Source for the HACHIKO board
+ *
+ * Copyright (C) 2014 Carlo Caione <carlo@caione.org>
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+/include/ "skeleton.dtsi"
+
+/ {
+	model = "HACHIKO";
+	compatible = "renesas,hachiko";
+
+	memory {
+		device_type = "memory";
+		reg = <0x08000000 0x08000000>;
+	};
+};
diff --git a/arch/arm/configs/hachiko64_defconfig b/arch/arm/configs/hachiko64_defconfig
new file mode 100644
index 0000000..dffc95b
--- /dev/null
+++ b/arch/arm/configs/hachiko64_defconfig
@@ -0,0 +1,107 @@
+CONFIG_EXPERIMENTAL=y
+CONFIG_SYSVIPC=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=16
+CONFIG_NAMESPACES=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_EMBEDDED=y
+CONFIG_PERF_EVENTS=y
+CONFIG_SLAB=y
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_ARCH_SHMOBILE=y
+CONFIG_ARCH_RZA1=y
+CONFIG_MACH_HACHIKO=y
+CONFIG_MEMORY_START=0x0c000000
+CONFIG_ARM_ERRATA_743622=y
+CONFIG_ARM_ERRATA_754322=y
+CONFIG_PREEMPT=y
+CONFIG_AEABI=y
+CONFIG_HIGHMEM=y
+# CONFIG_ATAGS is not set
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_KEXEC=y
+CONFIG_VFP=y
+CONFIG_NEON=y
+CONFIG_PM_RUNTIME=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_CAN=y
+CONFIG_CAN_RAW=y
+CONFIG_CAN_RZA1=y
+CONFIG_IRDA=y
+CONFIG_SH_IRDA=y
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_MTD=y
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_CFI=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_PHYSMAP=y
+CONFIG_MTD_M25P80=y
+CONFIG_SCSI=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_NETDEVICES=y
+CONFIG_SH_ETH=y
+CONFIG_MDIO_GPIO=y
+CONFIG_INPUT_SPARSEKMAP=y
+CONFIG_INPUT_EVDEV=y
+CONFIG_KEYBOARD_GPIO=y
+CONFIG_SERIAL_SH_SCI=y
+CONFIG_SERIAL_SH_SCI_NR_UARTS=8
+CONFIG_SERIAL_SH_SCI_CONSOLE=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_RIIC=y
+CONFIG_SPI=y
+CONFIG_SPI_RSPI=y
+CONFIG_SPI_SH_SPIBSC=y
+CONFIG_SPI_SPIDEV=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_FB=y
+CONFIG_FB_VDC5=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_LOGO=y
+CONFIG_USB=y
+CONFIG_USB_R8A66597_HCD=y
+CONFIG_USB_STORAGE=y
+CONFIG_MMC=y
+CONFIG_MMC_SDHI=y
+CONFIG_MMC_SH_MMCIF=y
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_SH=y
+CONFIG_DMADEVICES=y
+CONFIG_SH_DMAE=y
+CONFIG_RZA1_DMAE=y
+CONFIG_STAGING=y
+CONFIG_IIO=y
+CONFIG_IIO_BUFFER_CB=y
+CONFIG_SH_ADC=y
+CONFIG_EXT2_FS=y
+CONFIG_EXT3_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_TMPFS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+CONFIG_NFS_V4_1=y
+CONFIG_ROOT_NFS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_CRYPTO_CBC=y
+CONFIG_CRYPTO_MD5=y
+CONFIG_CRYPTO_DES=y
+CONFIG_CRC16=y
diff --git a/arch/arm/configs/hachiko_defconfig b/arch/arm/configs/hachiko_defconfig
new file mode 100644
index 0000000..5cd5b08
--- /dev/null
+++ b/arch/arm/configs/hachiko_defconfig
@@ -0,0 +1,123 @@
+CONFIG_EXPERIMENTAL=y
+CONFIG_SYSVIPC=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=16
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+# CONFIG_UID16 is not set
+# CONFIG_KALLSYMS is not set
+# CONFIG_BUG is not set
+# CONFIG_BASE_FULL is not set
+# CONFIG_SHMEM is not set
+# CONFIG_AIO is not set
+CONFIG_EMBEDDED=y
+# CONFIG_VM_EVENT_COUNTERS is not set
+# CONFIG_COMPAT_BRK is not set
+CONFIG_SLOB=y
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_LBDAF is not set
+CONFIG_ARCH_SHMOBILE=y
+CONFIG_ARCH_RZA1=y
+CONFIG_MACH_HACHIKO=y
+CONFIG_MEMORY_START=0x20000000
+CONFIG_MEMORY_SIZE=0x00a00000
+CONFIG_ARM_ERRATA_743622=y
+CONFIG_ARM_ERRATA_754322=y
+CONFIG_PREEMPT=y
+CONFIG_THUMB2_KERNEL=y
+CONFIG_HIGHMEM=y
+# CONFIG_ATAGS is not set
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_KEXEC=y
+CONFIG_VFP=y
+CONFIG_NEON=y
+# CONFIG_COREDUMP is not set
+# CONFIG_SUSPEND is not set
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_IPV6 is not set
+CONFIG_CAN=y
+CONFIG_CAN_RAW=y
+CONFIG_CAN_BCM=y
+CONFIG_CAN_RZA1=y
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_MTD=y
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_CFI=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_PHYSMAP=y
+CONFIG_MTD_M25P80=y
+CONFIG_SCSI=y
+CONFIG_BLK_DEV_SD=y
+# CONFIG_SCSI_LOWLEVEL is not set
+CONFIG_NETDEVICES=y
+# CONFIG_NET_CADENCE is not set
+# CONFIG_NET_VENDOR_BROADCOM is not set
+# CONFIG_NET_VENDOR_CIRRUS is not set
+# CONFIG_NET_VENDOR_FARADAY is not set
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MICROCHIP is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+CONFIG_SH_ETH=y
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_SMSC is not set
+# CONFIG_NET_VENDOR_STMICRO is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+CONFIG_MDIO_GPIO=y
+# CONFIG_WLAN is not set
+CONFIG_INPUT_SPARSEKMAP=y
+CONFIG_INPUT_EVDEV=y
+CONFIG_KEYBOARD_GPIO=y
+CONFIG_SERIAL_SH_SCI=y
+CONFIG_SERIAL_SH_SCI_NR_UARTS=8
+CONFIG_SERIAL_SH_SCI_CONSOLE=y
+# CONFIG_HW_RANDOM is not set
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_RIIC=y
+CONFIG_SPI=y
+CONFIG_SPI_RSPI=y
+CONFIG_SPI_SH_SPIBSC=y
+CONFIG_SPI_SPIDEV=y
+CONFIG_GPIO_SYSFS=y
+# CONFIG_HWMON is not set
+CONFIG_FB=y
+CONFIG_FB_VDC5=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_USB=y
+CONFIG_USB_R8A66597_HCD=y
+CONFIG_USB_STORAGE=y
+CONFIG_MMC=y
+CONFIG_MMC_SDHI=y
+CONFIG_MMC_SH_MMCIF=y
+CONFIG_DMADEVICES=y
+CONFIG_SH_DMAE=y
+CONFIG_RZA1_DMAE=y
+CONFIG_EXT2_FS=y
+# CONFIG_FUSE_FS is not set
+CONFIG_VFAT_FS=y
+# CONFIG_NETWORK_FILESYSTEMS is not set
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_DEBUG_PREEMPT is not set
+# CONFIG_FTRACE is not set
+CONFIG_CRYPTO_CBC=y
+CONFIG_CRYPTO_MD5=y
+CONFIG_CRYPTO_DES=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
diff --git a/arch/arm/mach-shmobile/Kconfig b/arch/arm/mach-shmobile/Kconfig
index 963792d..cfdb16f 100644
--- a/arch/arm/mach-shmobile/Kconfig
+++ b/arch/arm/mach-shmobile/Kconfig
@@ -132,6 +132,13 @@ config MACH_RSKRZA1
 	select REGULATOR_FIXED_VOLTAGE if REGULATOR
 	select USE_OF
 
+config MACH_HACHIKO
+	bool "HACHIKO board"
+	depends on ARCH_RZA1
+	select ARCH_REQUIRE_GPIOLIB
+	select REGULATOR_FIXED_VOLTAGE if REGULATOR
+	select USE_OF
+
 comment "SH-Mobile System Configuration"
 
 config CPU_HAS_INTEVT
diff --git a/arch/arm/mach-shmobile/Makefile b/arch/arm/mach-shmobile/Makefile
index 786fb7f..d7d0f8c 100644
--- a/arch/arm/mach-shmobile/Makefile
+++ b/arch/arm/mach-shmobile/Makefile
@@ -50,6 +50,7 @@ obj-$(CONFIG_MACH_ARMADILLO800EVA)	+= board-armadillo800eva.o
 obj-$(CONFIG_MACH_KZM9D)	+= board-kzm9d.o
 obj-$(CONFIG_MACH_KZM9G)	+= board-kzm9g.o
 obj-$(CONFIG_MACH_RSKRZA1)	+= board-rskrza1.o
+obj-$(CONFIG_MACH_HACHIKO)	+= board-hachiko.o
 
 # Framework support
 obj-$(CONFIG_SMP)		+= $(smp-y)
diff --git a/arch/arm/mach-shmobile/board-hachiko.c b/arch/arm/mach-shmobile/board-hachiko.c
new file mode 100644
index 0000000..ac48964
--- /dev/null
+++ b/arch/arm/mach-shmobile/board-hachiko.c
@@ -0,0 +1,355 @@
+/*
+ * hachiko board support
+ *
+ * Copyright (C) 2014  Carlo Caione
+ *
+ * Based on: board-rskrza1.c
+ *
+ * Copyright (C) 2013  Renesas Solutions Corp.
+ * Copyright (C) 2010  Magnus Damm
+ * Copyright (C) 2008  Yoshihiro Shimoda
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include <asm/hardware/gic.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <linux/export.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/physmap.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/fixed.h>
+#include <linux/regulator/machine.h>
+#include <linux/spi/smanalog.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/sh_mmcif.h>
+#include <linux/mmc/sh_mobile_sdhi.h>
+#include <linux/mfd/tmio.h>
+#include <linux/platform_data/dma-rza1.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <mach/common.h>
+#include <mach/rza1.h>
+#include <linux/i2c.h>
+#include <linux/sh_intc.h>
+#include <../sound/soc/codecs/wm8978.h>
+#include <video/vdc5fb.h>
+
+/* MTD */
+static struct mtd_partition nor_flash_partitions[] = {
+	{
+		.name		= "loader",
+		.offset		= 0x00000000,
+		.size		= 256 * 1024 * 2,
+	},
+	{
+		.name		= "bootenv",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= 128 * 1024 * 2,
+		.mask_flags	= MTD_WRITEABLE,
+	},
+	{
+		.name		= "kernel",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= 4 * 1024 * 1024,
+	},
+	{
+		.name		= "data",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= MTDPART_SIZ_FULL,
+	},
+};
+
+static struct physmap_flash_data nor_flash_data = {
+	.width		= 2,
+	.parts		= nor_flash_partitions,
+	.nr_parts	= ARRAY_SIZE(nor_flash_partitions),
+};
+
+static struct resource nor_flash_resources[] = {
+	[0]	= {
+		.start	= 0x00000000,
+		.end	= 0x08000000 - 1,
+		.flags	= IORESOURCE_MEM,
+	}
+};
+
+static struct platform_device nor_flash_device = {
+	.name		= "physmap-flash",
+	.dev		= {
+		.platform_data	= &nor_flash_data,
+	},
+	.num_resources	= ARRAY_SIZE(nor_flash_resources),
+	.resource	= nor_flash_resources,
+};
+
+/* MMCIF */
+static struct resource sh_mmcif_resources[] = {
+	[0] = {
+		.name	= "MMCIF",
+		.start	= 0xe804c800,
+		.end	= 0xe804c8ff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= 300,
+		.flags	= IORESOURCE_IRQ,
+	},
+	[2] = {
+		.start	= 301,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct sh_mmcif_plat_data sh_mmcif_platdata = {
+	.ocr		= MMC_VDD_32_33,
+	.caps		= MMC_CAP_4_BIT_DATA |
+			  MMC_CAP_8_BIT_DATA |
+				MMC_CAP_NONREMOVABLE,
+};
+
+static struct platform_device mmc_device = {
+	.name		= "sh_mmcif",
+	.id		= -1,
+	.dev		= {
+		.dma_mask		= NULL,
+		.coherent_dma_mask	= 0xffffffff,
+		.platform_data		= &sh_mmcif_platdata,
+	},
+	.num_resources	= ARRAY_SIZE(sh_mmcif_resources),
+	.resource	= sh_mmcif_resources,
+};
+
+/* SDHI0 */
+static struct sh_mobile_sdhi_info sdhi0_info = {
+	.dma_slave_tx	= RZA1DMA_SLAVE_SDHI0_TX,
+	.dma_slave_rx	= RZA1DMA_SLAVE_SDHI0_RX,
+	.tmio_caps	= MMC_CAP_SD_HIGHSPEED | MMC_CAP_SDIO_IRQ,
+	.tmio_ocr_mask	= MMC_VDD_32_33,
+	.tmio_flags	= TMIO_MMC_HAS_IDLE_WAIT,
+};
+
+static struct resource sdhi0_resources[] = {
+	[0] = {
+		.name	= "SDHI0",
+		.start	= 0xe804e000,
+		.end	= 0xe804e0ff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.name   = SH_MOBILE_SDHI_IRQ_CARD_DETECT,
+		.start	= 302,
+		.flags	= IORESOURCE_IRQ,
+	},
+	[2] = {
+		.name   = SH_MOBILE_SDHI_IRQ_SDCARD,
+		.start	= 303,
+		.flags	= IORESOURCE_IRQ,
+	},
+	[3] = {
+		.name   = SH_MOBILE_SDHI_IRQ_SDIO,
+		.start	= 304,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device sdhi0_device = {
+	.name		= "sh_mobile_sdhi",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(sdhi0_resources),
+	.resource	= sdhi0_resources,
+	.dev	= {
+		.platform_data	= &sdhi0_info,
+	},
+};
+
+#include "rskrza1-vdc5fb.c"
+
+static struct platform_device *rskrza1_devices[] __initdata = {
+	&nor_flash_device,
+	&mmc_device,
+	&sdhi0_device,
+};
+
+static struct mtd_partition spibsc0_flash_partitions[] = {
+	{
+		.name		= "spibsc0_loader",
+		.offset		= 0x00000000,
+		.size		= 0x00080000,
+		/* .mask_flags	= MTD_WRITEABLE, */
+	},
+	{
+		.name		= "spibsc0_bootenv",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= 0x00040000,
+	},
+	{
+		.name		= "spibsc0_kernel",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= 0x00400000,
+	},
+	{
+		.name		= "spibsc0_rootfs",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= MTDPART_SIZ_FULL,
+	},
+};
+
+
+
+static struct flash_platform_data spi_flash_data0 = {
+	.name	= "m25p80",
+	.parts	= spibsc0_flash_partitions,
+	.nr_parts = ARRAY_SIZE(spibsc0_flash_partitions),
+	.type = "s25fl512s",
+};
+
+
+static struct spi_board_info rskrza1_spi_devices[] __initdata = {
+	{
+		/* spidev */
+		.modalias		= "spidev",
+		.chip_select		= 0,
+		.max_speed_hz		= 5000000,
+		.bus_num		= 1,
+		.mode			= SPI_MODE_3,
+		.clk_delay		= 2,
+		.cs_negate_delay	= 2,
+		.next_access_delay	= 2,
+	},
+	{
+		/* SPI Flash */
+		.modalias = "m25p80",
+		/* .max_speed_hz = 25000000, */
+		.bus_num = 5,
+		.chip_select = 0,
+		.platform_data = &spi_flash_data0,
+	},
+};
+
+static void __init rskrza1_init_spi(void)
+{
+	/* register SPI device information */
+	spi_register_board_info(rskrza1_spi_devices,
+		ARRAY_SIZE(rskrza1_spi_devices));
+}
+
+void __init rskrza1_init(void)
+{
+	if (disable_sdhi)
+		sdhi0_device.name = "mobile_sdhi(hidden)";
+
+	platform_add_devices(rskrza1_devices, ARRAY_SIZE(rskrza1_devices));
+
+	rza1_pinmux_setup();
+
+	rza1_devices_setup();
+
+	/* ADC */
+	rza1_pfc_pin_assign(P1_8, ALT1, DIR_PIPC);	/* AN0 */
+	rza1_pfc_pin_assign(P1_9, ALT1, DIR_PIPC);	/* AN1 */
+	rza1_pfc_pin_assign(P1_10, ALT1, DIR_PIPC);	/* AN2 */
+	rza1_pfc_pin_assign(P1_11, ALT1, DIR_PIPC);	/* AN3 */
+
+#if defined(CONFIG_MMC)
+	/* set SDHI0 pfc configuration */
+	rza1_pfc_pin_assign(P4_8, ALT3, DIR_PIPC);	/* SD_CD_0 */
+	rza1_pfc_pin_assign(P4_9, ALT3, DIR_PIPC);	/* SD_WP_0 */
+	rza1_pfc_pin_bidirection(P4_10, true);		/* SD_D1_0 */
+	rza1_pfc_pin_assign(P4_10, ALT3, DIR_PIPC);	/* SD_D1_0 */
+	rza1_pfc_pin_bidirection(P4_11, true);		/* SD_D0_0 */
+	rza1_pfc_pin_assign(P4_11, ALT3, DIR_PIPC);	/* SD_D0_0 */
+	rza1_pfc_pin_assign(P4_12, ALT3, DIR_PIPC);	/* SD_CLK_0 */
+	rza1_pfc_pin_bidirection(P4_13, true);		/* SD_CMD_0 */
+	rza1_pfc_pin_assign(P4_13, ALT3, DIR_PIPC);	/* SD_CMD_0 */
+	rza1_pfc_pin_bidirection(P4_14, true);		/* SD_D3_0 */
+	rza1_pfc_pin_assign(P4_14, ALT3, DIR_PIPC);	/* SD_D3_0 */
+	rza1_pfc_pin_bidirection(P4_15, true);		/* SD_D2_0 */
+	rza1_pfc_pin_assign(P4_15, ALT3, DIR_PIPC);	/* SD_D2_0 */
+#else
+	/* GPIO */
+	rza1_pfc_pin_assign(P4_10, PMODE, DIR_OUT);	/* LED1 */
+	rza1_pfc_pin_assign(P4_11, PMODE, DIR_OUT);	/* LED2 */
+#endif
+
+#if defined(CONFIG_SPI_MASTER)
+	rskrza1_init_spi();
+#endif
+
+#if defined(CONFIG_FB_VDC5)
+	vdc5fb_setup();
+#endif
+}
+
+int rskrza1_board_can_pfc_assign(int channel)
+{
+	if (channel == 1) {
+		rza1_pfc_pin_assign(P1_4, ALT3, DIR_PIPC);
+		rza1_pfc_pin_assign(P5_10, ALT5, DIR_PIPC);
+	}
+
+	if (channel == 2) {
+		rza1_pfc_pin_assign(P7_3, ALT5, DIR_PIPC);
+		rza1_pfc_pin_assign(P7_2, ALT5, DIR_PIPC);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(rskrza1_board_can_pfc_assign);
+
+int rskrza1_board_i2c_pfc_assign(int id)
+{
+	/* set I2C pfc configuration */
+	switch (id) {
+	case 0:
+		rza1_pfc_pin_bidirection(P1_0, true);		/* I2C SCL0 */
+		rza1_pfc_pin_assign(P1_0, ALT1, DIR_PIPC);	/* I2C SCL0 */
+		rza1_pfc_pin_bidirection(P1_1, true);		/* I2C SDA0 */
+		rza1_pfc_pin_assign(P1_1, ALT1, DIR_PIPC);	/* I2C SDA0 */
+		break;
+	case 1:
+		rza1_pfc_pin_bidirection(P1_2, true);		/* I2C SCL1 */
+		rza1_pfc_pin_assign(P1_2, ALT1, DIR_PIPC);	/* I2C SCL1 */
+		rza1_pfc_pin_bidirection(P1_3, true);		/* I2C SDA1 */
+		rza1_pfc_pin_assign(P1_3, ALT1, DIR_PIPC);	/* I2C SDA1 */
+		break;
+	case 3:
+		rza1_pfc_pin_bidirection(P1_6, true);		/* I2C SCL3 */
+		rza1_pfc_pin_assign(P1_6, ALT1, DIR_PIPC);	/* I2C SCL3 */
+		rza1_pfc_pin_bidirection(P1_7, true);		/* I2C SDA3 */
+		rza1_pfc_pin_assign(P1_7, ALT1, DIR_PIPC);	/* I2C SDA3 */
+		break;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(rskrza1_board_i2c_pfc_assign);
+
+static const char *rskrza1_boards_compat_dt[] __initdata = {
+	"renesas,hachiko",
+	NULL,
+};
+
+DT_MACHINE_START(RSKRZA1_DT, "hachiko")
+	.nr_irqs	= NR_IRQS_LEGACY,
+	.map_io		= rza1_map_io,
+	.init_early	= rza1_add_early_devices,
+	.init_irq	= rza1_init_irq,
+	.handle_irq	= gic_handle_irq,
+	.init_machine	= rskrza1_init,
+	.init_late	= shmobile_init_late,
+	.timer		= &shmobile_timer,
+	.dt_compat	= rskrza1_boards_compat_dt,
+MACHINE_END
diff --git a/arch/arm/mach-shmobile/clock-rza1.c b/arch/arm/mach-shmobile/clock-rza1.c
index 39508f1..c49aea8 100644
--- a/arch/arm/mach-shmobile/clock-rza1.c
+++ b/arch/arm/mach-shmobile/clock-rza1.c
@@ -148,7 +148,7 @@ struct clk div4_clks[DIV4_NR] = {
 enum { MSTP51, MSTP50,
 	MSTP71, MSTP70,
 	MSTP47, MSTP46, MSTP45, MSTP44, MSTP43, MSTP42, MSTP41, MSTP40,
-	MSTP33, MSTP67, MSTP60,
+	MSTP32, MSTP33, MSTP67, MSTP60,
 	MSTP84,
 	MSTP92, MSTP93,
 #if defined(CONFIG_FB_VDC5)
@@ -179,6 +179,7 @@ static struct clk mstp_clks[MSTP_NR] = {
 	[MSTP42] = SH_CLK_MSTP8(&peripheral1_clk, STBCR4, 2, 0),   /* SCIF5 */
 	[MSTP41] = SH_CLK_MSTP8(&peripheral1_clk, STBCR4, 1, 0),   /* SCIF6 */
 	[MSTP40] = SH_CLK_MSTP8(&peripheral1_clk, STBCR4, 0, 0),   /* SCIF7 */
+	[MSTP32] = SH_CLK_MSTP8(&peripheral1_clk, STBCR3, 2, 0),   /* CAN */
 	[MSTP33] = SH_CLK_MSTP8(&peripheral0_clk, STBCR3, 3, 0),   /* MTU2 */
 	[MSTP67] = SH_CLK_MSTP8(&peripheral1_clk, STBCR6, 7, 0),   /* ADC */
 	[MSTP60] = SH_CLK_MSTP8(&r_clk, STBCR6, 0, 0),		   /* RTC */
@@ -243,6 +244,7 @@ static struct clk_lookup lookups[] = {
 	CLKDEV_CON_ID("rspi2", &mstp_clks[MSTP105]),
 	CLKDEV_CON_ID("rspi3", &mstp_clks[MSTP104]),
 	CLKDEV_CON_ID("rspi4", &mstp_clks[MSTP103]),
+	CLKDEV_CON_ID("can",  &mstp_clks[MSTP32]),
 	CLKDEV_CON_ID("scux", &mstp_clks[MSTP81]),	/* SCUX */
 	CLKDEV_CON_ID("ssif0", &mstp_clks[MSTP115]),	/* SSIF0 */
 #if defined(CONFIG_FB_VDC5)
diff --git a/arch/arm/mach-shmobile/include/mach/rza1.h b/arch/arm/mach-shmobile/include/mach/rza1.h
index 4887ddf..014cac5 100644
--- a/arch/arm/mach-shmobile/include/mach/rza1.h
+++ b/arch/arm/mach-shmobile/include/mach/rza1.h
@@ -51,6 +51,7 @@ enum pfc_direction {
 	DIR_OUT = 0,
 	DIR_IN,
 	DIR_PIPC,
+	DIR_LVDS,
 };
 
 extern int disable_ether;
@@ -63,7 +64,9 @@ extern void rza1_map_io(void);
 extern int rza1_pinmux_setup(void);
 extern int rza1_pfc_pin_assign(enum pfc_pin_number pinnum, enum pfc_mode mode,
 			       enum pfc_direction dir);
+extern void rza1_pfc_pin_lvds(void);
 extern int rza1_pfc_pin_bidirection(enum pfc_pin_number pinnum, bool bidirection);
 int rskrza1_board_i2c_pfc_assign(int id);
+int rskrza1_board_can_pfc_assign(int channel);
 
 #endif /* __ASM_RZA1_H__ */
diff --git a/arch/arm/mach-shmobile/pfc-rza1.c b/arch/arm/mach-shmobile/pfc-rza1.c
index d5c5495..2cb3904 100644
--- a/arch/arm/mach-shmobile/pfc-rza1.c
+++ b/arch/arm/mach-shmobile/pfc-rza1.c
@@ -17,6 +17,7 @@
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/mutex.h>
+#include <linux/delay.h>
 #include <mach/rza1.h>
 
 #define GPIO_CHIP_NAME "RZA1_INTERNAL_PFC"
@@ -102,6 +103,9 @@ static int set_direction(unsigned int port, int bit, enum pfc_direction dir)
 	if (dir == DIR_IN) {
 		bit_modify(PM(port), bit, true);
 		bit_modify(PIBC(port), bit, true);
+	} else if (dir == DIR_LVDS) {
+		bit_modify(PM(port), bit, true);
+		bit_modify(PIBC(port), bit, false);
 	} else {
 		bit_modify(PM(port), bit, false);
 		bit_modify(PIBC(port), bit, false);
@@ -272,11 +276,17 @@ int rza1_pfc_pin_assign(enum pfc_pin_number pinnum, enum pfc_mode mode,
 	int port, bit = (int)pinnum;
 
 	port = get_port_bitshift(&bit);
-	if (dir == DIR_PIPC)
-		ip_controlled_driver(port, bit, true);
-	else {
+
+	if (dir == DIR_LVDS) {
 		ip_controlled_driver(port, bit, false);
 		set_direction(port, bit, dir);
+	} else {
+		if (dir == DIR_PIPC)
+			ip_controlled_driver(port, bit, true);
+		else {
+			ip_controlled_driver(port, bit, false);
+			set_direction(port, bit, dir);
+		}
 	}
 
 	return set_mode(port, bit, mode);
@@ -294,7 +304,7 @@ int rza1_pfc_pin_bidirection(enum pfc_pin_number pinnum, bool bidirection)
 	port = get_port_bitshift(&bit);
 	set_bidirection(port, bit, bidirection);
 
-	return 0; 
+	return 0;
 }
 EXPORT_SYMBOL(rza1_pfc_pin_bidirection);
 
diff --git a/arch/arm/mach-shmobile/rskrza1-vdc5fb.c b/arch/arm/mach-shmobile/rskrza1-vdc5fb.c
index 3f00f4d..d771591 100644
--- a/arch/arm/mach-shmobile/rskrza1-vdc5fb.c
+++ b/arch/arm/mach-shmobile/rskrza1-vdc5fb.c
@@ -73,10 +73,86 @@ static struct resource vdc5fb_resources_ch1[VDC5FB_NUM_RES] = {
 		.end	= (VDC5FB_IRQ_BASE(1) + VDC5FB_IRQ_SIZE - 1),
 		.flags	= IORESOURCE_IRQ,
 	},
+	[3] = {
+		.name	= "lvds: reg",
+		.start	= VDC5FB_REG_LVDS,
+		.end	= (VDC5FB_REG_LVDS + VDC5FB_REG_LVDS_SIZE - 1),
+		.flags	= IORESOURCE_MEM,
+	},
 };
 #endif
 
 /*************************************************************************/
+/* LVDS */
+
+static struct fb_videomode videomode_lvds = {
+	.name		= "LVDS",
+	.refresh	= 60,
+	.xres		= 800,
+	.yres		= 480,
+	.pixclock	= 31250,
+	.left_margin	= 86,
+	.right_margin	= 42,
+	.upper_margin	= 32,
+	.lower_margin	= 10,
+	.hsync_len	= 128,
+	.vsync_len	= 2,
+	.sync		= 0,
+	.vmode		= 0,
+	.flag		= 0,
+};
+
+static int vdc5fb_pinmux_lvds(struct platform_device *pdev);
+
+static struct vdc5fb_pdata vdc5fb_pdata_lvds = {
+	.name			= "LVDS",
+	.videomode		= &videomode_lvds,
+	.panel_ocksel		= OCKSEL_PLL_DIV7,
+	.panel_icksel		= 0,
+	.bpp			= 32,
+	.panel_width		= 0,
+	.panel_height		= 0,
+	.flm_max		= 1,
+	.out_format		= OUT_FORMAT_RGB888,
+	.use_lvds		= 1,
+	.lvds			= {
+		.lvds_in_clk_sel	= VDC5_LVDS_INCLK_SEL_PERI,
+		.lvds_idiv_set		= VDC5_LVDS_NDIV_4,
+		.lvds_pll_tst		= (uint16_t)8u,
+		.lvds_odiv_set		= VDC5_LVDS_NDIV_4,
+		.lvds_pll_fd		= (uint16_t)56u,
+		.lvds_pll_rd		= (uint16_t)(1u-1u),
+		.lvds_pll_od		= VDC5_LVDS_PLL_NOD_4,
+	},
+	.tcon_sel		= {
+		[LCD_TCON0]	= TCON_SEL_UNUSED,
+		[LCD_TCON1]	= TCON_SEL_UNUSED,
+		[LCD_TCON2]	= TCON_SEL_UNUSED,
+		[LCD_TCON3]	= TCON_SEL_DE,
+		[LCD_TCON4]	= TCON_SEL_UNUSED,
+		[LCD_TCON5]	= TCON_SEL_UNUSED,
+		[LCD_TCON6]	= TCON_SEL_UNUSED,
+	},
+	.pinmux			= vdc5fb_pinmux_lvds,
+	.reset			= NULL,
+};
+
+
+static int vdc5fb_pinmux_lvds(struct platform_device *pdev)
+{
+	rza1_pfc_pin_assign(P5_0, ALT1, DIR_LVDS);
+	rza1_pfc_pin_assign(P5_1, ALT1, DIR_LVDS);
+	rza1_pfc_pin_assign(P5_2, ALT1, DIR_LVDS);
+	rza1_pfc_pin_assign(P5_3, ALT1, DIR_LVDS);
+	rza1_pfc_pin_assign(P5_4, ALT1, DIR_LVDS);
+	rza1_pfc_pin_assign(P5_5, ALT1, DIR_LVDS);
+	rza1_pfc_pin_assign(P5_6, ALT1, DIR_LVDS);
+	rza1_pfc_pin_assign(P5_7, ALT1, DIR_LVDS);
+
+	return 0;
+}
+
+/*************************************************************************/
 /* LCD MONITOR */
 
 #define	P1CLK			((13330000 * 30) / 6)
@@ -305,6 +381,82 @@ static int vdc5fb_pinmux_vga(struct platform_device *pdev)
 }
 
 /*************************************************************************/
+/* LCD */
+
+static struct fb_videomode videomode_wqvga_lcd_kit = {
+	.name		= "WQVGA",
+	.refresh	= 60,
+	.xres		= 480,
+	.yres		= 272,
+	.pixclock	= PIXCLOCK(P1CLK, 7),
+	.left_margin	= 43,
+	.right_margin	= 8,
+	.upper_margin	= 3,
+	.lower_margin	= 3,
+	.hsync_len	= 41,
+	.vsync_len	= 10,
+	.sync		= (FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT),
+	.vmode		= 0,
+	.flag		= 0,
+};
+
+static int vdc5fb_pinmux_lcd_kit(struct platform_device *pdev);
+
+static struct vdc5fb_pdata vdc5fb_pdata_ch0_lcd_kit = {
+	.name			= "LCD",
+	.videomode		= &videomode_wqvga_lcd_kit,
+	.panel_icksel		= ICKSEL_P1CLK,
+	.bpp			= 16,
+	.panel_width		= 184,	/* mm, unused */
+	.panel_height		= 132,	/* mm, unused */
+	.flm_max		= 1,
+	.out_format		= OUT_FORMAT_RGB565,
+	.use_lvds		= 0,
+	.tcon_sel		= {
+		[LCD_TCON0]	= TCON_SEL_DE,		/* DE */
+		[LCD_TCON1]	= TCON_SEL_UNUSED,	/* NC */
+		[LCD_TCON2]	= TCON_SEL_UNUSED,	/* NC */
+		[LCD_TCON3]	= TCON_SEL_UNUSED,	/* NC */
+		[LCD_TCON4]	= TCON_SEL_UNUSED,	/* NC */
+		[LCD_TCON5]	= TCON_SEL_UNUSED,	/* NC */
+		[LCD_TCON6]	= TCON_SEL_UNUSED,	/* NC */
+	},
+	.pinmux			= vdc5fb_pinmux_lcd_kit,
+	.reset			= NULL,
+};
+
+static int vdc5fb_pinmux_lcd_kit(struct platform_device *pdev)
+{
+	struct vdc5fb_pdata *pdata = (struct vdc5fb_pdata *)pdev->dev.platform_data;
+
+	if (pdev->id == 0) {
+		rza1_pfc_pin_assign(P3_8, ALT1, DIR_PIPC);
+		rza1_pfc_pin_assign(P3_9, ALT1, DIR_PIPC);
+		rza1_pfc_pin_assign(P3_10, ALT1, DIR_PIPC);
+		rza1_pfc_pin_assign(P3_11, ALT1, DIR_PIPC);
+		rza1_pfc_pin_assign(P3_12, ALT1, DIR_PIPC);
+		rza1_pfc_pin_assign(P3_13, ALT1, DIR_PIPC);
+		rza1_pfc_pin_assign(P3_14, ALT1, DIR_PIPC);
+		rza1_pfc_pin_assign(P3_15, ALT1, DIR_PIPC);
+		rza1_pfc_pin_assign(P4_0, ALT1, DIR_PIPC);
+		rza1_pfc_pin_assign(P4_1, ALT1, DIR_PIPC);
+		rza1_pfc_pin_assign(P4_2, ALT1, DIR_PIPC);
+		rza1_pfc_pin_assign(P4_3, ALT1, DIR_PIPC);
+		rza1_pfc_pin_assign(P4_4, ALT1, DIR_PIPC);
+		rza1_pfc_pin_assign(P4_5, ALT1, DIR_PIPC);
+		rza1_pfc_pin_assign(P4_6, ALT1, DIR_PIPC);
+		rza1_pfc_pin_assign(P4_7, ALT1, DIR_PIPC);
+
+		rza1_pfc_pin_assign(P3_0, ALT1, DIR_PIPC);
+
+		if (pdata->tcon_sel[LCD_TCON0] != TCON_SEL_UNUSED)
+			rza1_pfc_pin_assign(P3_1, ALT1, DIR_PIPC);
+	}
+
+	return 0;
+}
+
+/*************************************************************************/
 /* LCD-KIT-B01 */
 
 static struct fb_videomode videomode_wvga_lcd_kit_b01 = {
@@ -349,6 +501,7 @@ static struct vdc5fb_pdata vdc5fb_pdata_ch0_lcd_kit_b01 = {
 	.pinmux			= vdc5fb_pinmux_lcd_kit_b01,
 	.reset			= vdc5fb_reset_lcd_kit_b01,
 };
+
 static struct vdc5fb_pdata vdc5fb_pdata_ch1_lcd_kit_b01 = {
 	.name			= "LCD-KIT-B01",
 	.videomode		= &videomode_wvga_lcd_kit_b01,
@@ -543,8 +696,8 @@ static struct platform_device vdc5fb_devices[VDC5FB_NUM_CH] = {
 
 int disable_ether /* = 0 */;
 static int disable_sdhi /* = 0 */;
-static unsigned int vdc5fb0_opts = 1;
-static unsigned int vdc5fb1_opts /* = 0 */;
+static unsigned int vdc5fb0_opts;
+static unsigned int vdc5fb1_opts;
 
 int __init early_vdc5fb0(char *str)
 {
@@ -556,7 +709,7 @@ early_param("vdc5fb0", early_vdc5fb0);
 int __init early_vdc5fb1(char *str)
 {
 	get_option(&str, &vdc5fb1_opts);
-	if (vdc5fb1_opts != 0) {
+	if (vdc5fb1_opts != 0 && vdc5fb1_opts != 4) {
 		disable_ether = 1;
 		disable_sdhi = 1;
 	}
@@ -600,8 +753,9 @@ static int vdc5fb_setup(void)
 				pdev->dev.platform_data =
 					&vdc5fb_pdata_ch0_vga;
 				break;
-			case 3:	/* Add channel 1 first */
-				break;
+			case 3:
+				pdev->dev.platform_data =
+					&vdc5fb_pdata_ch0_lcd_kit;
 			default:
 				break;
 			}
@@ -627,6 +781,9 @@ static int vdc5fb_setup(void)
 				pdev->dev.platform_data =
 					&vdc5fb_pdata_ch1_vga;
 				break;
+			case 4:
+				pdev->dev.platform_data =
+					&vdc5fb_pdata_lvds;
 			default:
 				break;
 			}
diff --git a/arch/arm/mach-shmobile/setup-rza1.c b/arch/arm/mach-shmobile/setup-rza1.c
index 5b5c96d..57e3bdb 100644
--- a/arch/arm/mach-shmobile/setup-rza1.c
+++ b/arch/arm/mach-shmobile/setup-rza1.c
@@ -35,6 +35,7 @@
 #include <linux/usb/r8a66597.h>
 #include <linux/spi/sh_spibsc.h>
 #include <linux/platform_data/dma-rza1.h>
+#include <linux/can/platform/rza1_can.h>
 #include <mach/common.h>
 #include <mach/hardware.h>
 #include <mach/irqs.h>
@@ -447,6 +448,7 @@ static struct platform_device i2c_device1 = {
 	.resource	= i2c_resources1,
 };
 
+#if !defined(CONFIG_MACH_HACHIKO)
 static struct resource i2c_resources2[] = {
 	[0] = {
 		.start	= 0xfcfee800,
@@ -482,6 +484,7 @@ static struct platform_device i2c_device2 = {
 	.num_resources	= ARRAY_SIZE(i2c_resources2),
 	.resource	= i2c_resources2,
 };
+#endif
 
 static struct resource i2c_resources3[] = {
 	[0] = {
@@ -631,6 +634,49 @@ static struct resource spi4_resources[] = {
 	},
 };
 
+static struct resource rz_can_resources[] = {
+	[0] = {
+		.start	= 0xe803a000,
+		.end	= 0xe803b813,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= 258,
+		.end	= 258,
+		.flags	= IORESOURCE_IRQ,
+	},
+	[2] = {
+		.start	= 260,
+		.end	= 260,
+		.flags	= IORESOURCE_IRQ,
+	},
+	[3] = {
+		.start	= 259,
+		.end	= 259,
+		.flags	= IORESOURCE_IRQ,
+	},
+	[4] = {
+		.start	= 253,
+		.end	= 253,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct rz_can_platform_data rz_can_data = {
+	.channel	= 1,
+	.clock_select	= CLKR_CLKC,
+};
+
+static struct platform_device rz_can_device = {
+	.name		= "rz_can",
+	.num_resources	= ARRAY_SIZE(rz_can_resources),
+	.resource	= rz_can_resources,
+	.dev	= {
+		.platform_data	= &rz_can_data,
+
+	},
+};
+
 static struct platform_device spi4_device = {
 	.name	= "rspi",
 	.id	= 4,
@@ -955,7 +1001,9 @@ static struct platform_device scux_device = {
 static struct platform_device *rza1_devices[] __initdata = {
 	&i2c_device0,
 	&i2c_device1,
+#if !defined(CONFIG_MACH_HACHIKO)
 	&i2c_device2,
+#endif
 	&i2c_device3,
 	&r8a66597_usb_host0_device,
 	&r8a66597_usb_host1_device,
@@ -968,6 +1016,7 @@ static struct platform_device *rza1_devices[] __initdata = {
 	&adc0_device,
 	&spibsc0_device,
 	&spibsc1_device,
+	&rz_can_device,
 };
 
 static struct platform_device *rza1_early_devices[] __initdata = {
diff --git a/drivers/net/can/Kconfig b/drivers/net/can/Kconfig
index b56bd9e..248e006 100644
--- a/drivers/net/can/Kconfig
+++ b/drivers/net/can/Kconfig
@@ -83,6 +83,12 @@ config CAN_BFIN
 	  To compile this driver as a module, choose M here: the
 	  module will be called bfin_can.
 
+config CAN_RZA1
+	depends on CAN_DEV
+	tristate "RZ/A1 onchip RS-CAN controller"
+	---help---
+	  Driver for RZ/A1 onchip RS-CAN controller
+
 config CAN_JANZ_ICAN3
 	tristate "Janz VMOD-ICAN3 Intelligent CAN controller"
 	depends on CAN_DEV && MFD_JANZ_CMODIO
diff --git a/drivers/net/can/Makefile b/drivers/net/can/Makefile
index 7de5986..58c57bc 100644
--- a/drivers/net/can/Makefile
+++ b/drivers/net/can/Makefile
@@ -23,5 +23,6 @@ obj-$(CONFIG_CAN_JANZ_ICAN3)	+= janz-ican3.o
 obj-$(CONFIG_CAN_FLEXCAN)	+= flexcan.o
 obj-$(CONFIG_PCH_CAN)		+= pch_can.o
 obj-$(CONFIG_CAN_GRCAN)		+= grcan.o
+obj-$(CONFIG_CAN_RZA1)		+= rza1_can.o
 
 ccflags-$(CONFIG_CAN_DEBUG_DEVICES) := -DDEBUG
diff --git a/drivers/net/can/rza1_can.c b/drivers/net/can/rza1_can.c
new file mode 100644
index 0000000..2f9fd91
--- /dev/null
+++ b/drivers/net/can/rza1_can.c
@@ -0,0 +1,867 @@
+/*
+ * rza1_can.c - CAN network driver for RZ/A1 SoC CAN controller
+ *
+ * (C) 2014 by Carlo Caione <carlo@caione.org>
+ *
+ * This software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2 as distributed in the 'COPYING'
+ * file from the main directory of the linux kernel source.
+ *
+ */
+
+#include <linux/bitops.h>
+#include <linux/clk.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <linux/platform_device.h>
+#include <linux/can/error.h>
+#include <linux/can/dev.h>
+#include <linux/can/platform/rza1_can.h>
+#include <mach/rza1.h>
+
+enum {
+	CFM_RX_MODE = 0,
+	CFM_TX_MODE,
+	CFM_GW_MODE
+};
+
+enum {
+	OP_MODE = 0,
+	RST_MODE,
+	TEST_MODE
+};
+
+#define DRV_NAME			"rz_can"
+#define RZ_CAN_TX_ECHO_SKB_MAX		128
+#define RZ_CAN_INC_BUF_ID(x)		(((x) + 1) % RZ_CAN_TX_ECHO_SKB_MAX)
+
+#define RZ_CAN_CFCD_FULL		0x07
+#define RZ_CAN_CFTML			0
+
+#define RZ_CAN_RX_FIFO			0
+#define RZ_CAN_TX_FIFO			1
+
+#define RZ_CAN_FIFO_K(m,n)		(((m) * 3) + (n))
+
+#define RZ_CAN_GAFLID_FIFO_M(x)		BIT(x)
+#define RZ_CAN_GAFLID_TXRX_FIFO_M(x)	BIT(((x) + 8))
+
+#define RZ_CAN_RSCAN0GCFG		0x0084
+#define RZ_CAN_RSCAN0GCFG_DCS(x)	((x) << 4)
+
+#define RZ_CAN_RSCAN0GSTS		0x008c
+#define RZ_CAN_RSCAN0GSTS_GRAMINIT	BIT(3)
+
+#define RZ_CAN_RSCAN0CmCFG(m)		(0x0000 + (m * 0x0010))
+#define RZ_CAN_RSCAN0CmCFG_SJW(x)	(((x) & 0x03) << 24)
+#define RZ_CAN_RSCAN0CmCFG_TSEG2(x)	(((x) & 0x07) << 20)
+#define RZ_CAN_RSCAN0CmCFG_TSEG1(x)	(((x) & 0x0f) << 16)
+#define RZ_CAN_RSCAN0CmCFG_BRP(x)	(((x) & 0x1ff) << 0)
+
+#define RZ_CAN_RSCAN0GCTR		0x0088
+#define RZ_CAN_RSCAN0GCTR_GSLPR		BIT(2)
+#define RZ_CAN_RSCAN0GCTR_MEIE		BIT(9)
+
+#define RZ_CAN_RSCAN0GCTR_GMDC_M	0x00000003
+#define RZ_CAN_RSCAN0GCTR_GMDC(x)	(((x) & 0x03) << 0)
+
+#define RZ_CAN_RSCAN0CmCTR(m)		(0x0004 + ((m) * 0x0010))
+#define RZ_CAN_RSCAN0CmCTR_CSLPR	BIT(2)
+#define RZ_CAN_RSCAN0CmCTR_BEIE		BIT(8)
+#define RZ_CAN_RSCAN0CmCTR_EWIE		BIT(9)
+#define RZ_CAN_RSCAN0CmCTR_EPIE		BIT(10)
+#define RZ_CAN_RSCAN0CmCTR_BOEIE	BIT(11)
+#define RZ_CAN_RSCAN0CmCTR_OLIE		BIT(13)
+
+#define RZ_CAN_RSCAN0CmCTR_CHMDC_M	0x00000003
+#define RZ_CAN_RSCAN0CmCTR_CHMDC(x)	(((x) & 0x03) << 0)
+
+#define RZ_CAN_RSCAN0GAFLCFG0		0x009c
+#define RZ_CAN_RSCAN0GAFLCFG0_RNC(m,x)	(((x) & 0xff) << (8 * (3 - (m))))
+
+#define RZ_CAN_RSCAN0GAFLECTR		0x0098
+#define RZ_CAN_RSCAN0GAFLECTR_AFLDAE	BIT(8)
+#define RZ_CAN_RSCAN0GAFLECTR_AFLPN(x)	(((x) & 0x1f) << 0)
+
+#define RZ_CAN_RSCAN0GAFLIDj(j)		(0x0500 + ((j) * 0x0010))
+#define RZ_CAN_RSCAN0GAFLMj(j)		(0x0504 + ((j) * 0x0010))
+#define RZ_CAN_RSCAN0GAFLP0j(j)		(0x0508 + ((j) * 0x0010))
+#define RZ_CAN_RSCAN0GAFLP1j(j)		(0x050c + ((j) * 0x0010))
+
+#define RZ_CAN_RSCAN0CFCCk(k)		(0x0118 + ((k) * 0x0004))
+#define RZ_CAN_RSCAN0CFCCk_CFE		BIT(0)
+#define RZ_CAN_RSCAN0CFCCk_CFRXIE	BIT(1)
+#define RZ_CAN_RSCAN0CFCCk_CFTXIE	BIT(2)
+#define RZ_CAN_RSCAN0CFCCk_CFIM		BIT(12)
+#define RZ_CAN_RSCAN0CFCCk_CFITSS	BIT(18)
+#define RZ_CAN_RSCAN0CFCCk_CFITR	BIT(19)
+#define RZ_CAN_RSCAN0CFCCk_CFDC(x)	(((x) & 0x07) << 8)
+#define RZ_CAN_RSCAN0CFCCk_CFIGCV(x)	(((x) & 0x07) << 13)
+#define RZ_CAN_RSCAN0CFCCk_CFM(x)	(((x) & 0x03) << 16)
+#define RZ_CAN_RSCAN0CFCCk_CFTML(x)	(((x) & 0x0f) << 20)
+#define RZ_CAN_RSCAN0CFCCk_CFITT(x)	(((x) & 0xff) << 24)
+
+#define RZ_CAN_RSCAN0CmSTS(m)		(0x0008 + ((m) * 0x0010))
+#define RZ_CAN_RSCAN0CmSTS_TEC(x)	(((x) & 0xff000000) >> 24)
+#define RZ_CAN_RSCAN0CmSTS_REC(x)	(((x) & 0x00ff0000) >> 16)
+
+#define RZ_CAN_RSCAN0CmERFL(m)		(0x000c + ((m) * 0x0010))
+#define RZ_CAN_RSCAN0CmERFL_BEF		BIT(0)
+#define RZ_CAN_RSCAN0CmERFL_EWF		BIT(1)
+#define RZ_CAN_RSCAN0CmERFL_EPF		BIT(2)
+#define RZ_CAN_RSCAN0CmERFL_BOEF	BIT(3)
+#define RZ_CAN_RSCAN0CmERFL_OVLF	BIT(5)
+#define RZ_CAN_RSCAN0CmERFL_SERR	BIT(8)
+#define RZ_CAN_RSCAN0CmERFL_FERR	BIT(9)
+#define RZ_CAN_RSCAN0CmERFL_AERR	BIT(10)
+#define RZ_CAN_RSCAN0CmERFL_CERR	BIT(11)
+#define RZ_CAN_RSCAN0CmERFL_B1ERR	BIT(12)
+#define RZ_CAN_RSCAN0CmERFL_B0ERR	BIT(13)
+#define RZ_CAN_RSCAN0CmERFL_ADERR	BIT(14)
+
+#define RZ_CAN_RSCAN0CFSTSk(k)		(0x0178 + ((k) * 0x0004))
+#define RZ_CAN_RSCAN0CFSTSk_CFEMP	BIT(0)
+#define RZ_CAN_RSCAN0CFSTSk_CFFLL	BIT(1)
+#define RZ_CAN_RSCAN0CFSTSk_CFMLT	BIT(2)
+#define RZ_CAN_RSCAN0CFSTSk_CFRXIF	BIT(3)
+#define RZ_CAN_RSCAN0CFSTSk_CFTXIF	BIT(4)
+
+#define RZ_CAN_RSCAN0CFIDk(k)		(0x0e80 + ((k) * 0x0010))
+#define RZ_CAN_RSCAN0CFIDk_CFID_M	0x1fffffff
+#define RZ_CAN_RSCAN0CFIDk_CFRTR	BIT(30)
+#define RZ_CAN_RSCAN0CFIDk_CFIDE	BIT(31)
+
+#define RZ_CAN_RSCAN0CFPTRk(k)		(0x0e84 + ((k) * 0x0010))
+#define RZ_CAN_RSCAN0CFPTRk_CFDLC(x)	(((x) & 0x0f) << 28)
+#define RZ_CAN_RSCAN0CFPTRk_CFDLC_G(x)	(((x) & 0xf0000000) >> 28)
+
+#define RZ_CAN_RSCAN0CFDFbk(k,b)	((0x0e88 + ((b) * 0x04)) + ((k) * 0x0010))
+#define RZ_CAN_RSCAN0CFDFbk_CFDB(x,s)	(((x) & 0xff) << ((s) * 8))
+
+#define RZ_CAN_RSCAN0CFPCTRk(k)		(0x01d8 + ((k) * 0x0004))
+
+struct rz_can_priv {
+	struct can_priv can;	/* must be the first member */
+	struct net_device *ndev;
+	struct clk *clk;
+	spinlock_t skb_lock;
+	void __iomem *base;
+	unsigned int bytes_queued;
+	int frames_queued;
+	int clock_select;
+	int m;
+	int k_rx;
+	int k_tx;
+	int rx_irq;
+	int tx_irq;
+	int err_irq_m;
+	int err_irq_g;
+};
+
+static const struct can_bittiming_const rz_can_bittiming_const = {
+	.name = DRV_NAME,
+	.tseg1_min = 4,
+	.tseg1_max = 16,
+	.tseg2_min = 2,
+	.tseg2_max = 8,
+	.sjw_max = 4,
+	.brp_min = 4,
+	.brp_max = 1024,
+	.brp_inc = 1,
+};
+
+static void rz_can_write(struct rz_can_priv *priv, unsigned long reg_offs,
+			 u32 data)
+{
+	iowrite32(data, priv->base + reg_offs);
+}
+
+static u32 rz_can_read(struct rz_can_priv *priv, unsigned long reg_offs)
+{
+	return ioread32(priv->base + reg_offs);
+}
+
+static int rz_can_set_bittiming(struct net_device *ndev)
+{
+	struct rz_can_priv *priv = netdev_priv(ndev);
+	struct can_bittiming *bt = &priv->can.bittiming;
+	u32 cfg, dcs;
+
+	dcs = RZ_CAN_RSCAN0GCFG_DCS(priv->clock_select);
+	rz_can_write(priv, RZ_CAN_RSCAN0GCFG, dcs);
+
+	cfg = RZ_CAN_RSCAN0CmCFG_SJW(bt->sjw - 1);
+	cfg |= RZ_CAN_RSCAN0CmCFG_BRP(bt->brp - 1);
+	cfg |= RZ_CAN_RSCAN0CmCFG_TSEG1(bt->phase_seg1 + bt->prop_seg - 1);
+	cfg |= RZ_CAN_RSCAN0CmCFG_TSEG2(bt->phase_seg2 - 1);
+	rz_can_write(priv, RZ_CAN_RSCAN0CmCFG(priv->m), cfg);
+
+	return 0;
+}
+
+static int rz_can_get_berr_counter(const struct net_device *ndev,
+				   struct can_berr_counter *bec)
+{
+	struct rz_can_priv *priv = netdev_priv(ndev);
+	u32 reg;
+
+	reg = rz_can_read(priv, RZ_CAN_RSCAN0CmSTS(priv->m));
+	bec->txerr = RZ_CAN_RSCAN0CmSTS_TEC(reg);
+	bec->rxerr = RZ_CAN_RSCAN0CmSTS_REC(reg);
+
+	return 0;
+}
+
+static int rz_can_start_xmit(struct sk_buff *skb, struct net_device *ndev)
+{
+	struct rz_can_priv *priv = netdev_priv(ndev);
+	struct can_frame *cf = (struct can_frame *)skb->data;
+	unsigned long flags;
+	u8 dlc = cf->can_dlc;
+	canid_t id = cf->can_id;
+	u8 *data = cf->data;
+	u32 reg;
+	int b, s;
+
+	reg = rz_can_read(priv, RZ_CAN_RSCAN0CFCCk(priv->k_tx));
+	reg |= RZ_CAN_RSCAN0CFCCk_CFE;
+	rz_can_write(priv, RZ_CAN_RSCAN0CFCCk(priv->k_tx), reg);
+
+	if (can_dropped_invalid_skb(ndev, skb))
+		return NETDEV_TX_OK;
+
+	reg = rz_can_read(priv, RZ_CAN_RSCAN0CFSTSk(priv->k_tx));
+	if (reg & RZ_CAN_RSCAN0CFSTSk_CFFLL)
+		netif_stop_queue(ndev);
+
+	if (id & CAN_EFF_FLAG) {
+		/* Extended frame format */
+		reg = (id & CAN_EFF_MASK) | RZ_CAN_RSCAN0CFIDk_CFIDE;
+	} else {
+		/* Standard frame format */
+		reg = (id & CAN_SFF_MASK);
+	}
+
+	if (id & CAN_RTR_FLAG) {
+		/* Remote transmission request */
+		reg |= RZ_CAN_RSCAN0CFIDk_CFRTR;
+	}
+
+	rz_can_write(priv, RZ_CAN_RSCAN0CFIDk(priv->k_tx), reg);
+
+	rz_can_write(priv, RZ_CAN_RSCAN0CFPTRk(priv->k_tx),
+		     RZ_CAN_RSCAN0CFPTRk_CFDLC(dlc));
+
+	for (b = 0; b < 2; b++) {
+		reg = 0;
+		for (s = 0; s < 4; s++)
+			reg |= RZ_CAN_RSCAN0CFDFbk_CFDB(data[(b * 4) + s], s);
+		rz_can_write(priv, RZ_CAN_RSCAN0CFDFbk(priv->k_tx, b), reg);
+	}
+
+	spin_lock_irqsave(&priv->skb_lock, flags);
+	can_put_echo_skb(skb, ndev, priv->frames_queued++);
+	priv->bytes_queued += dlc;
+	spin_unlock_irqrestore(&priv->skb_lock, flags);
+
+	rz_can_write(priv, RZ_CAN_RSCAN0CFPCTRk(priv->k_tx), 0xff);
+
+	return 0;
+}
+
+static void rz_can_rx_pkt(struct net_device *ndev)
+{
+	struct rz_can_priv *priv = netdev_priv(ndev);
+	struct net_device_stats *stats = &ndev->stats;
+	struct sk_buff *skb;
+	struct can_frame *cf;
+	int b, s;
+	u32 reg;
+
+	while (!(rz_can_read(priv, RZ_CAN_RSCAN0CFSTSk(priv->k_rx)) & RZ_CAN_RSCAN0CFSTSk_CFEMP)) {
+
+		skb = alloc_can_skb(ndev, &cf);
+		if (!skb) {
+			stats->rx_dropped++;
+			return;
+		}
+
+		reg = rz_can_read(priv, RZ_CAN_RSCAN0CFIDk(priv->k_rx));
+
+		if (reg & RZ_CAN_RSCAN0CFIDk_CFIDE) {
+			/* Extended ID */
+			cf->can_id = (reg & CAN_EFF_MASK) | CAN_EFF_FLAG;
+		} else {
+			/* Standard ID */
+			cf->can_id = (reg & CAN_SFF_MASK);
+		}
+
+		if (reg & RZ_CAN_RSCAN0CFIDk_CFRTR)
+			cf->can_id |= CAN_RTR_FLAG;
+
+		for (b = 0; b < 2; b++) {
+			reg = rz_can_read(priv, RZ_CAN_RSCAN0CFDFbk(priv->k_rx, b));
+//			printk(KERN_EMERG "[CAN-rx-pkt] 0x%08X\n", reg);
+			for (s = 0; s < 4; s++)	{
+				cf->data[(b * 4) + s] = reg & 0x000000ff;
+				reg >>= 8;
+			}
+		}
+
+		reg = rz_can_read(priv, RZ_CAN_RSCAN0CFPTRk(priv->k_rx));
+		cf->can_dlc = RZ_CAN_RSCAN0CFPTRk_CFDLC_G(reg);
+
+		rz_can_write(priv, RZ_CAN_RSCAN0CFPCTRk(priv->k_rx), 0xff);
+		netif_rx(skb);
+
+		stats->rx_packets++;
+		stats->rx_bytes += cf->can_dlc;
+	}
+}
+
+static void rz_can_tx_failure_cleanup(struct net_device *ndev)
+{
+	int i;
+
+	for (i = 0; i < RZ_CAN_TX_ECHO_SKB_MAX; i++)
+		can_free_echo_skb(ndev, i);
+}
+
+static void rz_can_err(struct net_device *ndev)
+{
+	struct rz_can_priv *priv = netdev_priv(ndev);
+	struct net_device_stats *stats = &ndev->stats;
+	struct can_frame *cf;
+	struct sk_buff *skb;
+	u8 txerr = 0, rxerr = 0;
+	u32 reg;
+
+	skb = alloc_can_err_skb(ndev, &cf);
+	if (!skb)
+		return;
+
+	reg = rz_can_read(priv, RZ_CAN_RSCAN0CmERFL(priv->m));
+	if (reg & (RZ_CAN_RSCAN0CmERFL_EPF | RZ_CAN_RSCAN0CmERFL_EWF)) {
+		u32 sts = rz_can_read(priv, RZ_CAN_RSCAN0CmSTS(priv->m));
+		cf->can_id |= CAN_ERR_CRTL;
+		txerr = RZ_CAN_RSCAN0CmSTS_TEC(sts);
+		rxerr = RZ_CAN_RSCAN0CmSTS_REC(sts);
+		cf->data[6] = txerr;
+		cf->data[7] = rxerr;
+	}
+
+	if (reg & RZ_CAN_RSCAN0CmERFL_BEF) {
+		int rx_errors = 0, tx_errors = 0;
+
+		netdev_dbg(priv->ndev, "Bus error interrupt:\n");
+		cf->can_id |= CAN_ERR_BUSERROR | CAN_ERR_PROT;
+		cf->data[2] = CAN_ERR_PROT_UNSPEC;
+
+		if (reg & RZ_CAN_RSCAN0CmERFL_ADERR) {
+			netdev_dbg(priv->ndev, "ACK Delimiter Error\n");
+			cf->data[3] |= CAN_ERR_PROT_LOC_ACK_DEL;
+			tx_errors++;
+			reg &= ~RZ_CAN_RSCAN0CmERFL_ADERR;
+		}
+
+		if (reg & RZ_CAN_RSCAN0CmERFL_B0ERR) {
+			netdev_dbg(priv->ndev, "Bit Error (dominant)\n");
+			cf->data[2] |= CAN_ERR_PROT_BIT0;
+			tx_errors++;
+			reg &= ~RZ_CAN_RSCAN0CmERFL_B0ERR;
+		}
+
+		if (reg & RZ_CAN_RSCAN0CmERFL_B1ERR) {
+			netdev_dbg(priv->ndev, "Bit Error (recessive)\n");
+			cf->data[2] |= CAN_ERR_PROT_BIT1;
+			tx_errors++;
+			reg &= ~RZ_CAN_RSCAN0CmERFL_B1ERR;
+		}
+
+		if (reg & RZ_CAN_RSCAN0CmERFL_CERR) {
+			netdev_dbg(priv->ndev, "CRC Error\n");
+			cf->data[3] |= CAN_ERR_PROT_LOC_CRC_SEQ;
+			rx_errors++;
+			reg &= ~RZ_CAN_RSCAN0CmERFL_CERR;
+		}
+
+		if (reg & RZ_CAN_RSCAN0CmERFL_AERR) {
+			netdev_dbg(priv->ndev, "ACK Error\n");
+			cf->can_id |= CAN_ERR_ACK;
+			cf->data[3] |= CAN_ERR_PROT_LOC_ACK;
+			tx_errors++;
+			reg &= ~RZ_CAN_RSCAN0CmERFL_AERR;
+		}
+
+		if (reg & RZ_CAN_RSCAN0CmERFL_FERR) {
+			netdev_dbg(priv->ndev, "Form Error\n");
+			cf->data[2] |= CAN_ERR_PROT_FORM;
+			rx_errors++;
+			reg &= ~RZ_CAN_RSCAN0CmERFL_FERR;
+		}
+
+		if (reg & RZ_CAN_RSCAN0CmERFL_SERR) {
+			netdev_dbg(priv->ndev, "Stuff Error\n");
+			cf->data[2] |= CAN_ERR_PROT_STUFF;
+			rx_errors++;
+			reg &= ~RZ_CAN_RSCAN0CmERFL_SERR;
+		}
+
+		priv->can.can_stats.bus_error++;
+		ndev->stats.rx_errors += rx_errors;
+		ndev->stats.tx_errors += tx_errors;
+
+		reg &= ~RZ_CAN_RSCAN0CmERFL_BEF;
+		rz_can_write(priv, RZ_CAN_RSCAN0CmERFL(priv->m), reg);
+	}
+
+	if (reg & RZ_CAN_RSCAN0CmERFL_EWF) {
+		netdev_dbg(priv->ndev, "Error warning interrupt\n");
+		priv->can.state = CAN_STATE_ERROR_WARNING;
+		priv->can.can_stats.error_warning++;
+		cf->data[1] |= txerr > rxerr ? CAN_ERR_CRTL_TX_WARNING :
+					       CAN_ERR_CRTL_RX_WARNING;
+		reg &= ~RZ_CAN_RSCAN0CmERFL_EWF;
+		rz_can_write(priv, RZ_CAN_RSCAN0CmERFL(priv->m), reg);
+	}
+
+	if (reg & RZ_CAN_RSCAN0CmERFL_EPF) {
+		netdev_dbg(priv->ndev, "Error passive interrupt\n");
+		priv->can.state = CAN_STATE_ERROR_PASSIVE;
+		priv->can.can_stats.error_passive++;
+		cf->data[1] |= txerr > rxerr ? CAN_ERR_CRTL_TX_PASSIVE :
+					       CAN_ERR_CRTL_RX_PASSIVE;
+		reg &= ~RZ_CAN_RSCAN0CmERFL_EPF;
+		rz_can_write(priv, RZ_CAN_RSCAN0CmERFL(priv->m), reg);
+	}
+
+	if (reg & RZ_CAN_RSCAN0CmERFL_BOEF) {
+		netdev_dbg(priv->ndev, "Bus-off entry interrupt\n");
+		rz_can_tx_failure_cleanup(ndev);
+		priv->can.state = CAN_STATE_BUS_OFF;
+		cf->can_id |= CAN_ERR_BUSOFF;
+		reg &= ~RZ_CAN_RSCAN0CmERFL_BOEF;
+		rz_can_write(priv, RZ_CAN_RSCAN0CmERFL(priv->m), reg);
+		can_bus_off(ndev);
+	}
+
+	if (reg & RZ_CAN_RSCAN0CmERFL_OVLF) {
+		netdev_dbg(priv->ndev, "Overload Frame Transmission error interrupt\n");
+		cf->can_id |= CAN_ERR_PROT;
+		cf->data[2] |= CAN_ERR_PROT_OVERLOAD;
+		ndev->stats.rx_over_errors++;
+		ndev->stats.rx_errors++;
+		reg &= RZ_CAN_RSCAN0CmERFL_OVLF;
+		rz_can_write(priv, RZ_CAN_RSCAN0CmERFL(priv->m), reg);
+	}
+
+	netif_rx(skb);
+	stats->rx_packets++;
+	stats->rx_bytes += cf->can_dlc;
+}
+
+irqreturn_t rz_can_interrupt(int irq, void *dev_id)
+{
+	struct net_device *ndev = dev_id;
+	struct rz_can_priv *priv = netdev_priv(ndev);
+	struct net_device_stats *stats = &ndev->stats;
+	u32 reg_tx, reg_rx;
+	int i;
+
+	reg_tx = rz_can_read(priv, RZ_CAN_RSCAN0CFSTSk(priv->k_tx));
+	reg_rx = rz_can_read(priv, RZ_CAN_RSCAN0CFSTSk(priv->k_rx));
+
+	if ((irq == priv->tx_irq) && (reg_tx & RZ_CAN_RSCAN0CFSTSk_CFTXIF)) {
+		spin_lock(&priv->skb_lock);
+		for (i = 0; i < priv->frames_queued; i++)
+			can_get_echo_skb(ndev, i);
+		stats->tx_bytes += priv->bytes_queued;
+		stats->tx_packets += priv->frames_queued;
+		priv->bytes_queued = 0;
+		priv->frames_queued = 0;
+		spin_unlock(&priv->skb_lock);
+
+		netif_wake_queue(ndev);
+
+		reg_tx &= ~RZ_CAN_RSCAN0CFSTSk_CFTXIF;
+		rz_can_write(priv, RZ_CAN_RSCAN0CFSTSk(priv->k_tx), reg_tx);
+	}
+
+	if ((irq == priv->rx_irq) && (reg_rx & RZ_CAN_RSCAN0CFSTSk_CFRXIF)) {
+		rz_can_rx_pkt(ndev);
+		reg_rx &= ~RZ_CAN_RSCAN0CFSTSk_CFRXIF;
+		rz_can_write(priv, RZ_CAN_RSCAN0CFSTSk(priv->k_rx), reg_rx);
+	}
+
+	if (irq == priv->err_irq_g) {
+		reg_tx &= ~RZ_CAN_RSCAN0CFSTSk_CFMLT;
+		reg_rx &= ~RZ_CAN_RSCAN0CFSTSk_CFMLT;
+
+		rz_can_write(priv, RZ_CAN_RSCAN0CFSTSk(priv->k_tx), reg_tx);
+		rz_can_write(priv, RZ_CAN_RSCAN0CFSTSk(priv->k_rx), reg_rx);
+
+		netdev_dbg(ndev, "A transmit/receive FIFO message is lost.\n");
+	}
+
+	if (irq == priv->err_irq_m)
+		rz_can_err(ndev);
+
+	return IRQ_HANDLED;
+}
+
+static int rz_can_wait(struct rz_can_priv *priv, unsigned long offset,
+		       unsigned int mask, unsigned int ms_timeout)
+{
+	const unsigned long timeout = jiffies + msecs_to_jiffies(ms_timeout);
+	u32 reg;
+
+	do {
+		reg = rz_can_read(priv, offset);
+		reg = ~reg;
+		reg &= mask;
+
+		if (reg == mask)
+			return 0;
+
+	} while (time_before(jiffies, timeout));
+
+	return -ETIMEDOUT;
+}
+
+static int rz_can_start(struct net_device *ndev)
+{
+	struct rz_can_priv *priv = netdev_priv(ndev);
+	u32 reg;
+
+	if (rz_can_wait(priv, RZ_CAN_RSCAN0GSTS, RZ_CAN_RSCAN0GSTS_GRAMINIT, 50))
+		return -ETIMEDOUT;
+
+	/* Go to reset mode */
+	reg = rz_can_read(priv, RZ_CAN_RSCAN0GCTR);
+	reg &= ~RZ_CAN_RSCAN0GCTR_GSLPR;
+	rz_can_write(priv, RZ_CAN_RSCAN0GCTR, reg);
+
+	/* From channel stop mode to channel reset mode */
+	reg = rz_can_read(priv, RZ_CAN_RSCAN0CmCTR(priv->m));
+	reg &= ~RZ_CAN_RSCAN0CmCTR_CSLPR;
+	rz_can_write(priv, RZ_CAN_RSCAN0CmCTR(priv->m), reg);
+
+	/* Clock and bittiming */
+	rz_can_set_bittiming(ndev);
+
+	/* Receive rule setting */
+
+	/* 1 rule for channel m */
+	rz_can_write(priv, RZ_CAN_RSCAN0GAFLCFG0,
+		      RZ_CAN_RSCAN0GAFLCFG0_RNC(priv->m, 1));
+
+	/* Page 0 */
+	reg = RZ_CAN_RSCAN0GAFLECTR_AFLDAE;
+	reg |= RZ_CAN_RSCAN0GAFLECTR_AFLPN(0);
+	rz_can_write(priv, RZ_CAN_RSCAN0GAFLECTR, reg);
+
+	/* Create the receive rule */
+	rz_can_write(priv, RZ_CAN_RSCAN0GAFLMj(0), 0);
+	rz_can_write(priv, RZ_CAN_RSCAN0GAFLP0j(0), 0);
+	rz_can_write(priv, RZ_CAN_RSCAN0GAFLP1j(0),
+		     RZ_CAN_GAFLID_TXRX_FIFO_M(priv->k_rx));
+
+	reg = rz_can_read(priv, RZ_CAN_RSCAN0GAFLECTR);
+	reg &= ~RZ_CAN_RSCAN0GAFLECTR_AFLDAE;
+	rz_can_write(priv, RZ_CAN_RSCAN0GAFLECTR, reg);
+
+	/* Buffer settings */
+
+	/* RX: transmit/receive FIFO buffer (full depth, IRQ for each ptk) */
+	reg = RZ_CAN_RSCAN0CFCCk_CFM(CFM_RX_MODE);
+	reg |= RZ_CAN_RSCAN0CFCCk_CFIM;
+	reg |= RZ_CAN_RSCAN0CFCCk_CFDC(RZ_CAN_CFCD_FULL);
+	reg |= RZ_CAN_RSCAN0CFCCk_CFRXIE;
+//	reg |= RZ_CAN_RSCAN0CFCCk_CFE;
+	rz_can_write(priv, RZ_CAN_RSCAN0CFCCk(priv->k_rx), reg);
+
+	/* TX: transmit/receive FIFO buffer (full depth, IRQ for each ptk) */
+	reg = RZ_CAN_RSCAN0CFCCk_CFM(CFM_TX_MODE);
+	reg |= RZ_CAN_RSCAN0CFCCk_CFIM;
+	reg |= RZ_CAN_RSCAN0CFCCk_CFDC(RZ_CAN_CFCD_FULL);
+	reg |= RZ_CAN_RSCAN0CFCCk_CFTML(RZ_CAN_CFTML);
+	reg |= RZ_CAN_RSCAN0CFCCk_CFTXIE;
+	rz_can_write(priv, RZ_CAN_RSCAN0CFCCk(priv->k_tx), reg);
+
+	/* RSCAN0CmCTR / RSCAN0CmCTR register setting */
+	reg = rz_can_read(priv, RZ_CAN_RSCAN0GCTR);
+	reg |= RZ_CAN_RSCAN0GCTR_MEIE;
+	rz_can_write(priv, RZ_CAN_RSCAN0GCTR, reg);
+
+	reg = rz_can_read(priv, RZ_CAN_RSCAN0CmCTR(priv->m));
+	reg |= (RZ_CAN_RSCAN0CmCTR_EPIE | RZ_CAN_RSCAN0CmCTR_EWIE);
+	reg |= (RZ_CAN_RSCAN0CmCTR_BOEIE | RZ_CAN_RSCAN0CmCTR_BEIE);
+	reg |= RZ_CAN_RSCAN0CmCTR_OLIE;
+	rz_can_write(priv, RZ_CAN_RSCAN0CmCTR(priv->m), reg);
+
+	/* Transition to global operating mode */
+	reg = rz_can_read(priv, RZ_CAN_RSCAN0GCTR);
+	reg &= ~RZ_CAN_RSCAN0GCTR_GMDC_M;
+	reg |= RZ_CAN_RSCAN0GCTR_GMDC(OP_MODE);
+	rz_can_write(priv, RZ_CAN_RSCAN0GCTR, reg);
+
+	/* Transition to channel comm mode */
+	reg = rz_can_read(priv, RZ_CAN_RSCAN0CmCTR(priv->m));
+	reg &= ~RZ_CAN_RSCAN0CmCTR_CHMDC_M;
+	reg |= RZ_CAN_RSCAN0CmCTR_CHMDC(OP_MODE);
+	rz_can_write(priv, RZ_CAN_RSCAN0CmCTR(priv->m), reg);
+
+	priv->can.state = CAN_STATE_ERROR_ACTIVE;
+
+	reg = rz_can_read(priv, RZ_CAN_RSCAN0CFCCk(priv->k_rx));
+	reg |= RZ_CAN_RSCAN0CFCCk_CFE;
+	rz_can_write(priv, RZ_CAN_RSCAN0CFCCk(priv->k_rx), reg);
+
+
+	return 0;
+}
+
+static int rz_can_open(struct net_device *ndev)
+{
+	struct rz_can_priv *priv = netdev_priv(ndev);
+	int err;
+
+	err = clk_enable(priv->clk);
+	if (err < 0)
+		goto exit_open;
+
+	/* common open */
+	err = open_candev(ndev);
+	if (err)
+		goto exit_open;
+
+	/* register interrupt handler */
+	err = request_irq(priv->rx_irq, &rz_can_interrupt, 0,
+			"rz-can-rx", ndev);
+	if (err)
+		goto exit_rx_irq;
+
+	err = request_irq(priv->tx_irq, &rz_can_interrupt, 0,
+			"rz-can-tx", ndev);
+	if (err)
+		goto exit_tx_irq;
+
+	err = request_irq(priv->err_irq_m, &rz_can_interrupt, 0,
+			"rz-can-err-m", ndev);
+	if (err)
+		goto exit_err_irq_m;
+
+	err = request_irq(priv->err_irq_g, &rz_can_interrupt, 0,
+			"rz-can-err-g", ndev);
+	if (err)
+		goto exit_err_irq_g;
+
+	err = rz_can_start(ndev);
+	if (err)
+		goto exit_err_irq_g;
+
+	netif_start_queue(ndev);
+
+	return 0;
+
+exit_err_irq_g:
+	free_irq(priv->err_irq_m, ndev);
+exit_err_irq_m:
+	free_irq(priv->tx_irq, ndev);
+exit_tx_irq:
+	free_irq(priv->rx_irq, ndev);
+exit_rx_irq:
+	close_candev(ndev);
+exit_open:
+	return err;
+}
+
+static void rz_can_stop(struct net_device *ndev)
+{
+	struct rz_can_priv *priv = netdev_priv(ndev);
+	u32 reg;
+
+	/* Transition to global stop mode */
+	reg = rz_can_read(priv, RZ_CAN_RSCAN0GCTR);
+	reg &= ~RZ_CAN_RSCAN0GCTR_GMDC_M;
+	reg |= RZ_CAN_RSCAN0GCTR_GMDC(RST_MODE);
+	rz_can_write(priv, RZ_CAN_RSCAN0GCTR, reg);
+
+	/* Transition to channel comm mode */
+	reg = rz_can_read(priv, RZ_CAN_RSCAN0CmCTR(priv->m));
+	reg &= ~RZ_CAN_RSCAN0CmCTR_CHMDC_M;
+	reg |= RZ_CAN_RSCAN0CmCTR_CHMDC(RST_MODE);
+	rz_can_write(priv, RZ_CAN_RSCAN0CmCTR(priv->m), reg);
+
+	/* Go to stop mode */
+	reg = rz_can_read(priv, RZ_CAN_RSCAN0GCTR);
+	reg |= RZ_CAN_RSCAN0GCTR_GSLPR;
+	rz_can_write(priv, RZ_CAN_RSCAN0GCTR, reg);
+
+	/* From channel reset mode to channel stop mode */
+	reg = rz_can_read(priv, RZ_CAN_RSCAN0CmCTR(priv->m));
+	reg |= RZ_CAN_RSCAN0CmCTR_CSLPR;
+	rz_can_write(priv, RZ_CAN_RSCAN0CmCTR(priv->m), reg);
+}
+
+static int rz_can_close(struct net_device *ndev)
+{
+	struct rz_can_priv *priv = netdev_priv(ndev);
+
+	netif_stop_queue(ndev);
+	rz_can_stop(ndev);
+	free_irq(priv->tx_irq, ndev);
+	free_irq(priv->rx_irq, ndev);
+	free_irq(priv->err_irq_m, ndev);
+	free_irq(priv->err_irq_g, ndev);
+	clk_disable(priv->clk);
+	close_candev(ndev);
+
+	return 0;
+}
+
+static int rz_can_do_set_mode(struct net_device *ndev, enum can_mode mode)
+{
+	switch (mode) {
+	case CAN_MODE_START:
+		rz_can_start(ndev);
+		if (netif_queue_stopped(ndev))
+			netif_wake_queue(ndev);
+		break;
+
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
+static const struct net_device_ops rz_can_netdev_ops = {
+	.ndo_open               = rz_can_open,
+	.ndo_stop               = rz_can_close,
+	.ndo_start_xmit         = rz_can_start_xmit,
+};
+
+static int rz_can_probe(struct platform_device *pdev)
+{
+	struct rz_can_platform_data *pdata;
+	struct rz_can_priv *priv;
+	struct net_device *ndev;
+	struct resource *mem;
+	int err = -ENODEV;
+	int rx_irq, tx_irq, err_irq_m, err_irq_g;
+
+	pdata = dev_get_platdata(&pdev->dev);
+	if (!pdata) {
+		dev_err(&pdev->dev, "No platform data provided!\n");
+		goto fail;
+	}
+
+	rskrza1_board_can_pfc_assign(pdata->channel);
+
+	rx_irq = platform_get_irq(pdev, 0);
+	tx_irq = platform_get_irq(pdev, 1);
+	err_irq_m = platform_get_irq(pdev, 2);
+	err_irq_g = platform_get_irq(pdev, 3);
+	if (!rx_irq || !tx_irq || !err_irq_m || !err_irq_g) {
+		dev_err(&pdev->dev, "No IRQ resource\n");
+		goto fail;
+	}
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!mem) {
+		dev_err(&pdev->dev, "No mem resource\n");
+		goto fail;
+	}
+
+	if (!request_mem_region(mem->start, resource_size(mem),
+				dev_name(&pdev->dev))) {
+		err = -EBUSY;
+		goto fail;
+	}
+
+	ndev = alloc_candev(sizeof(struct rz_can_priv), RZ_CAN_TX_ECHO_SKB_MAX);
+	if (!ndev) {
+		dev_err(&pdev->dev, "alloc_candev failed\n");
+		err = -ENOMEM;
+		goto fail;
+	}
+
+	priv = netdev_priv(ndev);
+
+	priv->clk = devm_clk_get(&pdev->dev, "can");
+	if (IS_ERR(priv->clk)) {
+		err = PTR_ERR(priv->clk);
+		dev_err(&pdev->dev, "cannot get clock: %d\n", err);
+		goto fail_clk;
+	}
+
+	ndev->netdev_ops = &rz_can_netdev_ops;
+	ndev->flags |= IFF_ECHO;
+	priv->ndev = ndev;
+	priv->base = (void __iomem *) mem->start;
+	priv->clock_select = pdata->clock_select;
+	priv->m = pdata->channel;
+	priv->tx_irq = tx_irq;
+	priv->rx_irq = rx_irq;
+	priv->err_irq_m = err_irq_m;
+	priv->err_irq_g = err_irq_g;
+	priv->k_tx = RZ_CAN_FIFO_K(priv->m, RZ_CAN_TX_FIFO);
+	priv->k_rx = RZ_CAN_FIFO_K(priv->m, RZ_CAN_RX_FIFO);
+
+	priv->can.clock.freq = (clk_get_rate(priv->clk) / 2);
+	priv->can.bittiming_const = &rz_can_bittiming_const;
+	priv->can.do_set_mode = rz_can_do_set_mode;
+	priv->can.do_get_berr_counter = rz_can_get_berr_counter;
+	priv->can.ctrlmode_supported = CAN_CTRLMODE_BERR_REPORTING;
+
+	platform_set_drvdata(pdev, ndev);
+	SET_NETDEV_DEV(ndev, &pdev->dev);
+	spin_lock_init(&priv->skb_lock);
+
+	err = register_candev(ndev);
+	if (err) {
+		dev_err(&pdev->dev, "register_candev() failed\n");
+		goto fail_clk;
+	}
+
+	dev_info(&pdev->dev, "device registered (clock: %d, ch: %d, k_tx: %d, k_rx: %d)\n",
+			priv->can.clock.freq, priv->m, priv->k_tx, priv->k_rx);
+
+	return 0;
+
+fail_clk:
+	free_candev(ndev);
+fail:
+	return err;
+}
+
+static int rz_can_remove(struct platform_device *pdev)
+{
+	struct net_device *ndev = dev_get_drvdata(&pdev->dev);
+
+	unregister_candev(ndev);
+	free_candev(ndev);
+
+	return 0;
+}
+
+static struct platform_driver rz_can_driver = {
+	.probe = rz_can_probe,
+	.remove = rz_can_remove,
+	.driver = {
+		.name = DRV_NAME,
+		.owner = THIS_MODULE,
+	},
+};
+
+module_platform_driver(rz_can_driver);
+
+MODULE_AUTHOR("Carlo Caione <carlo@caione.org>");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("RZ/A1 on-chip CAN netdevice driver");
+MODULE_ALIAS("platform:" DRV_NAME);
diff --git a/drivers/video/renesas/vdc5fb-regs.h b/drivers/video/renesas/vdc5fb-regs.h
index e713749..45440b1 100644
--- a/drivers/video/renesas/vdc5fb-regs.h
+++ b/drivers/video/renesas/vdc5fb-regs.h
@@ -484,6 +484,24 @@ enum {
 	VDC5FB_MAX_IRQS,
 };
 
+enum {
+	LVDS_UPDATE = 0,
+	LVDSFCL,
+	LCLKSELR,
+	LPLLSETR,
+	LPLLMONR,
+	VDC5FB_LVDS_MAX_REGS
+};
+
+#define	VDC5FB_LVDS_OFFSET(x)	((x) - VDC5FB_REG_LVDS)
+static unsigned long vdc5fb_lvds_offsets[VDC5FB_LVDS_MAX_REGS] = {
+	[LVDS_UPDATE]		= VDC5FB_LVDS_OFFSET(0xFCFF7A30),
+	[LVDSFCL]		= VDC5FB_LVDS_OFFSET(0xFCFF7A34),
+	[LCLKSELR]		= VDC5FB_LVDS_OFFSET(0xFCFF7A50),
+	[LPLLSETR]		= VDC5FB_LVDS_OFFSET(0xFCFF7A54),
+	[LPLLMONR]		= VDC5FB_LVDS_OFFSET(0xFCFF7A58),
+};
+
 /* REGISTER ADDRESS OFFSET */
 #define	VDC5FB_OFFSET(x)	((x) - VDC5FB_REG_BASE(0))
 static unsigned long vdc5fb_offsets[VDC5FB_MAX_REGS] = {
@@ -955,6 +973,22 @@ static const char *irq_names[VDC5FB_MAX_IRQS] = {
 	((((a) & 0xffu) << 24) | (((g) & 0xffu) << 16) \
 	| (((b) & 0xffu) << 8) | ((r) & 0xffu))
 
+/* LVDS */
+#define LVDS_CLK_EN		(1u << 4)
+#define LVDS_PLL_PD		(1u << 0)
+#define LVDS_VDC_SEL		(1u << 1)
+#define LVDS_PLL_LD		(1u << 0)
+#define LVDS_LCLKSELR_MASK	(0x0703FF02u)
+#define LVDS_LPLLSETR_MASK	(0x07FF1F30u)
+
+#define LVDS_SET_IN_CLK_SEL(x)	(((x) & 0x7) << 24)
+#define LVDS_SET_IDIV(x)	(((x) & 0x3) << 16)
+#define LVDS_SET_TST(x)		(((x) & 0x3f) << 10)
+#define LVDS_SET_ODIV(x)	(((x) & 0x3) << 8)
+#define LVDS_SET_FD(x)		(((x) & 0x7ff) << 16)
+#define LVDS_SET_RD(x)		(((x) & 0x1f) << 8)
+#define LVDS_SET_OD(x)		(((x) & 0x3) << 4)
+
 /* SYSCNT_PANEL_CLK */
 #define	PANEL_DCDR(x)		(((x) & 0x3fu) << 0)
 #define PANEL_ICKEN		(1u << 8)
@@ -1107,6 +1141,16 @@ static unsigned long vdc5fb_read(struct vdc5fb_priv *priv, int reg)
 		return ioread32(priv->base + vdc5fb_offsets[reg]);
 }
 
+static void vdc5fb_lvds_write(struct vdc5fb_priv *priv, int reg, u32 data)
+{
+	iowrite32((u32)data, (priv->lvds_base + vdc5fb_lvds_offsets[reg]));
+}
+
+static unsigned long vdc5fb_lvds_read(struct vdc5fb_priv *priv, int reg)
+{
+	return ioread32(priv->lvds_base + vdc5fb_lvds_offsets[reg]);
+}
+
 static void vdc5fb_setbits(struct vdc5fb_priv *priv, int reg, u32 bits)
 {
 	u32 tmp;
diff --git a/drivers/video/renesas/vdc5fb.c b/drivers/video/renesas/vdc5fb.c
index 1a2f222..5485c64 100644
--- a/drivers/video/renesas/vdc5fb.c
+++ b/drivers/video/renesas/vdc5fb.c
@@ -50,10 +50,12 @@ struct vdc5fb_priv {
 	struct clk *lvds_clk;
 	/* framebuffers */
 	void __iomem *base;
+	void __iomem *lvds_base;
 	dma_addr_t dma_handle;
 	unsigned long flm_off;
 	unsigned long flm_num;
 	int fb_nofree;
+	int id;
 	/* irq */
 	struct {
 		int start;		/* start irq number */
@@ -77,6 +79,7 @@ struct vdc5fb_priv {
 
 /************************************************************************/
 
+static int vdc5fb_init_lvds(struct vdc5fb_priv *priv);
 static int vdc5fb_init_syscnt(struct vdc5fb_priv *priv);
 static int vdc5fb_init_sync(struct vdc5fb_priv *priv);
 static int vdc5fb_init_scalers(struct vdc5fb_priv *priv);
@@ -283,11 +286,18 @@ static int vdc5fb_set_panel_clock(struct vdc5fb_priv *priv,
 	unsigned long desired;
 	unsigned long source;
 	unsigned long used;
+	struct vdc5fb_pdata *pdata = priv_to_pdata(priv);
 	int n;
 
 	source = clk_get_rate(priv->dot_clk);
 	BUG_ON(source == 0);
 
+	/* Fix this */
+	if (pdata->use_lvds) {
+		priv->dcdr = 1;
+		return 0;
+	}
+
 	(void)do_div(desired64, mode->pixclock);
 	desired = (unsigned long)desired64;
 	for (n = 0; n < ARRAY_SIZE(dcdr_list); n++) {
@@ -303,6 +313,83 @@ static int vdc5fb_set_panel_clock(struct vdc5fb_priv *priv,
 
 /************************************************************************/
 
+static int vdc5fb_init_lvds(struct vdc5fb_priv *priv)
+{
+	struct vdc5fb_pdata *pdata = priv_to_pdata(priv);
+	struct vdc5fb_lvds_info *lvds = &pdata->lvds;
+	u32 tmp;
+
+	tmp = vdc5fb_read(priv, SYSCNT_PANEL_CLK);
+	tmp &= ~PANEL_ICKEN;
+	vdc5fb_write(priv, SYSCNT_PANEL_CLK, tmp);
+
+	/* LCLKSELR: LVDS clock select register */
+	tmp = vdc5fb_lvds_read(priv, LCLKSELR);
+	tmp &= ~LVDS_LCLKSELR_MASK;
+	vdc5fb_lvds_write(priv, LCLKSELR, tmp);
+
+	/* The clock input to frequency divider 1 */
+	tmp |= LVDS_SET_IN_CLK_SEL(lvds->lvds_in_clk_sel);
+	vdc5fb_lvds_write(priv, LCLKSELR, tmp);
+
+	/* The frequency dividing value (NIDIV) for frequency divider 1 */
+	tmp |= LVDS_SET_IDIV(lvds->lvds_idiv_set);
+	vdc5fb_lvds_write(priv, LCLKSELR, tmp);
+
+
+	/* The frequency dividing value (NODIV) for frequency divider 2 */
+	tmp |= LVDS_SET_ODIV(lvds->lvds_odiv_set);
+	vdc5fb_lvds_write(priv, LCLKSELR, tmp);
+
+	/* A channel in VDC5 whose data is to be output through the LVDS */
+	if (priv->id != 0)
+		tmp |= LVDS_VDC_SEL;
+	vdc5fb_lvds_write(priv, LCLKSELR, tmp);
+
+	mdelay(1);
+
+	/* LPLLSETR: LVDS PLL setting register */
+	tmp = vdc5fb_lvds_read(priv, LPLLSETR);
+	tmp &= ~LVDS_LPLLSETR_MASK;
+	vdc5fb_lvds_write(priv, LPLLSETR, tmp);
+
+	/* The frequency dividing value (NFD) for the feedback frequency */
+	tmp |= LVDS_SET_FD(lvds->lvds_pll_fd);
+	vdc5fb_lvds_write(priv, LPLLSETR, tmp);
+
+	/* The frequency dividing value (NRD) for the input frequency */
+	tmp |= LVDS_SET_RD(lvds->lvds_pll_rd);
+	vdc5fb_lvds_write(priv, LPLLSETR, tmp);
+
+	/* The frequency dividing value (NOD) for the output frequency */
+	tmp |= LVDS_SET_OD(lvds->lvds_pll_od);
+	vdc5fb_lvds_write(priv, LPLLSETR, tmp);
+
+	tmp = vdc5fb_lvds_read(priv, LCLKSELR);
+	/* Internal parameter setting for LVDS PLL */
+	tmp |= LVDS_SET_TST(lvds->lvds_pll_tst);
+	vdc5fb_lvds_write(priv, LCLKSELR, tmp);
+
+	mdelay(1);
+
+	tmp = vdc5fb_lvds_read(priv, LPLLSETR);
+	/* Controls power-down for the LVDS PLL: Normal operation */
+	tmp &= ~LVDS_PLL_PD;
+	vdc5fb_lvds_write(priv, LPLLSETR, tmp);
+
+	msleep(1);
+
+	while(1)
+		if ((vdc5fb_lvds_read(priv, LPLLMONR) & LVDS_PLL_LD) != 0)
+			break;
+
+	tmp = vdc5fb_lvds_read(priv, LCLKSELR);
+	tmp |= LVDS_CLK_EN;
+	vdc5fb_lvds_write(priv, LCLKSELR, tmp);
+
+	return 0;
+}
+
 static int vdc5fb_init_syscnt(struct vdc5fb_priv *priv)
 {
 	struct vdc5fb_pdata *pdata = priv_to_pdata(priv);
@@ -323,11 +410,18 @@ static int vdc5fb_init_syscnt(struct vdc5fb_priv *priv)
 
 	/* Setup panel clock */
 	tmp = PANEL_DCDR(priv->dcdr);
-	tmp |= PANEL_ICKEN;
-	tmp |= PANEL_OCKSEL(0);
+
+	if (!pdata->use_lvds)
+		tmp |= PANEL_OCKSEL(0);
+	else
+		tmp |= PANEL_OCKSEL(pdata->panel_ocksel);
+
 	tmp |= PANEL_ICKSEL(pdata->panel_icksel);
 	vdc5fb_write(priv, SYSCNT_PANEL_CLK, tmp);
 
+	tmp |= PANEL_ICKEN;
+	vdc5fb_write(priv, SYSCNT_PANEL_CLK, tmp);
+
 	return 0;
 }
 
@@ -754,6 +848,8 @@ static void vdc5fb_set_videomode(struct vdc5fb_priv *priv,
 		priv->flm_off += 0x1000;
 	priv->flm_num = 0;
 
+	if (pdata->use_lvds)
+		vdc5fb_init_lvds(priv);
 	vdc5fb_init_syscnt(priv);
 	vdc5fb_init_sync(priv);
 	vdc5fb_init_scalers(priv);
@@ -1102,6 +1198,12 @@ static int vdc5fb_start(struct vdc5fb_priv *priv)
 			return error;
 	}
 
+	if (pdata->use_lvds) {
+		error = clk_enable(priv->lvds_clk);
+		if (error < 0)
+			return error;
+	}
+
 	vdc5fb_set_videomode(priv, NULL);
 
 	return error;
@@ -1141,6 +1243,7 @@ static int vdc5fb_probe(struct platform_device *pdev)
 	struct vdc5fb_pdata *pdata;
 	struct fb_info *info;
 	struct resource *res;
+	struct resource *lvds_res;
 	void *buf;
 
 	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
@@ -1159,6 +1262,7 @@ static int vdc5fb_probe(struct platform_device *pdev)
 		goto err1;
 	}
 	priv->pdata = pdata;
+	priv->id = pdev->id;
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!res) {
@@ -1171,6 +1275,20 @@ static int vdc5fb_probe(struct platform_device *pdev)
 		goto err1;
 	}
 
+	if (pdata->use_lvds) {
+		lvds_res =  platform_get_resource_byname(pdev, IORESOURCE_MEM, "lvds: reg");
+		if (!lvds_res) {
+			dev_err(&pdev->dev, "cannot get resources (lvds reg)\n");
+			goto err1;
+		}
+
+		priv->lvds_base = ioremap_nocache(lvds_res->start, resource_size(lvds_res));
+		if (!priv->lvds_base) {
+			dev_err(&pdev->dev, "cannot ioremap (lvds reg)\n");
+			goto err1;
+		}
+	}
+
 	error = vdc5fb_init_clocks(priv);
 	if (error) {
 		dev_err(&pdev->dev, "cannot init clocks\n");
diff --git a/include/linux/can/platform/rza1_can.h b/include/linux/can/platform/rza1_can.h
new file mode 100644
index 0000000..71e637f
--- /dev/null
+++ b/include/linux/can/platform/rza1_can.h
@@ -0,0 +1,15 @@
+#ifndef _CAN_PLATFORM_RZA1_CAN_H_
+#define _CAN_PLATFORM_RZA1_CAN_H_
+
+#include <linux/types.h>
+
+/* Clock Select Register settings */
+#define CLKR_CLKC		0
+#define CLKR_CLK_XINCAN		1
+
+struct rz_can_platform_data {
+	int clock_select;	/* Clock source select */
+	int channel;
+};
+
+#endif	/* !_CAN_PLATFORM_RZA1_CAN_H_ */
diff --git a/include/video/vdc5fb.h b/include/video/vdc5fb.h
index 6e78df8..d4aaf96 100644
--- a/include/video/vdc5fb.h
+++ b/include/video/vdc5fb.h
@@ -27,14 +27,17 @@
 #define	VDC5FB_NUM_CH		2
 
 /* NUMBER OF RESOURCES */
-#define	VDC5FB_NUM_RES		3
+#define	VDC5FB_NUM_RES		4
 /* MEM resource 0 is used for registers */
 /* MEM resource 1 is used for framebuffer(s) */
 /* IRQ resource 0 is used for irq numbers */
+/* MEM resource 2 is used for LVDS */
 
 /* BASE ADDRESS AND SIZE OF REGISTERS */
 #define	VDC5FB_REG_BASE(x)	(0xFCFF6000 + (0x2000 * (x)))
 #define	VDC5FB_REG_SIZE		0x2000
+#define VDC5FB_REG_LVDS		0xFCFF7A30
+#define VDC5FB_REG_LVDS_SIZE	0x2D
 
 /* START AND TOTAL NUMBER OF IRQS */
 #define	VDC5FB_IRQ_BASE(x)	(75 + (24 * (x)))
@@ -48,6 +51,12 @@ enum {
 	ICKSEL_P1CLK,
 };
 
+enum {
+	OCKSEL_ICK = 0,
+	OCKSEL_PLL,
+	OCKSEL_PLL_DIV7,
+};
+
 /* tcon_sel */
 enum {				/* index */
 	LCD_TCON0 = 0,
@@ -76,23 +85,63 @@ enum {
 	OUT_FORMAT_RGB565,
 };
 
+/*! The clock input to frequency divider 1 */
+enum {
+	VDC5_LVDS_INCLK_SEL_IMG = 0,	/*!< Video image clock (VIDEO_X1) */
+	VDC5_LVDS_INCLK_SEL_DV_0,	/*!< Video image clock (DV_CLK 0) */
+	VDC5_LVDS_INCLK_SEL_DV_1,	/*!< Video image clock (DV_CLK 1) */
+	VDC5_LVDS_INCLK_SEL_EXT_0,	/*!< External clock (LCD_EXTCLK 0) */
+	VDC5_LVDS_INCLK_SEL_EXT_1,	/*!< External clock (LCD_EXTCLK 1) */
+	VDC5_LVDS_INCLK_SEL_PERI,	/*!< Peripheral clock 1 */
+	VDC5_LVDS_INCLK_SEL_NUM
+};
+
+enum {
+	VDC5_LVDS_NDIV_1 = 0,		/*!< Div 1 */
+	VDC5_LVDS_NDIV_2,		/*!< Div 2 */
+	VDC5_LVDS_NDIV_4,		/*!< Div 4 */
+	VDC5_LVDS_NDIV_NUM
+};
+
+/*! The frequency dividing value (NOD) for the output frequency */
+enum {
+	VDC5_LVDS_PLL_NOD_1 = 0,	/*!< Div 1 */
+	VDC5_LVDS_PLL_NOD_2,		/*!< Div 2 */
+	VDC5_LVDS_PLL_NOD_4,		/*!< Div 4 */
+	VDC5_LVDS_PLL_NOD_8,		/*!< Div 8 */
+	VDC5_LVDS_PLL_NOD_NUM
+};
+
+struct vdc5fb_lvds_info {
+	int lvds_in_clk_sel;		/*!< The clock input to frequency divider 1 */
+	int lvds_idiv_set;		/*!< The frequency dividing value (NIDIV) for frequency divider 1 */
+	int lvds_pll_tst;		/*!< Internal parameter setting for LVDS PLL */
+	int lvds_odiv_set;		/*!< The frequency dividing value (NODIV) for frequency divider 2 */
+	int lvds_pll_fd;		/*!< The frequency dividing value (NFD) for the feedback frequency */
+	int lvds_pll_rd;		/*!< The frequency dividing value (NRD) for the input frequency */
+	int lvds_pll_od;		/*!< The frequency dividing value (NOD) for the output frequency */
+};
+
 /* board-specific data */
 struct vdc5fb_pdata {
 	const char *name;
 	struct fb_videomode *videomode;
 	int bpp;		/* should be 16 or 32 */
 	int panel_icksel;	/* should be ICKSEL_P1CLK */
+	int panel_ocksel;
 	unsigned long panel_width;
 	unsigned long panel_height;
 	unsigned long flm_max;
 	int out_format;
 	int use_lvds;
 	unsigned char tcon_sel[LCD_MAX_TCON];
+	struct vdc5fb_lvds_info lvds;
 /* board specific setting function */
 	int (*pinmux)(struct platform_device *pdev);
 	int (*reset)(struct platform_device *pdev);
 	int (*tcon)(struct platform_device *pdev);
 };
+
 #endif /* __KERNEL__ */
 
 /*****************/
-- 
1.8.4.1

